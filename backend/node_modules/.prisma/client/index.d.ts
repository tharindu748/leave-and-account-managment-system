
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Leave_request
 * 
 */
export type Leave_request = $Result.DefaultSelection<Prisma.$Leave_requestPayload>
/**
 * Model Leave_request_date
 * 
 */
export type Leave_request_date = $Result.DefaultSelection<Prisma.$Leave_request_datePayload>
/**
 * Model Leave_balance
 * 
 */
export type Leave_balance = $Result.DefaultSelection<Prisma.$Leave_balancePayload>
/**
 * Model Leave_policy
 * 
 */
export type Leave_policy = $Result.DefaultSelection<Prisma.$Leave_policyPayload>
/**
 * Model SyncHistory
 * 
 */
export type SyncHistory = $Result.DefaultSelection<Prisma.$SyncHistoryPayload>
/**
 * Model Punch
 * 
 */
export type Punch = $Result.DefaultSelection<Prisma.$PunchPayload>
/**
 * Model AttendanceDay
 * 
 */
export type AttendanceDay = $Result.DefaultSelection<Prisma.$AttendanceDayPayload>
/**
 * Model DeviceConfig
 * 
 */
export type DeviceConfig = $Result.DefaultSelection<Prisma.$DeviceConfigPayload>
/**
 * Model AttendanceConfig
 * 
 */
export type AttendanceConfig = $Result.DefaultSelection<Prisma.$AttendanceConfigPayload>
/**
 * Model SalaryConfig
 * 
 */
export type SalaryConfig = $Result.DefaultSelection<Prisma.$SalaryConfigPayload>
/**
 * Model SalaryRecord
 * 
 */
export type SalaryRecord = $Result.DefaultSelection<Prisma.$SalaryRecordPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const LeaveType: {
  ANNUAL: 'ANNUAL',
  CASUAL: 'CASUAL'
};

export type LeaveType = (typeof LeaveType)[keyof typeof LeaveType]


export const LeaveStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  CANCELLED: 'CANCELLED'
};

export type LeaveStatus = (typeof LeaveStatus)[keyof typeof LeaveStatus]


export const HalfdayType: {
  MORNING: 'MORNING',
  AFTERNOON: 'AFTERNOON'
};

export type HalfdayType = (typeof HalfdayType)[keyof typeof HalfdayType]


export const Direction: {
  IN: 'IN',
  OUT: 'OUT'
};

export type Direction = (typeof Direction)[keyof typeof Direction]


export const Source: {
  device: 'device',
  manual: 'manual'
};

export type Source = (typeof Source)[keyof typeof Source]


export const AttendanceStatus: {
  OK: 'OK',
  ABSENT: 'ABSENT',
  PARTIAL: 'PARTIAL',
  MANUAL: 'MANUAL'
};

export type AttendanceStatus = (typeof AttendanceStatus)[keyof typeof AttendanceStatus]

}

export type LeaveType = $Enums.LeaveType

export const LeaveType: typeof $Enums.LeaveType

export type LeaveStatus = $Enums.LeaveStatus

export const LeaveStatus: typeof $Enums.LeaveStatus

export type HalfdayType = $Enums.HalfdayType

export const HalfdayType: typeof $Enums.HalfdayType

export type Direction = $Enums.Direction

export const Direction: typeof $Enums.Direction

export type Source = $Enums.Source

export const Source: typeof $Enums.Source

export type AttendanceStatus = $Enums.AttendanceStatus

export const AttendanceStatus: typeof $Enums.AttendanceStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leave_request`: Exposes CRUD operations for the **Leave_request** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leave_requests
    * const leave_requests = await prisma.leave_request.findMany()
    * ```
    */
  get leave_request(): Prisma.Leave_requestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leave_request_date`: Exposes CRUD operations for the **Leave_request_date** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leave_request_dates
    * const leave_request_dates = await prisma.leave_request_date.findMany()
    * ```
    */
  get leave_request_date(): Prisma.Leave_request_dateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leave_balance`: Exposes CRUD operations for the **Leave_balance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leave_balances
    * const leave_balances = await prisma.leave_balance.findMany()
    * ```
    */
  get leave_balance(): Prisma.Leave_balanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leave_policy`: Exposes CRUD operations for the **Leave_policy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leave_policies
    * const leave_policies = await prisma.leave_policy.findMany()
    * ```
    */
  get leave_policy(): Prisma.Leave_policyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.syncHistory`: Exposes CRUD operations for the **SyncHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SyncHistories
    * const syncHistories = await prisma.syncHistory.findMany()
    * ```
    */
  get syncHistory(): Prisma.SyncHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.punch`: Exposes CRUD operations for the **Punch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Punches
    * const punches = await prisma.punch.findMany()
    * ```
    */
  get punch(): Prisma.PunchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendanceDay`: Exposes CRUD operations for the **AttendanceDay** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendanceDays
    * const attendanceDays = await prisma.attendanceDay.findMany()
    * ```
    */
  get attendanceDay(): Prisma.AttendanceDayDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceConfig`: Exposes CRUD operations for the **DeviceConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceConfigs
    * const deviceConfigs = await prisma.deviceConfig.findMany()
    * ```
    */
  get deviceConfig(): Prisma.DeviceConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendanceConfig`: Exposes CRUD operations for the **AttendanceConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendanceConfigs
    * const attendanceConfigs = await prisma.attendanceConfig.findMany()
    * ```
    */
  get attendanceConfig(): Prisma.AttendanceConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salaryConfig`: Exposes CRUD operations for the **SalaryConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalaryConfigs
    * const salaryConfigs = await prisma.salaryConfig.findMany()
    * ```
    */
  get salaryConfig(): Prisma.SalaryConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salaryRecord`: Exposes CRUD operations for the **SalaryRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalaryRecords
    * const salaryRecords = await prisma.salaryRecord.findMany()
    * ```
    */
  get salaryRecord(): Prisma.SalaryRecordDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.1
   * Query Engine version: 272a37d34178c2894197e17273bf937f25acdeac
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Leave_request: 'Leave_request',
    Leave_request_date: 'Leave_request_date',
    Leave_balance: 'Leave_balance',
    Leave_policy: 'Leave_policy',
    SyncHistory: 'SyncHistory',
    Punch: 'Punch',
    AttendanceDay: 'AttendanceDay',
    DeviceConfig: 'DeviceConfig',
    AttendanceConfig: 'AttendanceConfig',
    SalaryConfig: 'SalaryConfig',
    SalaryRecord: 'SalaryRecord'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "leave_request" | "leave_request_date" | "leave_balance" | "leave_policy" | "syncHistory" | "punch" | "attendanceDay" | "deviceConfig" | "attendanceConfig" | "salaryConfig" | "salaryRecord"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Leave_request: {
        payload: Prisma.$Leave_requestPayload<ExtArgs>
        fields: Prisma.Leave_requestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Leave_requestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_requestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Leave_requestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_requestPayload>
          }
          findFirst: {
            args: Prisma.Leave_requestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_requestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Leave_requestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_requestPayload>
          }
          findMany: {
            args: Prisma.Leave_requestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_requestPayload>[]
          }
          create: {
            args: Prisma.Leave_requestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_requestPayload>
          }
          createMany: {
            args: Prisma.Leave_requestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Leave_requestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_requestPayload>[]
          }
          delete: {
            args: Prisma.Leave_requestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_requestPayload>
          }
          update: {
            args: Prisma.Leave_requestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_requestPayload>
          }
          deleteMany: {
            args: Prisma.Leave_requestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Leave_requestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Leave_requestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_requestPayload>[]
          }
          upsert: {
            args: Prisma.Leave_requestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_requestPayload>
          }
          aggregate: {
            args: Prisma.Leave_requestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeave_request>
          }
          groupBy: {
            args: Prisma.Leave_requestGroupByArgs<ExtArgs>
            result: $Utils.Optional<Leave_requestGroupByOutputType>[]
          }
          count: {
            args: Prisma.Leave_requestCountArgs<ExtArgs>
            result: $Utils.Optional<Leave_requestCountAggregateOutputType> | number
          }
        }
      }
      Leave_request_date: {
        payload: Prisma.$Leave_request_datePayload<ExtArgs>
        fields: Prisma.Leave_request_dateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Leave_request_dateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_request_datePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Leave_request_dateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_request_datePayload>
          }
          findFirst: {
            args: Prisma.Leave_request_dateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_request_datePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Leave_request_dateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_request_datePayload>
          }
          findMany: {
            args: Prisma.Leave_request_dateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_request_datePayload>[]
          }
          create: {
            args: Prisma.Leave_request_dateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_request_datePayload>
          }
          createMany: {
            args: Prisma.Leave_request_dateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Leave_request_dateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_request_datePayload>[]
          }
          delete: {
            args: Prisma.Leave_request_dateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_request_datePayload>
          }
          update: {
            args: Prisma.Leave_request_dateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_request_datePayload>
          }
          deleteMany: {
            args: Prisma.Leave_request_dateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Leave_request_dateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Leave_request_dateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_request_datePayload>[]
          }
          upsert: {
            args: Prisma.Leave_request_dateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_request_datePayload>
          }
          aggregate: {
            args: Prisma.Leave_request_dateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeave_request_date>
          }
          groupBy: {
            args: Prisma.Leave_request_dateGroupByArgs<ExtArgs>
            result: $Utils.Optional<Leave_request_dateGroupByOutputType>[]
          }
          count: {
            args: Prisma.Leave_request_dateCountArgs<ExtArgs>
            result: $Utils.Optional<Leave_request_dateCountAggregateOutputType> | number
          }
        }
      }
      Leave_balance: {
        payload: Prisma.$Leave_balancePayload<ExtArgs>
        fields: Prisma.Leave_balanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Leave_balanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_balancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Leave_balanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_balancePayload>
          }
          findFirst: {
            args: Prisma.Leave_balanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_balancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Leave_balanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_balancePayload>
          }
          findMany: {
            args: Prisma.Leave_balanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_balancePayload>[]
          }
          create: {
            args: Prisma.Leave_balanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_balancePayload>
          }
          createMany: {
            args: Prisma.Leave_balanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Leave_balanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_balancePayload>[]
          }
          delete: {
            args: Prisma.Leave_balanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_balancePayload>
          }
          update: {
            args: Prisma.Leave_balanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_balancePayload>
          }
          deleteMany: {
            args: Prisma.Leave_balanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Leave_balanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Leave_balanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_balancePayload>[]
          }
          upsert: {
            args: Prisma.Leave_balanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_balancePayload>
          }
          aggregate: {
            args: Prisma.Leave_balanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeave_balance>
          }
          groupBy: {
            args: Prisma.Leave_balanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<Leave_balanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.Leave_balanceCountArgs<ExtArgs>
            result: $Utils.Optional<Leave_balanceCountAggregateOutputType> | number
          }
        }
      }
      Leave_policy: {
        payload: Prisma.$Leave_policyPayload<ExtArgs>
        fields: Prisma.Leave_policyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Leave_policyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_policyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Leave_policyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_policyPayload>
          }
          findFirst: {
            args: Prisma.Leave_policyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_policyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Leave_policyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_policyPayload>
          }
          findMany: {
            args: Prisma.Leave_policyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_policyPayload>[]
          }
          create: {
            args: Prisma.Leave_policyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_policyPayload>
          }
          createMany: {
            args: Prisma.Leave_policyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Leave_policyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_policyPayload>[]
          }
          delete: {
            args: Prisma.Leave_policyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_policyPayload>
          }
          update: {
            args: Prisma.Leave_policyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_policyPayload>
          }
          deleteMany: {
            args: Prisma.Leave_policyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Leave_policyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Leave_policyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_policyPayload>[]
          }
          upsert: {
            args: Prisma.Leave_policyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Leave_policyPayload>
          }
          aggregate: {
            args: Prisma.Leave_policyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeave_policy>
          }
          groupBy: {
            args: Prisma.Leave_policyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Leave_policyGroupByOutputType>[]
          }
          count: {
            args: Prisma.Leave_policyCountArgs<ExtArgs>
            result: $Utils.Optional<Leave_policyCountAggregateOutputType> | number
          }
        }
      }
      SyncHistory: {
        payload: Prisma.$SyncHistoryPayload<ExtArgs>
        fields: Prisma.SyncHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyncHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyncHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload>
          }
          findFirst: {
            args: Prisma.SyncHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyncHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload>
          }
          findMany: {
            args: Prisma.SyncHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload>[]
          }
          create: {
            args: Prisma.SyncHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload>
          }
          createMany: {
            args: Prisma.SyncHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SyncHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload>[]
          }
          delete: {
            args: Prisma.SyncHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload>
          }
          update: {
            args: Prisma.SyncHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload>
          }
          deleteMany: {
            args: Prisma.SyncHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SyncHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SyncHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload>[]
          }
          upsert: {
            args: Prisma.SyncHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload>
          }
          aggregate: {
            args: Prisma.SyncHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSyncHistory>
          }
          groupBy: {
            args: Prisma.SyncHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SyncHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SyncHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<SyncHistoryCountAggregateOutputType> | number
          }
        }
      }
      Punch: {
        payload: Prisma.$PunchPayload<ExtArgs>
        fields: Prisma.PunchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PunchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PunchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PunchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PunchPayload>
          }
          findFirst: {
            args: Prisma.PunchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PunchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PunchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PunchPayload>
          }
          findMany: {
            args: Prisma.PunchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PunchPayload>[]
          }
          create: {
            args: Prisma.PunchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PunchPayload>
          }
          createMany: {
            args: Prisma.PunchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PunchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PunchPayload>[]
          }
          delete: {
            args: Prisma.PunchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PunchPayload>
          }
          update: {
            args: Prisma.PunchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PunchPayload>
          }
          deleteMany: {
            args: Prisma.PunchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PunchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PunchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PunchPayload>[]
          }
          upsert: {
            args: Prisma.PunchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PunchPayload>
          }
          aggregate: {
            args: Prisma.PunchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePunch>
          }
          groupBy: {
            args: Prisma.PunchGroupByArgs<ExtArgs>
            result: $Utils.Optional<PunchGroupByOutputType>[]
          }
          count: {
            args: Prisma.PunchCountArgs<ExtArgs>
            result: $Utils.Optional<PunchCountAggregateOutputType> | number
          }
        }
      }
      AttendanceDay: {
        payload: Prisma.$AttendanceDayPayload<ExtArgs>
        fields: Prisma.AttendanceDayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceDayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceDayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDayPayload>
          }
          findFirst: {
            args: Prisma.AttendanceDayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceDayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDayPayload>
          }
          findMany: {
            args: Prisma.AttendanceDayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDayPayload>[]
          }
          create: {
            args: Prisma.AttendanceDayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDayPayload>
          }
          createMany: {
            args: Prisma.AttendanceDayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceDayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDayPayload>[]
          }
          delete: {
            args: Prisma.AttendanceDayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDayPayload>
          }
          update: {
            args: Prisma.AttendanceDayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDayPayload>
          }
          deleteMany: {
            args: Prisma.AttendanceDayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceDayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceDayUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDayPayload>[]
          }
          upsert: {
            args: Prisma.AttendanceDayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDayPayload>
          }
          aggregate: {
            args: Prisma.AttendanceDayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendanceDay>
          }
          groupBy: {
            args: Prisma.AttendanceDayGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceDayGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceDayCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceDayCountAggregateOutputType> | number
          }
        }
      }
      DeviceConfig: {
        payload: Prisma.$DeviceConfigPayload<ExtArgs>
        fields: Prisma.DeviceConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConfigPayload>
          }
          findFirst: {
            args: Prisma.DeviceConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConfigPayload>
          }
          findMany: {
            args: Prisma.DeviceConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConfigPayload>[]
          }
          create: {
            args: Prisma.DeviceConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConfigPayload>
          }
          createMany: {
            args: Prisma.DeviceConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConfigPayload>[]
          }
          delete: {
            args: Prisma.DeviceConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConfigPayload>
          }
          update: {
            args: Prisma.DeviceConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConfigPayload>
          }
          deleteMany: {
            args: Prisma.DeviceConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConfigPayload>[]
          }
          upsert: {
            args: Prisma.DeviceConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConfigPayload>
          }
          aggregate: {
            args: Prisma.DeviceConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceConfig>
          }
          groupBy: {
            args: Prisma.DeviceConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceConfigCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceConfigCountAggregateOutputType> | number
          }
        }
      }
      AttendanceConfig: {
        payload: Prisma.$AttendanceConfigPayload<ExtArgs>
        fields: Prisma.AttendanceConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceConfigPayload>
          }
          findFirst: {
            args: Prisma.AttendanceConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceConfigPayload>
          }
          findMany: {
            args: Prisma.AttendanceConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceConfigPayload>[]
          }
          create: {
            args: Prisma.AttendanceConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceConfigPayload>
          }
          createMany: {
            args: Prisma.AttendanceConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceConfigPayload>[]
          }
          delete: {
            args: Prisma.AttendanceConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceConfigPayload>
          }
          update: {
            args: Prisma.AttendanceConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceConfigPayload>
          }
          deleteMany: {
            args: Prisma.AttendanceConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceConfigPayload>[]
          }
          upsert: {
            args: Prisma.AttendanceConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceConfigPayload>
          }
          aggregate: {
            args: Prisma.AttendanceConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendanceConfig>
          }
          groupBy: {
            args: Prisma.AttendanceConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceConfigCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceConfigCountAggregateOutputType> | number
          }
        }
      }
      SalaryConfig: {
        payload: Prisma.$SalaryConfigPayload<ExtArgs>
        fields: Prisma.SalaryConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalaryConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalaryConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryConfigPayload>
          }
          findFirst: {
            args: Prisma.SalaryConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalaryConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryConfigPayload>
          }
          findMany: {
            args: Prisma.SalaryConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryConfigPayload>[]
          }
          create: {
            args: Prisma.SalaryConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryConfigPayload>
          }
          createMany: {
            args: Prisma.SalaryConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalaryConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryConfigPayload>[]
          }
          delete: {
            args: Prisma.SalaryConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryConfigPayload>
          }
          update: {
            args: Prisma.SalaryConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryConfigPayload>
          }
          deleteMany: {
            args: Prisma.SalaryConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalaryConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalaryConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryConfigPayload>[]
          }
          upsert: {
            args: Prisma.SalaryConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryConfigPayload>
          }
          aggregate: {
            args: Prisma.SalaryConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalaryConfig>
          }
          groupBy: {
            args: Prisma.SalaryConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalaryConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalaryConfigCountArgs<ExtArgs>
            result: $Utils.Optional<SalaryConfigCountAggregateOutputType> | number
          }
        }
      }
      SalaryRecord: {
        payload: Prisma.$SalaryRecordPayload<ExtArgs>
        fields: Prisma.SalaryRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalaryRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalaryRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryRecordPayload>
          }
          findFirst: {
            args: Prisma.SalaryRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalaryRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryRecordPayload>
          }
          findMany: {
            args: Prisma.SalaryRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryRecordPayload>[]
          }
          create: {
            args: Prisma.SalaryRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryRecordPayload>
          }
          createMany: {
            args: Prisma.SalaryRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalaryRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryRecordPayload>[]
          }
          delete: {
            args: Prisma.SalaryRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryRecordPayload>
          }
          update: {
            args: Prisma.SalaryRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryRecordPayload>
          }
          deleteMany: {
            args: Prisma.SalaryRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalaryRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalaryRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryRecordPayload>[]
          }
          upsert: {
            args: Prisma.SalaryRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryRecordPayload>
          }
          aggregate: {
            args: Prisma.SalaryRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalaryRecord>
          }
          groupBy: {
            args: Prisma.SalaryRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalaryRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalaryRecordCountArgs<ExtArgs>
            result: $Utils.Optional<SalaryRecordCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    leave_request?: Leave_requestOmit
    leave_request_date?: Leave_request_dateOmit
    leave_balance?: Leave_balanceOmit
    leave_policy?: Leave_policyOmit
    syncHistory?: SyncHistoryOmit
    punch?: PunchOmit
    attendanceDay?: AttendanceDayOmit
    deviceConfig?: DeviceConfigOmit
    attendanceConfig?: AttendanceConfigOmit
    salaryConfig?: SalaryConfigOmit
    salaryRecord?: SalaryRecordOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    leaveRequests: number
    approvedRequests: number
    leaveBalances: number
    punches: number
    attendanceDays: number
    salaryConfigs: number
    salaryRecords: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leaveRequests?: boolean | UserCountOutputTypeCountLeaveRequestsArgs
    approvedRequests?: boolean | UserCountOutputTypeCountApprovedRequestsArgs
    leaveBalances?: boolean | UserCountOutputTypeCountLeaveBalancesArgs
    punches?: boolean | UserCountOutputTypeCountPunchesArgs
    attendanceDays?: boolean | UserCountOutputTypeCountAttendanceDaysArgs
    salaryConfigs?: boolean | UserCountOutputTypeCountSalaryConfigsArgs
    salaryRecords?: boolean | UserCountOutputTypeCountSalaryRecordsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeaveRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Leave_requestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Leave_requestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeaveBalancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Leave_balanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPunchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PunchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttendanceDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceDayWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSalaryConfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryConfigWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSalaryRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryRecordWhereInput
  }


  /**
   * Count Type Leave_requestCountOutputType
   */

  export type Leave_requestCountOutputType = {
    dates: number
  }

  export type Leave_requestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dates?: boolean | Leave_requestCountOutputTypeCountDatesArgs
  }

  // Custom InputTypes
  /**
   * Leave_requestCountOutputType without action
   */
  export type Leave_requestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_requestCountOutputType
     */
    select?: Leave_requestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Leave_requestCountOutputType without action
   */
  export type Leave_requestCountOutputTypeCountDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Leave_request_dateWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    isAdmin: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    refreshToken: string | null
    employeeId: string | null
    cardNumber: string | null
    validFrom: Date | null
    validTo: Date | null
    epfNo: string | null
    nic: string | null
    jobPosition: string | null
    imagePath: string | null
    active: boolean | null
    joinDate: Date | null
    address: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    isAdmin: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    refreshToken: string | null
    employeeId: string | null
    cardNumber: string | null
    validFrom: Date | null
    validTo: Date | null
    epfNo: string | null
    nic: string | null
    jobPosition: string | null
    imagePath: string | null
    active: boolean | null
    joinDate: Date | null
    address: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    isAdmin: number
    createdAt: number
    updatedAt: number
    refreshToken: number
    employeeId: number
    cardNumber: number
    validFrom: number
    validTo: number
    epfNo: number
    nic: number
    jobPosition: number
    imagePath: number
    active: number
    joinDate: number
    address: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    isAdmin?: true
    createdAt?: true
    updatedAt?: true
    refreshToken?: true
    employeeId?: true
    cardNumber?: true
    validFrom?: true
    validTo?: true
    epfNo?: true
    nic?: true
    jobPosition?: true
    imagePath?: true
    active?: true
    joinDate?: true
    address?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    isAdmin?: true
    createdAt?: true
    updatedAt?: true
    refreshToken?: true
    employeeId?: true
    cardNumber?: true
    validFrom?: true
    validTo?: true
    epfNo?: true
    nic?: true
    jobPosition?: true
    imagePath?: true
    active?: true
    joinDate?: true
    address?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    isAdmin?: true
    createdAt?: true
    updatedAt?: true
    refreshToken?: true
    employeeId?: true
    cardNumber?: true
    validFrom?: true
    validTo?: true
    epfNo?: true
    nic?: true
    jobPosition?: true
    imagePath?: true
    active?: true
    joinDate?: true
    address?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    name: string
    isAdmin: boolean
    createdAt: Date
    updatedAt: Date
    refreshToken: string | null
    employeeId: string | null
    cardNumber: string | null
    validFrom: Date | null
    validTo: Date | null
    epfNo: string | null
    nic: string | null
    jobPosition: string | null
    imagePath: string | null
    active: boolean
    joinDate: Date | null
    address: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    isAdmin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    refreshToken?: boolean
    employeeId?: boolean
    cardNumber?: boolean
    validFrom?: boolean
    validTo?: boolean
    epfNo?: boolean
    nic?: boolean
    jobPosition?: boolean
    imagePath?: boolean
    active?: boolean
    joinDate?: boolean
    address?: boolean
    leaveRequests?: boolean | User$leaveRequestsArgs<ExtArgs>
    approvedRequests?: boolean | User$approvedRequestsArgs<ExtArgs>
    leaveBalances?: boolean | User$leaveBalancesArgs<ExtArgs>
    punches?: boolean | User$punchesArgs<ExtArgs>
    attendanceDays?: boolean | User$attendanceDaysArgs<ExtArgs>
    salaryConfigs?: boolean | User$salaryConfigsArgs<ExtArgs>
    salaryRecords?: boolean | User$salaryRecordsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    isAdmin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    refreshToken?: boolean
    employeeId?: boolean
    cardNumber?: boolean
    validFrom?: boolean
    validTo?: boolean
    epfNo?: boolean
    nic?: boolean
    jobPosition?: boolean
    imagePath?: boolean
    active?: boolean
    joinDate?: boolean
    address?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    isAdmin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    refreshToken?: boolean
    employeeId?: boolean
    cardNumber?: boolean
    validFrom?: boolean
    validTo?: boolean
    epfNo?: boolean
    nic?: boolean
    jobPosition?: boolean
    imagePath?: boolean
    active?: boolean
    joinDate?: boolean
    address?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    isAdmin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    refreshToken?: boolean
    employeeId?: boolean
    cardNumber?: boolean
    validFrom?: boolean
    validTo?: boolean
    epfNo?: boolean
    nic?: boolean
    jobPosition?: boolean
    imagePath?: boolean
    active?: boolean
    joinDate?: boolean
    address?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "name" | "isAdmin" | "createdAt" | "updatedAt" | "refreshToken" | "employeeId" | "cardNumber" | "validFrom" | "validTo" | "epfNo" | "nic" | "jobPosition" | "imagePath" | "active" | "joinDate" | "address", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leaveRequests?: boolean | User$leaveRequestsArgs<ExtArgs>
    approvedRequests?: boolean | User$approvedRequestsArgs<ExtArgs>
    leaveBalances?: boolean | User$leaveBalancesArgs<ExtArgs>
    punches?: boolean | User$punchesArgs<ExtArgs>
    attendanceDays?: boolean | User$attendanceDaysArgs<ExtArgs>
    salaryConfigs?: boolean | User$salaryConfigsArgs<ExtArgs>
    salaryRecords?: boolean | User$salaryRecordsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      leaveRequests: Prisma.$Leave_requestPayload<ExtArgs>[]
      approvedRequests: Prisma.$Leave_requestPayload<ExtArgs>[]
      leaveBalances: Prisma.$Leave_balancePayload<ExtArgs>[]
      punches: Prisma.$PunchPayload<ExtArgs>[]
      attendanceDays: Prisma.$AttendanceDayPayload<ExtArgs>[]
      salaryConfigs: Prisma.$SalaryConfigPayload<ExtArgs>[]
      salaryRecords: Prisma.$SalaryRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      name: string
      isAdmin: boolean
      createdAt: Date
      updatedAt: Date
      refreshToken: string | null
      employeeId: string | null
      cardNumber: string | null
      validFrom: Date | null
      validTo: Date | null
      epfNo: string | null
      nic: string | null
      jobPosition: string | null
      imagePath: string | null
      active: boolean
      joinDate: Date | null
      address: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    leaveRequests<T extends User$leaveRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$leaveRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Leave_requestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvedRequests<T extends User$approvedRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Leave_requestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaveBalances<T extends User$leaveBalancesArgs<ExtArgs> = {}>(args?: Subset<T, User$leaveBalancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Leave_balancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    punches<T extends User$punchesArgs<ExtArgs> = {}>(args?: Subset<T, User$punchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PunchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendanceDays<T extends User$attendanceDaysArgs<ExtArgs> = {}>(args?: Subset<T, User$attendanceDaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceDayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    salaryConfigs<T extends User$salaryConfigsArgs<ExtArgs> = {}>(args?: Subset<T, User$salaryConfigsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    salaryRecords<T extends User$salaryRecordsArgs<ExtArgs> = {}>(args?: Subset<T, User$salaryRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly isAdmin: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly refreshToken: FieldRef<"User", 'String'>
    readonly employeeId: FieldRef<"User", 'String'>
    readonly cardNumber: FieldRef<"User", 'String'>
    readonly validFrom: FieldRef<"User", 'DateTime'>
    readonly validTo: FieldRef<"User", 'DateTime'>
    readonly epfNo: FieldRef<"User", 'String'>
    readonly nic: FieldRef<"User", 'String'>
    readonly jobPosition: FieldRef<"User", 'String'>
    readonly imagePath: FieldRef<"User", 'String'>
    readonly active: FieldRef<"User", 'Boolean'>
    readonly joinDate: FieldRef<"User", 'DateTime'>
    readonly address: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.leaveRequests
   */
  export type User$leaveRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_request
     */
    select?: Leave_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_request
     */
    omit?: Leave_requestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_requestInclude<ExtArgs> | null
    where?: Leave_requestWhereInput
    orderBy?: Leave_requestOrderByWithRelationInput | Leave_requestOrderByWithRelationInput[]
    cursor?: Leave_requestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Leave_requestScalarFieldEnum | Leave_requestScalarFieldEnum[]
  }

  /**
   * User.approvedRequests
   */
  export type User$approvedRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_request
     */
    select?: Leave_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_request
     */
    omit?: Leave_requestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_requestInclude<ExtArgs> | null
    where?: Leave_requestWhereInput
    orderBy?: Leave_requestOrderByWithRelationInput | Leave_requestOrderByWithRelationInput[]
    cursor?: Leave_requestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Leave_requestScalarFieldEnum | Leave_requestScalarFieldEnum[]
  }

  /**
   * User.leaveBalances
   */
  export type User$leaveBalancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_balance
     */
    select?: Leave_balanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_balance
     */
    omit?: Leave_balanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_balanceInclude<ExtArgs> | null
    where?: Leave_balanceWhereInput
    orderBy?: Leave_balanceOrderByWithRelationInput | Leave_balanceOrderByWithRelationInput[]
    cursor?: Leave_balanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Leave_balanceScalarFieldEnum | Leave_balanceScalarFieldEnum[]
  }

  /**
   * User.punches
   */
  export type User$punchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Punch
     */
    select?: PunchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Punch
     */
    omit?: PunchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PunchInclude<ExtArgs> | null
    where?: PunchWhereInput
    orderBy?: PunchOrderByWithRelationInput | PunchOrderByWithRelationInput[]
    cursor?: PunchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PunchScalarFieldEnum | PunchScalarFieldEnum[]
  }

  /**
   * User.attendanceDays
   */
  export type User$attendanceDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDay
     */
    select?: AttendanceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDay
     */
    omit?: AttendanceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDayInclude<ExtArgs> | null
    where?: AttendanceDayWhereInput
    orderBy?: AttendanceDayOrderByWithRelationInput | AttendanceDayOrderByWithRelationInput[]
    cursor?: AttendanceDayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceDayScalarFieldEnum | AttendanceDayScalarFieldEnum[]
  }

  /**
   * User.salaryConfigs
   */
  export type User$salaryConfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryConfig
     */
    select?: SalaryConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryConfig
     */
    omit?: SalaryConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryConfigInclude<ExtArgs> | null
    where?: SalaryConfigWhereInput
    orderBy?: SalaryConfigOrderByWithRelationInput | SalaryConfigOrderByWithRelationInput[]
    cursor?: SalaryConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalaryConfigScalarFieldEnum | SalaryConfigScalarFieldEnum[]
  }

  /**
   * User.salaryRecords
   */
  export type User$salaryRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRecord
     */
    select?: SalaryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryRecord
     */
    omit?: SalaryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRecordInclude<ExtArgs> | null
    where?: SalaryRecordWhereInput
    orderBy?: SalaryRecordOrderByWithRelationInput | SalaryRecordOrderByWithRelationInput[]
    cursor?: SalaryRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalaryRecordScalarFieldEnum | SalaryRecordScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Leave_request
   */

  export type AggregateLeave_request = {
    _count: Leave_requestCountAggregateOutputType | null
    _avg: Leave_requestAvgAggregateOutputType | null
    _sum: Leave_requestSumAggregateOutputType | null
    _min: Leave_requestMinAggregateOutputType | null
    _max: Leave_requestMaxAggregateOutputType | null
  }

  export type Leave_requestAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    approvedBy: number | null
  }

  export type Leave_requestSumAggregateOutputType = {
    id: number | null
    userId: number | null
    approvedBy: number | null
  }

  export type Leave_requestMinAggregateOutputType = {
    id: number | null
    userId: number | null
    approvedBy: number | null
    leaveType: $Enums.LeaveType | null
    status: $Enums.LeaveStatus | null
    reason: string | null
    requestedAt: Date | null
    approvedAt: Date | null
    rejectedAt: Date | null
  }

  export type Leave_requestMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    approvedBy: number | null
    leaveType: $Enums.LeaveType | null
    status: $Enums.LeaveStatus | null
    reason: string | null
    requestedAt: Date | null
    approvedAt: Date | null
    rejectedAt: Date | null
  }

  export type Leave_requestCountAggregateOutputType = {
    id: number
    userId: number
    approvedBy: number
    leaveType: number
    status: number
    reason: number
    requestedAt: number
    approvedAt: number
    rejectedAt: number
    _all: number
  }


  export type Leave_requestAvgAggregateInputType = {
    id?: true
    userId?: true
    approvedBy?: true
  }

  export type Leave_requestSumAggregateInputType = {
    id?: true
    userId?: true
    approvedBy?: true
  }

  export type Leave_requestMinAggregateInputType = {
    id?: true
    userId?: true
    approvedBy?: true
    leaveType?: true
    status?: true
    reason?: true
    requestedAt?: true
    approvedAt?: true
    rejectedAt?: true
  }

  export type Leave_requestMaxAggregateInputType = {
    id?: true
    userId?: true
    approvedBy?: true
    leaveType?: true
    status?: true
    reason?: true
    requestedAt?: true
    approvedAt?: true
    rejectedAt?: true
  }

  export type Leave_requestCountAggregateInputType = {
    id?: true
    userId?: true
    approvedBy?: true
    leaveType?: true
    status?: true
    reason?: true
    requestedAt?: true
    approvedAt?: true
    rejectedAt?: true
    _all?: true
  }

  export type Leave_requestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leave_request to aggregate.
     */
    where?: Leave_requestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leave_requests to fetch.
     */
    orderBy?: Leave_requestOrderByWithRelationInput | Leave_requestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Leave_requestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leave_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leave_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leave_requests
    **/
    _count?: true | Leave_requestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Leave_requestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Leave_requestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Leave_requestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Leave_requestMaxAggregateInputType
  }

  export type GetLeave_requestAggregateType<T extends Leave_requestAggregateArgs> = {
        [P in keyof T & keyof AggregateLeave_request]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeave_request[P]>
      : GetScalarType<T[P], AggregateLeave_request[P]>
  }




  export type Leave_requestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Leave_requestWhereInput
    orderBy?: Leave_requestOrderByWithAggregationInput | Leave_requestOrderByWithAggregationInput[]
    by: Leave_requestScalarFieldEnum[] | Leave_requestScalarFieldEnum
    having?: Leave_requestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Leave_requestCountAggregateInputType | true
    _avg?: Leave_requestAvgAggregateInputType
    _sum?: Leave_requestSumAggregateInputType
    _min?: Leave_requestMinAggregateInputType
    _max?: Leave_requestMaxAggregateInputType
  }

  export type Leave_requestGroupByOutputType = {
    id: number
    userId: number
    approvedBy: number | null
    leaveType: $Enums.LeaveType
    status: $Enums.LeaveStatus | null
    reason: string | null
    requestedAt: Date
    approvedAt: Date | null
    rejectedAt: Date | null
    _count: Leave_requestCountAggregateOutputType | null
    _avg: Leave_requestAvgAggregateOutputType | null
    _sum: Leave_requestSumAggregateOutputType | null
    _min: Leave_requestMinAggregateOutputType | null
    _max: Leave_requestMaxAggregateOutputType | null
  }

  type GetLeave_requestGroupByPayload<T extends Leave_requestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Leave_requestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Leave_requestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Leave_requestGroupByOutputType[P]>
            : GetScalarType<T[P], Leave_requestGroupByOutputType[P]>
        }
      >
    >


  export type Leave_requestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    approvedBy?: boolean
    leaveType?: boolean
    status?: boolean
    reason?: boolean
    requestedAt?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    dates?: boolean | Leave_request$datesArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    approvedByUser?: boolean | Leave_request$approvedByUserArgs<ExtArgs>
    _count?: boolean | Leave_requestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leave_request"]>

  export type Leave_requestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    approvedBy?: boolean
    leaveType?: boolean
    status?: boolean
    reason?: boolean
    requestedAt?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    approvedByUser?: boolean | Leave_request$approvedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["leave_request"]>

  export type Leave_requestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    approvedBy?: boolean
    leaveType?: boolean
    status?: boolean
    reason?: boolean
    requestedAt?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    approvedByUser?: boolean | Leave_request$approvedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["leave_request"]>

  export type Leave_requestSelectScalar = {
    id?: boolean
    userId?: boolean
    approvedBy?: boolean
    leaveType?: boolean
    status?: boolean
    reason?: boolean
    requestedAt?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
  }

  export type Leave_requestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "approvedBy" | "leaveType" | "status" | "reason" | "requestedAt" | "approvedAt" | "rejectedAt", ExtArgs["result"]["leave_request"]>
  export type Leave_requestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dates?: boolean | Leave_request$datesArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    approvedByUser?: boolean | Leave_request$approvedByUserArgs<ExtArgs>
    _count?: boolean | Leave_requestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type Leave_requestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    approvedByUser?: boolean | Leave_request$approvedByUserArgs<ExtArgs>
  }
  export type Leave_requestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    approvedByUser?: boolean | Leave_request$approvedByUserArgs<ExtArgs>
  }

  export type $Leave_requestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Leave_request"
    objects: {
      dates: Prisma.$Leave_request_datePayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      approvedByUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      approvedBy: number | null
      leaveType: $Enums.LeaveType
      status: $Enums.LeaveStatus | null
      reason: string | null
      requestedAt: Date
      approvedAt: Date | null
      rejectedAt: Date | null
    }, ExtArgs["result"]["leave_request"]>
    composites: {}
  }

  type Leave_requestGetPayload<S extends boolean | null | undefined | Leave_requestDefaultArgs> = $Result.GetResult<Prisma.$Leave_requestPayload, S>

  type Leave_requestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Leave_requestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Leave_requestCountAggregateInputType | true
    }

  export interface Leave_requestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Leave_request'], meta: { name: 'Leave_request' } }
    /**
     * Find zero or one Leave_request that matches the filter.
     * @param {Leave_requestFindUniqueArgs} args - Arguments to find a Leave_request
     * @example
     * // Get one Leave_request
     * const leave_request = await prisma.leave_request.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Leave_requestFindUniqueArgs>(args: SelectSubset<T, Leave_requestFindUniqueArgs<ExtArgs>>): Prisma__Leave_requestClient<$Result.GetResult<Prisma.$Leave_requestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Leave_request that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Leave_requestFindUniqueOrThrowArgs} args - Arguments to find a Leave_request
     * @example
     * // Get one Leave_request
     * const leave_request = await prisma.leave_request.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Leave_requestFindUniqueOrThrowArgs>(args: SelectSubset<T, Leave_requestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Leave_requestClient<$Result.GetResult<Prisma.$Leave_requestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leave_request that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Leave_requestFindFirstArgs} args - Arguments to find a Leave_request
     * @example
     * // Get one Leave_request
     * const leave_request = await prisma.leave_request.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Leave_requestFindFirstArgs>(args?: SelectSubset<T, Leave_requestFindFirstArgs<ExtArgs>>): Prisma__Leave_requestClient<$Result.GetResult<Prisma.$Leave_requestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leave_request that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Leave_requestFindFirstOrThrowArgs} args - Arguments to find a Leave_request
     * @example
     * // Get one Leave_request
     * const leave_request = await prisma.leave_request.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Leave_requestFindFirstOrThrowArgs>(args?: SelectSubset<T, Leave_requestFindFirstOrThrowArgs<ExtArgs>>): Prisma__Leave_requestClient<$Result.GetResult<Prisma.$Leave_requestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leave_requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Leave_requestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leave_requests
     * const leave_requests = await prisma.leave_request.findMany()
     * 
     * // Get first 10 Leave_requests
     * const leave_requests = await prisma.leave_request.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leave_requestWithIdOnly = await prisma.leave_request.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Leave_requestFindManyArgs>(args?: SelectSubset<T, Leave_requestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Leave_requestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Leave_request.
     * @param {Leave_requestCreateArgs} args - Arguments to create a Leave_request.
     * @example
     * // Create one Leave_request
     * const Leave_request = await prisma.leave_request.create({
     *   data: {
     *     // ... data to create a Leave_request
     *   }
     * })
     * 
     */
    create<T extends Leave_requestCreateArgs>(args: SelectSubset<T, Leave_requestCreateArgs<ExtArgs>>): Prisma__Leave_requestClient<$Result.GetResult<Prisma.$Leave_requestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leave_requests.
     * @param {Leave_requestCreateManyArgs} args - Arguments to create many Leave_requests.
     * @example
     * // Create many Leave_requests
     * const leave_request = await prisma.leave_request.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Leave_requestCreateManyArgs>(args?: SelectSubset<T, Leave_requestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leave_requests and returns the data saved in the database.
     * @param {Leave_requestCreateManyAndReturnArgs} args - Arguments to create many Leave_requests.
     * @example
     * // Create many Leave_requests
     * const leave_request = await prisma.leave_request.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leave_requests and only return the `id`
     * const leave_requestWithIdOnly = await prisma.leave_request.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Leave_requestCreateManyAndReturnArgs>(args?: SelectSubset<T, Leave_requestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Leave_requestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Leave_request.
     * @param {Leave_requestDeleteArgs} args - Arguments to delete one Leave_request.
     * @example
     * // Delete one Leave_request
     * const Leave_request = await prisma.leave_request.delete({
     *   where: {
     *     // ... filter to delete one Leave_request
     *   }
     * })
     * 
     */
    delete<T extends Leave_requestDeleteArgs>(args: SelectSubset<T, Leave_requestDeleteArgs<ExtArgs>>): Prisma__Leave_requestClient<$Result.GetResult<Prisma.$Leave_requestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Leave_request.
     * @param {Leave_requestUpdateArgs} args - Arguments to update one Leave_request.
     * @example
     * // Update one Leave_request
     * const leave_request = await prisma.leave_request.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Leave_requestUpdateArgs>(args: SelectSubset<T, Leave_requestUpdateArgs<ExtArgs>>): Prisma__Leave_requestClient<$Result.GetResult<Prisma.$Leave_requestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leave_requests.
     * @param {Leave_requestDeleteManyArgs} args - Arguments to filter Leave_requests to delete.
     * @example
     * // Delete a few Leave_requests
     * const { count } = await prisma.leave_request.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Leave_requestDeleteManyArgs>(args?: SelectSubset<T, Leave_requestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leave_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Leave_requestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leave_requests
     * const leave_request = await prisma.leave_request.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Leave_requestUpdateManyArgs>(args: SelectSubset<T, Leave_requestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leave_requests and returns the data updated in the database.
     * @param {Leave_requestUpdateManyAndReturnArgs} args - Arguments to update many Leave_requests.
     * @example
     * // Update many Leave_requests
     * const leave_request = await prisma.leave_request.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Leave_requests and only return the `id`
     * const leave_requestWithIdOnly = await prisma.leave_request.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Leave_requestUpdateManyAndReturnArgs>(args: SelectSubset<T, Leave_requestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Leave_requestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Leave_request.
     * @param {Leave_requestUpsertArgs} args - Arguments to update or create a Leave_request.
     * @example
     * // Update or create a Leave_request
     * const leave_request = await prisma.leave_request.upsert({
     *   create: {
     *     // ... data to create a Leave_request
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Leave_request we want to update
     *   }
     * })
     */
    upsert<T extends Leave_requestUpsertArgs>(args: SelectSubset<T, Leave_requestUpsertArgs<ExtArgs>>): Prisma__Leave_requestClient<$Result.GetResult<Prisma.$Leave_requestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leave_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Leave_requestCountArgs} args - Arguments to filter Leave_requests to count.
     * @example
     * // Count the number of Leave_requests
     * const count = await prisma.leave_request.count({
     *   where: {
     *     // ... the filter for the Leave_requests we want to count
     *   }
     * })
    **/
    count<T extends Leave_requestCountArgs>(
      args?: Subset<T, Leave_requestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Leave_requestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Leave_request.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Leave_requestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Leave_requestAggregateArgs>(args: Subset<T, Leave_requestAggregateArgs>): Prisma.PrismaPromise<GetLeave_requestAggregateType<T>>

    /**
     * Group by Leave_request.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Leave_requestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Leave_requestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Leave_requestGroupByArgs['orderBy'] }
        : { orderBy?: Leave_requestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Leave_requestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeave_requestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Leave_request model
   */
  readonly fields: Leave_requestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Leave_request.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Leave_requestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dates<T extends Leave_request$datesArgs<ExtArgs> = {}>(args?: Subset<T, Leave_request$datesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Leave_request_datePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approvedByUser<T extends Leave_request$approvedByUserArgs<ExtArgs> = {}>(args?: Subset<T, Leave_request$approvedByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Leave_request model
   */
  interface Leave_requestFieldRefs {
    readonly id: FieldRef<"Leave_request", 'Int'>
    readonly userId: FieldRef<"Leave_request", 'Int'>
    readonly approvedBy: FieldRef<"Leave_request", 'Int'>
    readonly leaveType: FieldRef<"Leave_request", 'LeaveType'>
    readonly status: FieldRef<"Leave_request", 'LeaveStatus'>
    readonly reason: FieldRef<"Leave_request", 'String'>
    readonly requestedAt: FieldRef<"Leave_request", 'DateTime'>
    readonly approvedAt: FieldRef<"Leave_request", 'DateTime'>
    readonly rejectedAt: FieldRef<"Leave_request", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Leave_request findUnique
   */
  export type Leave_requestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_request
     */
    select?: Leave_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_request
     */
    omit?: Leave_requestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_requestInclude<ExtArgs> | null
    /**
     * Filter, which Leave_request to fetch.
     */
    where: Leave_requestWhereUniqueInput
  }

  /**
   * Leave_request findUniqueOrThrow
   */
  export type Leave_requestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_request
     */
    select?: Leave_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_request
     */
    omit?: Leave_requestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_requestInclude<ExtArgs> | null
    /**
     * Filter, which Leave_request to fetch.
     */
    where: Leave_requestWhereUniqueInput
  }

  /**
   * Leave_request findFirst
   */
  export type Leave_requestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_request
     */
    select?: Leave_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_request
     */
    omit?: Leave_requestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_requestInclude<ExtArgs> | null
    /**
     * Filter, which Leave_request to fetch.
     */
    where?: Leave_requestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leave_requests to fetch.
     */
    orderBy?: Leave_requestOrderByWithRelationInput | Leave_requestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leave_requests.
     */
    cursor?: Leave_requestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leave_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leave_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leave_requests.
     */
    distinct?: Leave_requestScalarFieldEnum | Leave_requestScalarFieldEnum[]
  }

  /**
   * Leave_request findFirstOrThrow
   */
  export type Leave_requestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_request
     */
    select?: Leave_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_request
     */
    omit?: Leave_requestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_requestInclude<ExtArgs> | null
    /**
     * Filter, which Leave_request to fetch.
     */
    where?: Leave_requestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leave_requests to fetch.
     */
    orderBy?: Leave_requestOrderByWithRelationInput | Leave_requestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leave_requests.
     */
    cursor?: Leave_requestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leave_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leave_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leave_requests.
     */
    distinct?: Leave_requestScalarFieldEnum | Leave_requestScalarFieldEnum[]
  }

  /**
   * Leave_request findMany
   */
  export type Leave_requestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_request
     */
    select?: Leave_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_request
     */
    omit?: Leave_requestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_requestInclude<ExtArgs> | null
    /**
     * Filter, which Leave_requests to fetch.
     */
    where?: Leave_requestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leave_requests to fetch.
     */
    orderBy?: Leave_requestOrderByWithRelationInput | Leave_requestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leave_requests.
     */
    cursor?: Leave_requestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leave_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leave_requests.
     */
    skip?: number
    distinct?: Leave_requestScalarFieldEnum | Leave_requestScalarFieldEnum[]
  }

  /**
   * Leave_request create
   */
  export type Leave_requestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_request
     */
    select?: Leave_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_request
     */
    omit?: Leave_requestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_requestInclude<ExtArgs> | null
    /**
     * The data needed to create a Leave_request.
     */
    data: XOR<Leave_requestCreateInput, Leave_requestUncheckedCreateInput>
  }

  /**
   * Leave_request createMany
   */
  export type Leave_requestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leave_requests.
     */
    data: Leave_requestCreateManyInput | Leave_requestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Leave_request createManyAndReturn
   */
  export type Leave_requestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_request
     */
    select?: Leave_requestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_request
     */
    omit?: Leave_requestOmit<ExtArgs> | null
    /**
     * The data used to create many Leave_requests.
     */
    data: Leave_requestCreateManyInput | Leave_requestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_requestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Leave_request update
   */
  export type Leave_requestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_request
     */
    select?: Leave_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_request
     */
    omit?: Leave_requestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_requestInclude<ExtArgs> | null
    /**
     * The data needed to update a Leave_request.
     */
    data: XOR<Leave_requestUpdateInput, Leave_requestUncheckedUpdateInput>
    /**
     * Choose, which Leave_request to update.
     */
    where: Leave_requestWhereUniqueInput
  }

  /**
   * Leave_request updateMany
   */
  export type Leave_requestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leave_requests.
     */
    data: XOR<Leave_requestUpdateManyMutationInput, Leave_requestUncheckedUpdateManyInput>
    /**
     * Filter which Leave_requests to update
     */
    where?: Leave_requestWhereInput
    /**
     * Limit how many Leave_requests to update.
     */
    limit?: number
  }

  /**
   * Leave_request updateManyAndReturn
   */
  export type Leave_requestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_request
     */
    select?: Leave_requestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_request
     */
    omit?: Leave_requestOmit<ExtArgs> | null
    /**
     * The data used to update Leave_requests.
     */
    data: XOR<Leave_requestUpdateManyMutationInput, Leave_requestUncheckedUpdateManyInput>
    /**
     * Filter which Leave_requests to update
     */
    where?: Leave_requestWhereInput
    /**
     * Limit how many Leave_requests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_requestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Leave_request upsert
   */
  export type Leave_requestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_request
     */
    select?: Leave_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_request
     */
    omit?: Leave_requestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_requestInclude<ExtArgs> | null
    /**
     * The filter to search for the Leave_request to update in case it exists.
     */
    where: Leave_requestWhereUniqueInput
    /**
     * In case the Leave_request found by the `where` argument doesn't exist, create a new Leave_request with this data.
     */
    create: XOR<Leave_requestCreateInput, Leave_requestUncheckedCreateInput>
    /**
     * In case the Leave_request was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Leave_requestUpdateInput, Leave_requestUncheckedUpdateInput>
  }

  /**
   * Leave_request delete
   */
  export type Leave_requestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_request
     */
    select?: Leave_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_request
     */
    omit?: Leave_requestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_requestInclude<ExtArgs> | null
    /**
     * Filter which Leave_request to delete.
     */
    where: Leave_requestWhereUniqueInput
  }

  /**
   * Leave_request deleteMany
   */
  export type Leave_requestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leave_requests to delete
     */
    where?: Leave_requestWhereInput
    /**
     * Limit how many Leave_requests to delete.
     */
    limit?: number
  }

  /**
   * Leave_request.dates
   */
  export type Leave_request$datesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_request_date
     */
    select?: Leave_request_dateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_request_date
     */
    omit?: Leave_request_dateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_request_dateInclude<ExtArgs> | null
    where?: Leave_request_dateWhereInput
    orderBy?: Leave_request_dateOrderByWithRelationInput | Leave_request_dateOrderByWithRelationInput[]
    cursor?: Leave_request_dateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Leave_request_dateScalarFieldEnum | Leave_request_dateScalarFieldEnum[]
  }

  /**
   * Leave_request.approvedByUser
   */
  export type Leave_request$approvedByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Leave_request without action
   */
  export type Leave_requestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_request
     */
    select?: Leave_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_request
     */
    omit?: Leave_requestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_requestInclude<ExtArgs> | null
  }


  /**
   * Model Leave_request_date
   */

  export type AggregateLeave_request_date = {
    _count: Leave_request_dateCountAggregateOutputType | null
    _avg: Leave_request_dateAvgAggregateOutputType | null
    _sum: Leave_request_dateSumAggregateOutputType | null
    _min: Leave_request_dateMinAggregateOutputType | null
    _max: Leave_request_dateMaxAggregateOutputType | null
  }

  export type Leave_request_dateAvgAggregateOutputType = {
    id: number | null
    requestId: number | null
  }

  export type Leave_request_dateSumAggregateOutputType = {
    id: number | null
    requestId: number | null
  }

  export type Leave_request_dateMinAggregateOutputType = {
    id: number | null
    requestId: number | null
    leaveDate: Date | null
    isHalfDay: boolean | null
    halfdayType: $Enums.HalfdayType | null
  }

  export type Leave_request_dateMaxAggregateOutputType = {
    id: number | null
    requestId: number | null
    leaveDate: Date | null
    isHalfDay: boolean | null
    halfdayType: $Enums.HalfdayType | null
  }

  export type Leave_request_dateCountAggregateOutputType = {
    id: number
    requestId: number
    leaveDate: number
    isHalfDay: number
    halfdayType: number
    _all: number
  }


  export type Leave_request_dateAvgAggregateInputType = {
    id?: true
    requestId?: true
  }

  export type Leave_request_dateSumAggregateInputType = {
    id?: true
    requestId?: true
  }

  export type Leave_request_dateMinAggregateInputType = {
    id?: true
    requestId?: true
    leaveDate?: true
    isHalfDay?: true
    halfdayType?: true
  }

  export type Leave_request_dateMaxAggregateInputType = {
    id?: true
    requestId?: true
    leaveDate?: true
    isHalfDay?: true
    halfdayType?: true
  }

  export type Leave_request_dateCountAggregateInputType = {
    id?: true
    requestId?: true
    leaveDate?: true
    isHalfDay?: true
    halfdayType?: true
    _all?: true
  }

  export type Leave_request_dateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leave_request_date to aggregate.
     */
    where?: Leave_request_dateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leave_request_dates to fetch.
     */
    orderBy?: Leave_request_dateOrderByWithRelationInput | Leave_request_dateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Leave_request_dateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leave_request_dates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leave_request_dates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leave_request_dates
    **/
    _count?: true | Leave_request_dateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Leave_request_dateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Leave_request_dateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Leave_request_dateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Leave_request_dateMaxAggregateInputType
  }

  export type GetLeave_request_dateAggregateType<T extends Leave_request_dateAggregateArgs> = {
        [P in keyof T & keyof AggregateLeave_request_date]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeave_request_date[P]>
      : GetScalarType<T[P], AggregateLeave_request_date[P]>
  }




  export type Leave_request_dateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Leave_request_dateWhereInput
    orderBy?: Leave_request_dateOrderByWithAggregationInput | Leave_request_dateOrderByWithAggregationInput[]
    by: Leave_request_dateScalarFieldEnum[] | Leave_request_dateScalarFieldEnum
    having?: Leave_request_dateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Leave_request_dateCountAggregateInputType | true
    _avg?: Leave_request_dateAvgAggregateInputType
    _sum?: Leave_request_dateSumAggregateInputType
    _min?: Leave_request_dateMinAggregateInputType
    _max?: Leave_request_dateMaxAggregateInputType
  }

  export type Leave_request_dateGroupByOutputType = {
    id: number
    requestId: number
    leaveDate: Date
    isHalfDay: boolean
    halfdayType: $Enums.HalfdayType | null
    _count: Leave_request_dateCountAggregateOutputType | null
    _avg: Leave_request_dateAvgAggregateOutputType | null
    _sum: Leave_request_dateSumAggregateOutputType | null
    _min: Leave_request_dateMinAggregateOutputType | null
    _max: Leave_request_dateMaxAggregateOutputType | null
  }

  type GetLeave_request_dateGroupByPayload<T extends Leave_request_dateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Leave_request_dateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Leave_request_dateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Leave_request_dateGroupByOutputType[P]>
            : GetScalarType<T[P], Leave_request_dateGroupByOutputType[P]>
        }
      >
    >


  export type Leave_request_dateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    leaveDate?: boolean
    isHalfDay?: boolean
    halfdayType?: boolean
    request?: boolean | Leave_requestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leave_request_date"]>

  export type Leave_request_dateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    leaveDate?: boolean
    isHalfDay?: boolean
    halfdayType?: boolean
    request?: boolean | Leave_requestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leave_request_date"]>

  export type Leave_request_dateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    leaveDate?: boolean
    isHalfDay?: boolean
    halfdayType?: boolean
    request?: boolean | Leave_requestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leave_request_date"]>

  export type Leave_request_dateSelectScalar = {
    id?: boolean
    requestId?: boolean
    leaveDate?: boolean
    isHalfDay?: boolean
    halfdayType?: boolean
  }

  export type Leave_request_dateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "requestId" | "leaveDate" | "isHalfDay" | "halfdayType", ExtArgs["result"]["leave_request_date"]>
  export type Leave_request_dateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | Leave_requestDefaultArgs<ExtArgs>
  }
  export type Leave_request_dateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | Leave_requestDefaultArgs<ExtArgs>
  }
  export type Leave_request_dateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | Leave_requestDefaultArgs<ExtArgs>
  }

  export type $Leave_request_datePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Leave_request_date"
    objects: {
      request: Prisma.$Leave_requestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      requestId: number
      leaveDate: Date
      isHalfDay: boolean
      halfdayType: $Enums.HalfdayType | null
    }, ExtArgs["result"]["leave_request_date"]>
    composites: {}
  }

  type Leave_request_dateGetPayload<S extends boolean | null | undefined | Leave_request_dateDefaultArgs> = $Result.GetResult<Prisma.$Leave_request_datePayload, S>

  type Leave_request_dateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Leave_request_dateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Leave_request_dateCountAggregateInputType | true
    }

  export interface Leave_request_dateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Leave_request_date'], meta: { name: 'Leave_request_date' } }
    /**
     * Find zero or one Leave_request_date that matches the filter.
     * @param {Leave_request_dateFindUniqueArgs} args - Arguments to find a Leave_request_date
     * @example
     * // Get one Leave_request_date
     * const leave_request_date = await prisma.leave_request_date.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Leave_request_dateFindUniqueArgs>(args: SelectSubset<T, Leave_request_dateFindUniqueArgs<ExtArgs>>): Prisma__Leave_request_dateClient<$Result.GetResult<Prisma.$Leave_request_datePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Leave_request_date that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Leave_request_dateFindUniqueOrThrowArgs} args - Arguments to find a Leave_request_date
     * @example
     * // Get one Leave_request_date
     * const leave_request_date = await prisma.leave_request_date.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Leave_request_dateFindUniqueOrThrowArgs>(args: SelectSubset<T, Leave_request_dateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Leave_request_dateClient<$Result.GetResult<Prisma.$Leave_request_datePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leave_request_date that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Leave_request_dateFindFirstArgs} args - Arguments to find a Leave_request_date
     * @example
     * // Get one Leave_request_date
     * const leave_request_date = await prisma.leave_request_date.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Leave_request_dateFindFirstArgs>(args?: SelectSubset<T, Leave_request_dateFindFirstArgs<ExtArgs>>): Prisma__Leave_request_dateClient<$Result.GetResult<Prisma.$Leave_request_datePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leave_request_date that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Leave_request_dateFindFirstOrThrowArgs} args - Arguments to find a Leave_request_date
     * @example
     * // Get one Leave_request_date
     * const leave_request_date = await prisma.leave_request_date.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Leave_request_dateFindFirstOrThrowArgs>(args?: SelectSubset<T, Leave_request_dateFindFirstOrThrowArgs<ExtArgs>>): Prisma__Leave_request_dateClient<$Result.GetResult<Prisma.$Leave_request_datePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leave_request_dates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Leave_request_dateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leave_request_dates
     * const leave_request_dates = await prisma.leave_request_date.findMany()
     * 
     * // Get first 10 Leave_request_dates
     * const leave_request_dates = await prisma.leave_request_date.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leave_request_dateWithIdOnly = await prisma.leave_request_date.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Leave_request_dateFindManyArgs>(args?: SelectSubset<T, Leave_request_dateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Leave_request_datePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Leave_request_date.
     * @param {Leave_request_dateCreateArgs} args - Arguments to create a Leave_request_date.
     * @example
     * // Create one Leave_request_date
     * const Leave_request_date = await prisma.leave_request_date.create({
     *   data: {
     *     // ... data to create a Leave_request_date
     *   }
     * })
     * 
     */
    create<T extends Leave_request_dateCreateArgs>(args: SelectSubset<T, Leave_request_dateCreateArgs<ExtArgs>>): Prisma__Leave_request_dateClient<$Result.GetResult<Prisma.$Leave_request_datePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leave_request_dates.
     * @param {Leave_request_dateCreateManyArgs} args - Arguments to create many Leave_request_dates.
     * @example
     * // Create many Leave_request_dates
     * const leave_request_date = await prisma.leave_request_date.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Leave_request_dateCreateManyArgs>(args?: SelectSubset<T, Leave_request_dateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leave_request_dates and returns the data saved in the database.
     * @param {Leave_request_dateCreateManyAndReturnArgs} args - Arguments to create many Leave_request_dates.
     * @example
     * // Create many Leave_request_dates
     * const leave_request_date = await prisma.leave_request_date.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leave_request_dates and only return the `id`
     * const leave_request_dateWithIdOnly = await prisma.leave_request_date.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Leave_request_dateCreateManyAndReturnArgs>(args?: SelectSubset<T, Leave_request_dateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Leave_request_datePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Leave_request_date.
     * @param {Leave_request_dateDeleteArgs} args - Arguments to delete one Leave_request_date.
     * @example
     * // Delete one Leave_request_date
     * const Leave_request_date = await prisma.leave_request_date.delete({
     *   where: {
     *     // ... filter to delete one Leave_request_date
     *   }
     * })
     * 
     */
    delete<T extends Leave_request_dateDeleteArgs>(args: SelectSubset<T, Leave_request_dateDeleteArgs<ExtArgs>>): Prisma__Leave_request_dateClient<$Result.GetResult<Prisma.$Leave_request_datePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Leave_request_date.
     * @param {Leave_request_dateUpdateArgs} args - Arguments to update one Leave_request_date.
     * @example
     * // Update one Leave_request_date
     * const leave_request_date = await prisma.leave_request_date.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Leave_request_dateUpdateArgs>(args: SelectSubset<T, Leave_request_dateUpdateArgs<ExtArgs>>): Prisma__Leave_request_dateClient<$Result.GetResult<Prisma.$Leave_request_datePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leave_request_dates.
     * @param {Leave_request_dateDeleteManyArgs} args - Arguments to filter Leave_request_dates to delete.
     * @example
     * // Delete a few Leave_request_dates
     * const { count } = await prisma.leave_request_date.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Leave_request_dateDeleteManyArgs>(args?: SelectSubset<T, Leave_request_dateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leave_request_dates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Leave_request_dateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leave_request_dates
     * const leave_request_date = await prisma.leave_request_date.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Leave_request_dateUpdateManyArgs>(args: SelectSubset<T, Leave_request_dateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leave_request_dates and returns the data updated in the database.
     * @param {Leave_request_dateUpdateManyAndReturnArgs} args - Arguments to update many Leave_request_dates.
     * @example
     * // Update many Leave_request_dates
     * const leave_request_date = await prisma.leave_request_date.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Leave_request_dates and only return the `id`
     * const leave_request_dateWithIdOnly = await prisma.leave_request_date.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Leave_request_dateUpdateManyAndReturnArgs>(args: SelectSubset<T, Leave_request_dateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Leave_request_datePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Leave_request_date.
     * @param {Leave_request_dateUpsertArgs} args - Arguments to update or create a Leave_request_date.
     * @example
     * // Update or create a Leave_request_date
     * const leave_request_date = await prisma.leave_request_date.upsert({
     *   create: {
     *     // ... data to create a Leave_request_date
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Leave_request_date we want to update
     *   }
     * })
     */
    upsert<T extends Leave_request_dateUpsertArgs>(args: SelectSubset<T, Leave_request_dateUpsertArgs<ExtArgs>>): Prisma__Leave_request_dateClient<$Result.GetResult<Prisma.$Leave_request_datePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leave_request_dates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Leave_request_dateCountArgs} args - Arguments to filter Leave_request_dates to count.
     * @example
     * // Count the number of Leave_request_dates
     * const count = await prisma.leave_request_date.count({
     *   where: {
     *     // ... the filter for the Leave_request_dates we want to count
     *   }
     * })
    **/
    count<T extends Leave_request_dateCountArgs>(
      args?: Subset<T, Leave_request_dateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Leave_request_dateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Leave_request_date.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Leave_request_dateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Leave_request_dateAggregateArgs>(args: Subset<T, Leave_request_dateAggregateArgs>): Prisma.PrismaPromise<GetLeave_request_dateAggregateType<T>>

    /**
     * Group by Leave_request_date.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Leave_request_dateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Leave_request_dateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Leave_request_dateGroupByArgs['orderBy'] }
        : { orderBy?: Leave_request_dateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Leave_request_dateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeave_request_dateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Leave_request_date model
   */
  readonly fields: Leave_request_dateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Leave_request_date.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Leave_request_dateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    request<T extends Leave_requestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Leave_requestDefaultArgs<ExtArgs>>): Prisma__Leave_requestClient<$Result.GetResult<Prisma.$Leave_requestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Leave_request_date model
   */
  interface Leave_request_dateFieldRefs {
    readonly id: FieldRef<"Leave_request_date", 'Int'>
    readonly requestId: FieldRef<"Leave_request_date", 'Int'>
    readonly leaveDate: FieldRef<"Leave_request_date", 'DateTime'>
    readonly isHalfDay: FieldRef<"Leave_request_date", 'Boolean'>
    readonly halfdayType: FieldRef<"Leave_request_date", 'HalfdayType'>
  }
    

  // Custom InputTypes
  /**
   * Leave_request_date findUnique
   */
  export type Leave_request_dateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_request_date
     */
    select?: Leave_request_dateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_request_date
     */
    omit?: Leave_request_dateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_request_dateInclude<ExtArgs> | null
    /**
     * Filter, which Leave_request_date to fetch.
     */
    where: Leave_request_dateWhereUniqueInput
  }

  /**
   * Leave_request_date findUniqueOrThrow
   */
  export type Leave_request_dateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_request_date
     */
    select?: Leave_request_dateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_request_date
     */
    omit?: Leave_request_dateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_request_dateInclude<ExtArgs> | null
    /**
     * Filter, which Leave_request_date to fetch.
     */
    where: Leave_request_dateWhereUniqueInput
  }

  /**
   * Leave_request_date findFirst
   */
  export type Leave_request_dateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_request_date
     */
    select?: Leave_request_dateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_request_date
     */
    omit?: Leave_request_dateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_request_dateInclude<ExtArgs> | null
    /**
     * Filter, which Leave_request_date to fetch.
     */
    where?: Leave_request_dateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leave_request_dates to fetch.
     */
    orderBy?: Leave_request_dateOrderByWithRelationInput | Leave_request_dateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leave_request_dates.
     */
    cursor?: Leave_request_dateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leave_request_dates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leave_request_dates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leave_request_dates.
     */
    distinct?: Leave_request_dateScalarFieldEnum | Leave_request_dateScalarFieldEnum[]
  }

  /**
   * Leave_request_date findFirstOrThrow
   */
  export type Leave_request_dateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_request_date
     */
    select?: Leave_request_dateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_request_date
     */
    omit?: Leave_request_dateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_request_dateInclude<ExtArgs> | null
    /**
     * Filter, which Leave_request_date to fetch.
     */
    where?: Leave_request_dateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leave_request_dates to fetch.
     */
    orderBy?: Leave_request_dateOrderByWithRelationInput | Leave_request_dateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leave_request_dates.
     */
    cursor?: Leave_request_dateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leave_request_dates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leave_request_dates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leave_request_dates.
     */
    distinct?: Leave_request_dateScalarFieldEnum | Leave_request_dateScalarFieldEnum[]
  }

  /**
   * Leave_request_date findMany
   */
  export type Leave_request_dateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_request_date
     */
    select?: Leave_request_dateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_request_date
     */
    omit?: Leave_request_dateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_request_dateInclude<ExtArgs> | null
    /**
     * Filter, which Leave_request_dates to fetch.
     */
    where?: Leave_request_dateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leave_request_dates to fetch.
     */
    orderBy?: Leave_request_dateOrderByWithRelationInput | Leave_request_dateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leave_request_dates.
     */
    cursor?: Leave_request_dateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leave_request_dates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leave_request_dates.
     */
    skip?: number
    distinct?: Leave_request_dateScalarFieldEnum | Leave_request_dateScalarFieldEnum[]
  }

  /**
   * Leave_request_date create
   */
  export type Leave_request_dateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_request_date
     */
    select?: Leave_request_dateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_request_date
     */
    omit?: Leave_request_dateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_request_dateInclude<ExtArgs> | null
    /**
     * The data needed to create a Leave_request_date.
     */
    data: XOR<Leave_request_dateCreateInput, Leave_request_dateUncheckedCreateInput>
  }

  /**
   * Leave_request_date createMany
   */
  export type Leave_request_dateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leave_request_dates.
     */
    data: Leave_request_dateCreateManyInput | Leave_request_dateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Leave_request_date createManyAndReturn
   */
  export type Leave_request_dateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_request_date
     */
    select?: Leave_request_dateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_request_date
     */
    omit?: Leave_request_dateOmit<ExtArgs> | null
    /**
     * The data used to create many Leave_request_dates.
     */
    data: Leave_request_dateCreateManyInput | Leave_request_dateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_request_dateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Leave_request_date update
   */
  export type Leave_request_dateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_request_date
     */
    select?: Leave_request_dateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_request_date
     */
    omit?: Leave_request_dateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_request_dateInclude<ExtArgs> | null
    /**
     * The data needed to update a Leave_request_date.
     */
    data: XOR<Leave_request_dateUpdateInput, Leave_request_dateUncheckedUpdateInput>
    /**
     * Choose, which Leave_request_date to update.
     */
    where: Leave_request_dateWhereUniqueInput
  }

  /**
   * Leave_request_date updateMany
   */
  export type Leave_request_dateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leave_request_dates.
     */
    data: XOR<Leave_request_dateUpdateManyMutationInput, Leave_request_dateUncheckedUpdateManyInput>
    /**
     * Filter which Leave_request_dates to update
     */
    where?: Leave_request_dateWhereInput
    /**
     * Limit how many Leave_request_dates to update.
     */
    limit?: number
  }

  /**
   * Leave_request_date updateManyAndReturn
   */
  export type Leave_request_dateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_request_date
     */
    select?: Leave_request_dateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_request_date
     */
    omit?: Leave_request_dateOmit<ExtArgs> | null
    /**
     * The data used to update Leave_request_dates.
     */
    data: XOR<Leave_request_dateUpdateManyMutationInput, Leave_request_dateUncheckedUpdateManyInput>
    /**
     * Filter which Leave_request_dates to update
     */
    where?: Leave_request_dateWhereInput
    /**
     * Limit how many Leave_request_dates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_request_dateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Leave_request_date upsert
   */
  export type Leave_request_dateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_request_date
     */
    select?: Leave_request_dateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_request_date
     */
    omit?: Leave_request_dateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_request_dateInclude<ExtArgs> | null
    /**
     * The filter to search for the Leave_request_date to update in case it exists.
     */
    where: Leave_request_dateWhereUniqueInput
    /**
     * In case the Leave_request_date found by the `where` argument doesn't exist, create a new Leave_request_date with this data.
     */
    create: XOR<Leave_request_dateCreateInput, Leave_request_dateUncheckedCreateInput>
    /**
     * In case the Leave_request_date was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Leave_request_dateUpdateInput, Leave_request_dateUncheckedUpdateInput>
  }

  /**
   * Leave_request_date delete
   */
  export type Leave_request_dateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_request_date
     */
    select?: Leave_request_dateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_request_date
     */
    omit?: Leave_request_dateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_request_dateInclude<ExtArgs> | null
    /**
     * Filter which Leave_request_date to delete.
     */
    where: Leave_request_dateWhereUniqueInput
  }

  /**
   * Leave_request_date deleteMany
   */
  export type Leave_request_dateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leave_request_dates to delete
     */
    where?: Leave_request_dateWhereInput
    /**
     * Limit how many Leave_request_dates to delete.
     */
    limit?: number
  }

  /**
   * Leave_request_date without action
   */
  export type Leave_request_dateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_request_date
     */
    select?: Leave_request_dateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_request_date
     */
    omit?: Leave_request_dateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_request_dateInclude<ExtArgs> | null
  }


  /**
   * Model Leave_balance
   */

  export type AggregateLeave_balance = {
    _count: Leave_balanceCountAggregateOutputType | null
    _avg: Leave_balanceAvgAggregateOutputType | null
    _sum: Leave_balanceSumAggregateOutputType | null
    _min: Leave_balanceMinAggregateOutputType | null
    _max: Leave_balanceMaxAggregateOutputType | null
  }

  export type Leave_balanceAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    year: number | null
    balance: number | null
  }

  export type Leave_balanceSumAggregateOutputType = {
    id: number | null
    userId: number | null
    year: number | null
    balance: number | null
  }

  export type Leave_balanceMinAggregateOutputType = {
    id: number | null
    userId: number | null
    year: number | null
    leaveType: $Enums.LeaveType | null
    balance: number | null
  }

  export type Leave_balanceMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    year: number | null
    leaveType: $Enums.LeaveType | null
    balance: number | null
  }

  export type Leave_balanceCountAggregateOutputType = {
    id: number
    userId: number
    year: number
    leaveType: number
    balance: number
    _all: number
  }


  export type Leave_balanceAvgAggregateInputType = {
    id?: true
    userId?: true
    year?: true
    balance?: true
  }

  export type Leave_balanceSumAggregateInputType = {
    id?: true
    userId?: true
    year?: true
    balance?: true
  }

  export type Leave_balanceMinAggregateInputType = {
    id?: true
    userId?: true
    year?: true
    leaveType?: true
    balance?: true
  }

  export type Leave_balanceMaxAggregateInputType = {
    id?: true
    userId?: true
    year?: true
    leaveType?: true
    balance?: true
  }

  export type Leave_balanceCountAggregateInputType = {
    id?: true
    userId?: true
    year?: true
    leaveType?: true
    balance?: true
    _all?: true
  }

  export type Leave_balanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leave_balance to aggregate.
     */
    where?: Leave_balanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leave_balances to fetch.
     */
    orderBy?: Leave_balanceOrderByWithRelationInput | Leave_balanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Leave_balanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leave_balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leave_balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leave_balances
    **/
    _count?: true | Leave_balanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Leave_balanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Leave_balanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Leave_balanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Leave_balanceMaxAggregateInputType
  }

  export type GetLeave_balanceAggregateType<T extends Leave_balanceAggregateArgs> = {
        [P in keyof T & keyof AggregateLeave_balance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeave_balance[P]>
      : GetScalarType<T[P], AggregateLeave_balance[P]>
  }




  export type Leave_balanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Leave_balanceWhereInput
    orderBy?: Leave_balanceOrderByWithAggregationInput | Leave_balanceOrderByWithAggregationInput[]
    by: Leave_balanceScalarFieldEnum[] | Leave_balanceScalarFieldEnum
    having?: Leave_balanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Leave_balanceCountAggregateInputType | true
    _avg?: Leave_balanceAvgAggregateInputType
    _sum?: Leave_balanceSumAggregateInputType
    _min?: Leave_balanceMinAggregateInputType
    _max?: Leave_balanceMaxAggregateInputType
  }

  export type Leave_balanceGroupByOutputType = {
    id: number
    userId: number
    year: number
    leaveType: $Enums.LeaveType
    balance: number
    _count: Leave_balanceCountAggregateOutputType | null
    _avg: Leave_balanceAvgAggregateOutputType | null
    _sum: Leave_balanceSumAggregateOutputType | null
    _min: Leave_balanceMinAggregateOutputType | null
    _max: Leave_balanceMaxAggregateOutputType | null
  }

  type GetLeave_balanceGroupByPayload<T extends Leave_balanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Leave_balanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Leave_balanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Leave_balanceGroupByOutputType[P]>
            : GetScalarType<T[P], Leave_balanceGroupByOutputType[P]>
        }
      >
    >


  export type Leave_balanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    year?: boolean
    leaveType?: boolean
    balance?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leave_balance"]>

  export type Leave_balanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    year?: boolean
    leaveType?: boolean
    balance?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leave_balance"]>

  export type Leave_balanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    year?: boolean
    leaveType?: boolean
    balance?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leave_balance"]>

  export type Leave_balanceSelectScalar = {
    id?: boolean
    userId?: boolean
    year?: boolean
    leaveType?: boolean
    balance?: boolean
  }

  export type Leave_balanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "year" | "leaveType" | "balance", ExtArgs["result"]["leave_balance"]>
  export type Leave_balanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type Leave_balanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type Leave_balanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $Leave_balancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Leave_balance"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      year: number
      leaveType: $Enums.LeaveType
      balance: number
    }, ExtArgs["result"]["leave_balance"]>
    composites: {}
  }

  type Leave_balanceGetPayload<S extends boolean | null | undefined | Leave_balanceDefaultArgs> = $Result.GetResult<Prisma.$Leave_balancePayload, S>

  type Leave_balanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Leave_balanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Leave_balanceCountAggregateInputType | true
    }

  export interface Leave_balanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Leave_balance'], meta: { name: 'Leave_balance' } }
    /**
     * Find zero or one Leave_balance that matches the filter.
     * @param {Leave_balanceFindUniqueArgs} args - Arguments to find a Leave_balance
     * @example
     * // Get one Leave_balance
     * const leave_balance = await prisma.leave_balance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Leave_balanceFindUniqueArgs>(args: SelectSubset<T, Leave_balanceFindUniqueArgs<ExtArgs>>): Prisma__Leave_balanceClient<$Result.GetResult<Prisma.$Leave_balancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Leave_balance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Leave_balanceFindUniqueOrThrowArgs} args - Arguments to find a Leave_balance
     * @example
     * // Get one Leave_balance
     * const leave_balance = await prisma.leave_balance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Leave_balanceFindUniqueOrThrowArgs>(args: SelectSubset<T, Leave_balanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Leave_balanceClient<$Result.GetResult<Prisma.$Leave_balancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leave_balance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Leave_balanceFindFirstArgs} args - Arguments to find a Leave_balance
     * @example
     * // Get one Leave_balance
     * const leave_balance = await prisma.leave_balance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Leave_balanceFindFirstArgs>(args?: SelectSubset<T, Leave_balanceFindFirstArgs<ExtArgs>>): Prisma__Leave_balanceClient<$Result.GetResult<Prisma.$Leave_balancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leave_balance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Leave_balanceFindFirstOrThrowArgs} args - Arguments to find a Leave_balance
     * @example
     * // Get one Leave_balance
     * const leave_balance = await prisma.leave_balance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Leave_balanceFindFirstOrThrowArgs>(args?: SelectSubset<T, Leave_balanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__Leave_balanceClient<$Result.GetResult<Prisma.$Leave_balancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leave_balances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Leave_balanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leave_balances
     * const leave_balances = await prisma.leave_balance.findMany()
     * 
     * // Get first 10 Leave_balances
     * const leave_balances = await prisma.leave_balance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leave_balanceWithIdOnly = await prisma.leave_balance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Leave_balanceFindManyArgs>(args?: SelectSubset<T, Leave_balanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Leave_balancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Leave_balance.
     * @param {Leave_balanceCreateArgs} args - Arguments to create a Leave_balance.
     * @example
     * // Create one Leave_balance
     * const Leave_balance = await prisma.leave_balance.create({
     *   data: {
     *     // ... data to create a Leave_balance
     *   }
     * })
     * 
     */
    create<T extends Leave_balanceCreateArgs>(args: SelectSubset<T, Leave_balanceCreateArgs<ExtArgs>>): Prisma__Leave_balanceClient<$Result.GetResult<Prisma.$Leave_balancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leave_balances.
     * @param {Leave_balanceCreateManyArgs} args - Arguments to create many Leave_balances.
     * @example
     * // Create many Leave_balances
     * const leave_balance = await prisma.leave_balance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Leave_balanceCreateManyArgs>(args?: SelectSubset<T, Leave_balanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leave_balances and returns the data saved in the database.
     * @param {Leave_balanceCreateManyAndReturnArgs} args - Arguments to create many Leave_balances.
     * @example
     * // Create many Leave_balances
     * const leave_balance = await prisma.leave_balance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leave_balances and only return the `id`
     * const leave_balanceWithIdOnly = await prisma.leave_balance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Leave_balanceCreateManyAndReturnArgs>(args?: SelectSubset<T, Leave_balanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Leave_balancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Leave_balance.
     * @param {Leave_balanceDeleteArgs} args - Arguments to delete one Leave_balance.
     * @example
     * // Delete one Leave_balance
     * const Leave_balance = await prisma.leave_balance.delete({
     *   where: {
     *     // ... filter to delete one Leave_balance
     *   }
     * })
     * 
     */
    delete<T extends Leave_balanceDeleteArgs>(args: SelectSubset<T, Leave_balanceDeleteArgs<ExtArgs>>): Prisma__Leave_balanceClient<$Result.GetResult<Prisma.$Leave_balancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Leave_balance.
     * @param {Leave_balanceUpdateArgs} args - Arguments to update one Leave_balance.
     * @example
     * // Update one Leave_balance
     * const leave_balance = await prisma.leave_balance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Leave_balanceUpdateArgs>(args: SelectSubset<T, Leave_balanceUpdateArgs<ExtArgs>>): Prisma__Leave_balanceClient<$Result.GetResult<Prisma.$Leave_balancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leave_balances.
     * @param {Leave_balanceDeleteManyArgs} args - Arguments to filter Leave_balances to delete.
     * @example
     * // Delete a few Leave_balances
     * const { count } = await prisma.leave_balance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Leave_balanceDeleteManyArgs>(args?: SelectSubset<T, Leave_balanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leave_balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Leave_balanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leave_balances
     * const leave_balance = await prisma.leave_balance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Leave_balanceUpdateManyArgs>(args: SelectSubset<T, Leave_balanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leave_balances and returns the data updated in the database.
     * @param {Leave_balanceUpdateManyAndReturnArgs} args - Arguments to update many Leave_balances.
     * @example
     * // Update many Leave_balances
     * const leave_balance = await prisma.leave_balance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Leave_balances and only return the `id`
     * const leave_balanceWithIdOnly = await prisma.leave_balance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Leave_balanceUpdateManyAndReturnArgs>(args: SelectSubset<T, Leave_balanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Leave_balancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Leave_balance.
     * @param {Leave_balanceUpsertArgs} args - Arguments to update or create a Leave_balance.
     * @example
     * // Update or create a Leave_balance
     * const leave_balance = await prisma.leave_balance.upsert({
     *   create: {
     *     // ... data to create a Leave_balance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Leave_balance we want to update
     *   }
     * })
     */
    upsert<T extends Leave_balanceUpsertArgs>(args: SelectSubset<T, Leave_balanceUpsertArgs<ExtArgs>>): Prisma__Leave_balanceClient<$Result.GetResult<Prisma.$Leave_balancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leave_balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Leave_balanceCountArgs} args - Arguments to filter Leave_balances to count.
     * @example
     * // Count the number of Leave_balances
     * const count = await prisma.leave_balance.count({
     *   where: {
     *     // ... the filter for the Leave_balances we want to count
     *   }
     * })
    **/
    count<T extends Leave_balanceCountArgs>(
      args?: Subset<T, Leave_balanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Leave_balanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Leave_balance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Leave_balanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Leave_balanceAggregateArgs>(args: Subset<T, Leave_balanceAggregateArgs>): Prisma.PrismaPromise<GetLeave_balanceAggregateType<T>>

    /**
     * Group by Leave_balance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Leave_balanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Leave_balanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Leave_balanceGroupByArgs['orderBy'] }
        : { orderBy?: Leave_balanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Leave_balanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeave_balanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Leave_balance model
   */
  readonly fields: Leave_balanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Leave_balance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Leave_balanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Leave_balance model
   */
  interface Leave_balanceFieldRefs {
    readonly id: FieldRef<"Leave_balance", 'Int'>
    readonly userId: FieldRef<"Leave_balance", 'Int'>
    readonly year: FieldRef<"Leave_balance", 'Int'>
    readonly leaveType: FieldRef<"Leave_balance", 'LeaveType'>
    readonly balance: FieldRef<"Leave_balance", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Leave_balance findUnique
   */
  export type Leave_balanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_balance
     */
    select?: Leave_balanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_balance
     */
    omit?: Leave_balanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_balanceInclude<ExtArgs> | null
    /**
     * Filter, which Leave_balance to fetch.
     */
    where: Leave_balanceWhereUniqueInput
  }

  /**
   * Leave_balance findUniqueOrThrow
   */
  export type Leave_balanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_balance
     */
    select?: Leave_balanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_balance
     */
    omit?: Leave_balanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_balanceInclude<ExtArgs> | null
    /**
     * Filter, which Leave_balance to fetch.
     */
    where: Leave_balanceWhereUniqueInput
  }

  /**
   * Leave_balance findFirst
   */
  export type Leave_balanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_balance
     */
    select?: Leave_balanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_balance
     */
    omit?: Leave_balanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_balanceInclude<ExtArgs> | null
    /**
     * Filter, which Leave_balance to fetch.
     */
    where?: Leave_balanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leave_balances to fetch.
     */
    orderBy?: Leave_balanceOrderByWithRelationInput | Leave_balanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leave_balances.
     */
    cursor?: Leave_balanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leave_balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leave_balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leave_balances.
     */
    distinct?: Leave_balanceScalarFieldEnum | Leave_balanceScalarFieldEnum[]
  }

  /**
   * Leave_balance findFirstOrThrow
   */
  export type Leave_balanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_balance
     */
    select?: Leave_balanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_balance
     */
    omit?: Leave_balanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_balanceInclude<ExtArgs> | null
    /**
     * Filter, which Leave_balance to fetch.
     */
    where?: Leave_balanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leave_balances to fetch.
     */
    orderBy?: Leave_balanceOrderByWithRelationInput | Leave_balanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leave_balances.
     */
    cursor?: Leave_balanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leave_balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leave_balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leave_balances.
     */
    distinct?: Leave_balanceScalarFieldEnum | Leave_balanceScalarFieldEnum[]
  }

  /**
   * Leave_balance findMany
   */
  export type Leave_balanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_balance
     */
    select?: Leave_balanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_balance
     */
    omit?: Leave_balanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_balanceInclude<ExtArgs> | null
    /**
     * Filter, which Leave_balances to fetch.
     */
    where?: Leave_balanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leave_balances to fetch.
     */
    orderBy?: Leave_balanceOrderByWithRelationInput | Leave_balanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leave_balances.
     */
    cursor?: Leave_balanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leave_balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leave_balances.
     */
    skip?: number
    distinct?: Leave_balanceScalarFieldEnum | Leave_balanceScalarFieldEnum[]
  }

  /**
   * Leave_balance create
   */
  export type Leave_balanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_balance
     */
    select?: Leave_balanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_balance
     */
    omit?: Leave_balanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_balanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Leave_balance.
     */
    data: XOR<Leave_balanceCreateInput, Leave_balanceUncheckedCreateInput>
  }

  /**
   * Leave_balance createMany
   */
  export type Leave_balanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leave_balances.
     */
    data: Leave_balanceCreateManyInput | Leave_balanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Leave_balance createManyAndReturn
   */
  export type Leave_balanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_balance
     */
    select?: Leave_balanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_balance
     */
    omit?: Leave_balanceOmit<ExtArgs> | null
    /**
     * The data used to create many Leave_balances.
     */
    data: Leave_balanceCreateManyInput | Leave_balanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_balanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Leave_balance update
   */
  export type Leave_balanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_balance
     */
    select?: Leave_balanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_balance
     */
    omit?: Leave_balanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_balanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Leave_balance.
     */
    data: XOR<Leave_balanceUpdateInput, Leave_balanceUncheckedUpdateInput>
    /**
     * Choose, which Leave_balance to update.
     */
    where: Leave_balanceWhereUniqueInput
  }

  /**
   * Leave_balance updateMany
   */
  export type Leave_balanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leave_balances.
     */
    data: XOR<Leave_balanceUpdateManyMutationInput, Leave_balanceUncheckedUpdateManyInput>
    /**
     * Filter which Leave_balances to update
     */
    where?: Leave_balanceWhereInput
    /**
     * Limit how many Leave_balances to update.
     */
    limit?: number
  }

  /**
   * Leave_balance updateManyAndReturn
   */
  export type Leave_balanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_balance
     */
    select?: Leave_balanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_balance
     */
    omit?: Leave_balanceOmit<ExtArgs> | null
    /**
     * The data used to update Leave_balances.
     */
    data: XOR<Leave_balanceUpdateManyMutationInput, Leave_balanceUncheckedUpdateManyInput>
    /**
     * Filter which Leave_balances to update
     */
    where?: Leave_balanceWhereInput
    /**
     * Limit how many Leave_balances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_balanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Leave_balance upsert
   */
  export type Leave_balanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_balance
     */
    select?: Leave_balanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_balance
     */
    omit?: Leave_balanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_balanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Leave_balance to update in case it exists.
     */
    where: Leave_balanceWhereUniqueInput
    /**
     * In case the Leave_balance found by the `where` argument doesn't exist, create a new Leave_balance with this data.
     */
    create: XOR<Leave_balanceCreateInput, Leave_balanceUncheckedCreateInput>
    /**
     * In case the Leave_balance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Leave_balanceUpdateInput, Leave_balanceUncheckedUpdateInput>
  }

  /**
   * Leave_balance delete
   */
  export type Leave_balanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_balance
     */
    select?: Leave_balanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_balance
     */
    omit?: Leave_balanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_balanceInclude<ExtArgs> | null
    /**
     * Filter which Leave_balance to delete.
     */
    where: Leave_balanceWhereUniqueInput
  }

  /**
   * Leave_balance deleteMany
   */
  export type Leave_balanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leave_balances to delete
     */
    where?: Leave_balanceWhereInput
    /**
     * Limit how many Leave_balances to delete.
     */
    limit?: number
  }

  /**
   * Leave_balance without action
   */
  export type Leave_balanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_balance
     */
    select?: Leave_balanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_balance
     */
    omit?: Leave_balanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Leave_balanceInclude<ExtArgs> | null
  }


  /**
   * Model Leave_policy
   */

  export type AggregateLeave_policy = {
    _count: Leave_policyCountAggregateOutputType | null
    _avg: Leave_policyAvgAggregateOutputType | null
    _sum: Leave_policySumAggregateOutputType | null
    _min: Leave_policyMinAggregateOutputType | null
    _max: Leave_policyMaxAggregateOutputType | null
  }

  export type Leave_policyAvgAggregateOutputType = {
    defaultBalance: number | null
  }

  export type Leave_policySumAggregateOutputType = {
    defaultBalance: number | null
  }

  export type Leave_policyMinAggregateOutputType = {
    leaveType: $Enums.LeaveType | null
    defaultBalance: number | null
  }

  export type Leave_policyMaxAggregateOutputType = {
    leaveType: $Enums.LeaveType | null
    defaultBalance: number | null
  }

  export type Leave_policyCountAggregateOutputType = {
    leaveType: number
    defaultBalance: number
    _all: number
  }


  export type Leave_policyAvgAggregateInputType = {
    defaultBalance?: true
  }

  export type Leave_policySumAggregateInputType = {
    defaultBalance?: true
  }

  export type Leave_policyMinAggregateInputType = {
    leaveType?: true
    defaultBalance?: true
  }

  export type Leave_policyMaxAggregateInputType = {
    leaveType?: true
    defaultBalance?: true
  }

  export type Leave_policyCountAggregateInputType = {
    leaveType?: true
    defaultBalance?: true
    _all?: true
  }

  export type Leave_policyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leave_policy to aggregate.
     */
    where?: Leave_policyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leave_policies to fetch.
     */
    orderBy?: Leave_policyOrderByWithRelationInput | Leave_policyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Leave_policyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leave_policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leave_policies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leave_policies
    **/
    _count?: true | Leave_policyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Leave_policyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Leave_policySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Leave_policyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Leave_policyMaxAggregateInputType
  }

  export type GetLeave_policyAggregateType<T extends Leave_policyAggregateArgs> = {
        [P in keyof T & keyof AggregateLeave_policy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeave_policy[P]>
      : GetScalarType<T[P], AggregateLeave_policy[P]>
  }




  export type Leave_policyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Leave_policyWhereInput
    orderBy?: Leave_policyOrderByWithAggregationInput | Leave_policyOrderByWithAggregationInput[]
    by: Leave_policyScalarFieldEnum[] | Leave_policyScalarFieldEnum
    having?: Leave_policyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Leave_policyCountAggregateInputType | true
    _avg?: Leave_policyAvgAggregateInputType
    _sum?: Leave_policySumAggregateInputType
    _min?: Leave_policyMinAggregateInputType
    _max?: Leave_policyMaxAggregateInputType
  }

  export type Leave_policyGroupByOutputType = {
    leaveType: $Enums.LeaveType
    defaultBalance: number
    _count: Leave_policyCountAggregateOutputType | null
    _avg: Leave_policyAvgAggregateOutputType | null
    _sum: Leave_policySumAggregateOutputType | null
    _min: Leave_policyMinAggregateOutputType | null
    _max: Leave_policyMaxAggregateOutputType | null
  }

  type GetLeave_policyGroupByPayload<T extends Leave_policyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Leave_policyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Leave_policyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Leave_policyGroupByOutputType[P]>
            : GetScalarType<T[P], Leave_policyGroupByOutputType[P]>
        }
      >
    >


  export type Leave_policySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    leaveType?: boolean
    defaultBalance?: boolean
  }, ExtArgs["result"]["leave_policy"]>

  export type Leave_policySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    leaveType?: boolean
    defaultBalance?: boolean
  }, ExtArgs["result"]["leave_policy"]>

  export type Leave_policySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    leaveType?: boolean
    defaultBalance?: boolean
  }, ExtArgs["result"]["leave_policy"]>

  export type Leave_policySelectScalar = {
    leaveType?: boolean
    defaultBalance?: boolean
  }

  export type Leave_policyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"leaveType" | "defaultBalance", ExtArgs["result"]["leave_policy"]>

  export type $Leave_policyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Leave_policy"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      leaveType: $Enums.LeaveType
      defaultBalance: number
    }, ExtArgs["result"]["leave_policy"]>
    composites: {}
  }

  type Leave_policyGetPayload<S extends boolean | null | undefined | Leave_policyDefaultArgs> = $Result.GetResult<Prisma.$Leave_policyPayload, S>

  type Leave_policyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Leave_policyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Leave_policyCountAggregateInputType | true
    }

  export interface Leave_policyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Leave_policy'], meta: { name: 'Leave_policy' } }
    /**
     * Find zero or one Leave_policy that matches the filter.
     * @param {Leave_policyFindUniqueArgs} args - Arguments to find a Leave_policy
     * @example
     * // Get one Leave_policy
     * const leave_policy = await prisma.leave_policy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Leave_policyFindUniqueArgs>(args: SelectSubset<T, Leave_policyFindUniqueArgs<ExtArgs>>): Prisma__Leave_policyClient<$Result.GetResult<Prisma.$Leave_policyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Leave_policy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Leave_policyFindUniqueOrThrowArgs} args - Arguments to find a Leave_policy
     * @example
     * // Get one Leave_policy
     * const leave_policy = await prisma.leave_policy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Leave_policyFindUniqueOrThrowArgs>(args: SelectSubset<T, Leave_policyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Leave_policyClient<$Result.GetResult<Prisma.$Leave_policyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leave_policy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Leave_policyFindFirstArgs} args - Arguments to find a Leave_policy
     * @example
     * // Get one Leave_policy
     * const leave_policy = await prisma.leave_policy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Leave_policyFindFirstArgs>(args?: SelectSubset<T, Leave_policyFindFirstArgs<ExtArgs>>): Prisma__Leave_policyClient<$Result.GetResult<Prisma.$Leave_policyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leave_policy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Leave_policyFindFirstOrThrowArgs} args - Arguments to find a Leave_policy
     * @example
     * // Get one Leave_policy
     * const leave_policy = await prisma.leave_policy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Leave_policyFindFirstOrThrowArgs>(args?: SelectSubset<T, Leave_policyFindFirstOrThrowArgs<ExtArgs>>): Prisma__Leave_policyClient<$Result.GetResult<Prisma.$Leave_policyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leave_policies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Leave_policyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leave_policies
     * const leave_policies = await prisma.leave_policy.findMany()
     * 
     * // Get first 10 Leave_policies
     * const leave_policies = await prisma.leave_policy.findMany({ take: 10 })
     * 
     * // Only select the `defaultBalance`
     * const leave_policyWithDefaultBalanceOnly = await prisma.leave_policy.findMany({ select: { defaultBalance: true } })
     * 
     */
    findMany<T extends Leave_policyFindManyArgs>(args?: SelectSubset<T, Leave_policyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Leave_policyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Leave_policy.
     * @param {Leave_policyCreateArgs} args - Arguments to create a Leave_policy.
     * @example
     * // Create one Leave_policy
     * const Leave_policy = await prisma.leave_policy.create({
     *   data: {
     *     // ... data to create a Leave_policy
     *   }
     * })
     * 
     */
    create<T extends Leave_policyCreateArgs>(args: SelectSubset<T, Leave_policyCreateArgs<ExtArgs>>): Prisma__Leave_policyClient<$Result.GetResult<Prisma.$Leave_policyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leave_policies.
     * @param {Leave_policyCreateManyArgs} args - Arguments to create many Leave_policies.
     * @example
     * // Create many Leave_policies
     * const leave_policy = await prisma.leave_policy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Leave_policyCreateManyArgs>(args?: SelectSubset<T, Leave_policyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leave_policies and returns the data saved in the database.
     * @param {Leave_policyCreateManyAndReturnArgs} args - Arguments to create many Leave_policies.
     * @example
     * // Create many Leave_policies
     * const leave_policy = await prisma.leave_policy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leave_policies and only return the `defaultBalance`
     * const leave_policyWithDefaultBalanceOnly = await prisma.leave_policy.createManyAndReturn({
     *   select: { defaultBalance: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Leave_policyCreateManyAndReturnArgs>(args?: SelectSubset<T, Leave_policyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Leave_policyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Leave_policy.
     * @param {Leave_policyDeleteArgs} args - Arguments to delete one Leave_policy.
     * @example
     * // Delete one Leave_policy
     * const Leave_policy = await prisma.leave_policy.delete({
     *   where: {
     *     // ... filter to delete one Leave_policy
     *   }
     * })
     * 
     */
    delete<T extends Leave_policyDeleteArgs>(args: SelectSubset<T, Leave_policyDeleteArgs<ExtArgs>>): Prisma__Leave_policyClient<$Result.GetResult<Prisma.$Leave_policyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Leave_policy.
     * @param {Leave_policyUpdateArgs} args - Arguments to update one Leave_policy.
     * @example
     * // Update one Leave_policy
     * const leave_policy = await prisma.leave_policy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Leave_policyUpdateArgs>(args: SelectSubset<T, Leave_policyUpdateArgs<ExtArgs>>): Prisma__Leave_policyClient<$Result.GetResult<Prisma.$Leave_policyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leave_policies.
     * @param {Leave_policyDeleteManyArgs} args - Arguments to filter Leave_policies to delete.
     * @example
     * // Delete a few Leave_policies
     * const { count } = await prisma.leave_policy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Leave_policyDeleteManyArgs>(args?: SelectSubset<T, Leave_policyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leave_policies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Leave_policyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leave_policies
     * const leave_policy = await prisma.leave_policy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Leave_policyUpdateManyArgs>(args: SelectSubset<T, Leave_policyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leave_policies and returns the data updated in the database.
     * @param {Leave_policyUpdateManyAndReturnArgs} args - Arguments to update many Leave_policies.
     * @example
     * // Update many Leave_policies
     * const leave_policy = await prisma.leave_policy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Leave_policies and only return the `defaultBalance`
     * const leave_policyWithDefaultBalanceOnly = await prisma.leave_policy.updateManyAndReturn({
     *   select: { defaultBalance: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Leave_policyUpdateManyAndReturnArgs>(args: SelectSubset<T, Leave_policyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Leave_policyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Leave_policy.
     * @param {Leave_policyUpsertArgs} args - Arguments to update or create a Leave_policy.
     * @example
     * // Update or create a Leave_policy
     * const leave_policy = await prisma.leave_policy.upsert({
     *   create: {
     *     // ... data to create a Leave_policy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Leave_policy we want to update
     *   }
     * })
     */
    upsert<T extends Leave_policyUpsertArgs>(args: SelectSubset<T, Leave_policyUpsertArgs<ExtArgs>>): Prisma__Leave_policyClient<$Result.GetResult<Prisma.$Leave_policyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leave_policies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Leave_policyCountArgs} args - Arguments to filter Leave_policies to count.
     * @example
     * // Count the number of Leave_policies
     * const count = await prisma.leave_policy.count({
     *   where: {
     *     // ... the filter for the Leave_policies we want to count
     *   }
     * })
    **/
    count<T extends Leave_policyCountArgs>(
      args?: Subset<T, Leave_policyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Leave_policyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Leave_policy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Leave_policyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Leave_policyAggregateArgs>(args: Subset<T, Leave_policyAggregateArgs>): Prisma.PrismaPromise<GetLeave_policyAggregateType<T>>

    /**
     * Group by Leave_policy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Leave_policyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Leave_policyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Leave_policyGroupByArgs['orderBy'] }
        : { orderBy?: Leave_policyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Leave_policyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeave_policyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Leave_policy model
   */
  readonly fields: Leave_policyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Leave_policy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Leave_policyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Leave_policy model
   */
  interface Leave_policyFieldRefs {
    readonly leaveType: FieldRef<"Leave_policy", 'LeaveType'>
    readonly defaultBalance: FieldRef<"Leave_policy", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Leave_policy findUnique
   */
  export type Leave_policyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_policy
     */
    select?: Leave_policySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_policy
     */
    omit?: Leave_policyOmit<ExtArgs> | null
    /**
     * Filter, which Leave_policy to fetch.
     */
    where: Leave_policyWhereUniqueInput
  }

  /**
   * Leave_policy findUniqueOrThrow
   */
  export type Leave_policyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_policy
     */
    select?: Leave_policySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_policy
     */
    omit?: Leave_policyOmit<ExtArgs> | null
    /**
     * Filter, which Leave_policy to fetch.
     */
    where: Leave_policyWhereUniqueInput
  }

  /**
   * Leave_policy findFirst
   */
  export type Leave_policyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_policy
     */
    select?: Leave_policySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_policy
     */
    omit?: Leave_policyOmit<ExtArgs> | null
    /**
     * Filter, which Leave_policy to fetch.
     */
    where?: Leave_policyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leave_policies to fetch.
     */
    orderBy?: Leave_policyOrderByWithRelationInput | Leave_policyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leave_policies.
     */
    cursor?: Leave_policyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leave_policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leave_policies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leave_policies.
     */
    distinct?: Leave_policyScalarFieldEnum | Leave_policyScalarFieldEnum[]
  }

  /**
   * Leave_policy findFirstOrThrow
   */
  export type Leave_policyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_policy
     */
    select?: Leave_policySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_policy
     */
    omit?: Leave_policyOmit<ExtArgs> | null
    /**
     * Filter, which Leave_policy to fetch.
     */
    where?: Leave_policyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leave_policies to fetch.
     */
    orderBy?: Leave_policyOrderByWithRelationInput | Leave_policyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leave_policies.
     */
    cursor?: Leave_policyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leave_policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leave_policies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leave_policies.
     */
    distinct?: Leave_policyScalarFieldEnum | Leave_policyScalarFieldEnum[]
  }

  /**
   * Leave_policy findMany
   */
  export type Leave_policyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_policy
     */
    select?: Leave_policySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_policy
     */
    omit?: Leave_policyOmit<ExtArgs> | null
    /**
     * Filter, which Leave_policies to fetch.
     */
    where?: Leave_policyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leave_policies to fetch.
     */
    orderBy?: Leave_policyOrderByWithRelationInput | Leave_policyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leave_policies.
     */
    cursor?: Leave_policyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leave_policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leave_policies.
     */
    skip?: number
    distinct?: Leave_policyScalarFieldEnum | Leave_policyScalarFieldEnum[]
  }

  /**
   * Leave_policy create
   */
  export type Leave_policyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_policy
     */
    select?: Leave_policySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_policy
     */
    omit?: Leave_policyOmit<ExtArgs> | null
    /**
     * The data needed to create a Leave_policy.
     */
    data: XOR<Leave_policyCreateInput, Leave_policyUncheckedCreateInput>
  }

  /**
   * Leave_policy createMany
   */
  export type Leave_policyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leave_policies.
     */
    data: Leave_policyCreateManyInput | Leave_policyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Leave_policy createManyAndReturn
   */
  export type Leave_policyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_policy
     */
    select?: Leave_policySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_policy
     */
    omit?: Leave_policyOmit<ExtArgs> | null
    /**
     * The data used to create many Leave_policies.
     */
    data: Leave_policyCreateManyInput | Leave_policyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Leave_policy update
   */
  export type Leave_policyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_policy
     */
    select?: Leave_policySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_policy
     */
    omit?: Leave_policyOmit<ExtArgs> | null
    /**
     * The data needed to update a Leave_policy.
     */
    data: XOR<Leave_policyUpdateInput, Leave_policyUncheckedUpdateInput>
    /**
     * Choose, which Leave_policy to update.
     */
    where: Leave_policyWhereUniqueInput
  }

  /**
   * Leave_policy updateMany
   */
  export type Leave_policyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leave_policies.
     */
    data: XOR<Leave_policyUpdateManyMutationInput, Leave_policyUncheckedUpdateManyInput>
    /**
     * Filter which Leave_policies to update
     */
    where?: Leave_policyWhereInput
    /**
     * Limit how many Leave_policies to update.
     */
    limit?: number
  }

  /**
   * Leave_policy updateManyAndReturn
   */
  export type Leave_policyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_policy
     */
    select?: Leave_policySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_policy
     */
    omit?: Leave_policyOmit<ExtArgs> | null
    /**
     * The data used to update Leave_policies.
     */
    data: XOR<Leave_policyUpdateManyMutationInput, Leave_policyUncheckedUpdateManyInput>
    /**
     * Filter which Leave_policies to update
     */
    where?: Leave_policyWhereInput
    /**
     * Limit how many Leave_policies to update.
     */
    limit?: number
  }

  /**
   * Leave_policy upsert
   */
  export type Leave_policyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_policy
     */
    select?: Leave_policySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_policy
     */
    omit?: Leave_policyOmit<ExtArgs> | null
    /**
     * The filter to search for the Leave_policy to update in case it exists.
     */
    where: Leave_policyWhereUniqueInput
    /**
     * In case the Leave_policy found by the `where` argument doesn't exist, create a new Leave_policy with this data.
     */
    create: XOR<Leave_policyCreateInput, Leave_policyUncheckedCreateInput>
    /**
     * In case the Leave_policy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Leave_policyUpdateInput, Leave_policyUncheckedUpdateInput>
  }

  /**
   * Leave_policy delete
   */
  export type Leave_policyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_policy
     */
    select?: Leave_policySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_policy
     */
    omit?: Leave_policyOmit<ExtArgs> | null
    /**
     * Filter which Leave_policy to delete.
     */
    where: Leave_policyWhereUniqueInput
  }

  /**
   * Leave_policy deleteMany
   */
  export type Leave_policyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leave_policies to delete
     */
    where?: Leave_policyWhereInput
    /**
     * Limit how many Leave_policies to delete.
     */
    limit?: number
  }

  /**
   * Leave_policy without action
   */
  export type Leave_policyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave_policy
     */
    select?: Leave_policySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave_policy
     */
    omit?: Leave_policyOmit<ExtArgs> | null
  }


  /**
   * Model SyncHistory
   */

  export type AggregateSyncHistory = {
    _count: SyncHistoryCountAggregateOutputType | null
    _avg: SyncHistoryAvgAggregateOutputType | null
    _sum: SyncHistorySumAggregateOutputType | null
    _min: SyncHistoryMinAggregateOutputType | null
    _max: SyncHistoryMaxAggregateOutputType | null
  }

  export type SyncHistoryAvgAggregateOutputType = {
    id: number | null
    totalUsers: number | null
    newUsers: number | null
    updatedUsers: number | null
  }

  export type SyncHistorySumAggregateOutputType = {
    id: number | null
    totalUsers: number | null
    newUsers: number | null
    updatedUsers: number | null
  }

  export type SyncHistoryMinAggregateOutputType = {
    id: number | null
    syncTime: Date | null
    totalUsers: number | null
    newUsers: number | null
    updatedUsers: number | null
    status: string | null
  }

  export type SyncHistoryMaxAggregateOutputType = {
    id: number | null
    syncTime: Date | null
    totalUsers: number | null
    newUsers: number | null
    updatedUsers: number | null
    status: string | null
  }

  export type SyncHistoryCountAggregateOutputType = {
    id: number
    syncTime: number
    totalUsers: number
    newUsers: number
    updatedUsers: number
    status: number
    _all: number
  }


  export type SyncHistoryAvgAggregateInputType = {
    id?: true
    totalUsers?: true
    newUsers?: true
    updatedUsers?: true
  }

  export type SyncHistorySumAggregateInputType = {
    id?: true
    totalUsers?: true
    newUsers?: true
    updatedUsers?: true
  }

  export type SyncHistoryMinAggregateInputType = {
    id?: true
    syncTime?: true
    totalUsers?: true
    newUsers?: true
    updatedUsers?: true
    status?: true
  }

  export type SyncHistoryMaxAggregateInputType = {
    id?: true
    syncTime?: true
    totalUsers?: true
    newUsers?: true
    updatedUsers?: true
    status?: true
  }

  export type SyncHistoryCountAggregateInputType = {
    id?: true
    syncTime?: true
    totalUsers?: true
    newUsers?: true
    updatedUsers?: true
    status?: true
    _all?: true
  }

  export type SyncHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncHistory to aggregate.
     */
    where?: SyncHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncHistories to fetch.
     */
    orderBy?: SyncHistoryOrderByWithRelationInput | SyncHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyncHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SyncHistories
    **/
    _count?: true | SyncHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SyncHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SyncHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyncHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyncHistoryMaxAggregateInputType
  }

  export type GetSyncHistoryAggregateType<T extends SyncHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSyncHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyncHistory[P]>
      : GetScalarType<T[P], AggregateSyncHistory[P]>
  }




  export type SyncHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyncHistoryWhereInput
    orderBy?: SyncHistoryOrderByWithAggregationInput | SyncHistoryOrderByWithAggregationInput[]
    by: SyncHistoryScalarFieldEnum[] | SyncHistoryScalarFieldEnum
    having?: SyncHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyncHistoryCountAggregateInputType | true
    _avg?: SyncHistoryAvgAggregateInputType
    _sum?: SyncHistorySumAggregateInputType
    _min?: SyncHistoryMinAggregateInputType
    _max?: SyncHistoryMaxAggregateInputType
  }

  export type SyncHistoryGroupByOutputType = {
    id: number
    syncTime: Date
    totalUsers: number
    newUsers: number
    updatedUsers: number
    status: string
    _count: SyncHistoryCountAggregateOutputType | null
    _avg: SyncHistoryAvgAggregateOutputType | null
    _sum: SyncHistorySumAggregateOutputType | null
    _min: SyncHistoryMinAggregateOutputType | null
    _max: SyncHistoryMaxAggregateOutputType | null
  }

  type GetSyncHistoryGroupByPayload<T extends SyncHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyncHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyncHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyncHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], SyncHistoryGroupByOutputType[P]>
        }
      >
    >


  export type SyncHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    syncTime?: boolean
    totalUsers?: boolean
    newUsers?: boolean
    updatedUsers?: boolean
    status?: boolean
  }, ExtArgs["result"]["syncHistory"]>

  export type SyncHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    syncTime?: boolean
    totalUsers?: boolean
    newUsers?: boolean
    updatedUsers?: boolean
    status?: boolean
  }, ExtArgs["result"]["syncHistory"]>

  export type SyncHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    syncTime?: boolean
    totalUsers?: boolean
    newUsers?: boolean
    updatedUsers?: boolean
    status?: boolean
  }, ExtArgs["result"]["syncHistory"]>

  export type SyncHistorySelectScalar = {
    id?: boolean
    syncTime?: boolean
    totalUsers?: boolean
    newUsers?: boolean
    updatedUsers?: boolean
    status?: boolean
  }

  export type SyncHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "syncTime" | "totalUsers" | "newUsers" | "updatedUsers" | "status", ExtArgs["result"]["syncHistory"]>

  export type $SyncHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SyncHistory"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      syncTime: Date
      totalUsers: number
      newUsers: number
      updatedUsers: number
      status: string
    }, ExtArgs["result"]["syncHistory"]>
    composites: {}
  }

  type SyncHistoryGetPayload<S extends boolean | null | undefined | SyncHistoryDefaultArgs> = $Result.GetResult<Prisma.$SyncHistoryPayload, S>

  type SyncHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SyncHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SyncHistoryCountAggregateInputType | true
    }

  export interface SyncHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SyncHistory'], meta: { name: 'SyncHistory' } }
    /**
     * Find zero or one SyncHistory that matches the filter.
     * @param {SyncHistoryFindUniqueArgs} args - Arguments to find a SyncHistory
     * @example
     * // Get one SyncHistory
     * const syncHistory = await prisma.syncHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SyncHistoryFindUniqueArgs>(args: SelectSubset<T, SyncHistoryFindUniqueArgs<ExtArgs>>): Prisma__SyncHistoryClient<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SyncHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SyncHistoryFindUniqueOrThrowArgs} args - Arguments to find a SyncHistory
     * @example
     * // Get one SyncHistory
     * const syncHistory = await prisma.syncHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SyncHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, SyncHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SyncHistoryClient<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyncHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncHistoryFindFirstArgs} args - Arguments to find a SyncHistory
     * @example
     * // Get one SyncHistory
     * const syncHistory = await prisma.syncHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SyncHistoryFindFirstArgs>(args?: SelectSubset<T, SyncHistoryFindFirstArgs<ExtArgs>>): Prisma__SyncHistoryClient<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyncHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncHistoryFindFirstOrThrowArgs} args - Arguments to find a SyncHistory
     * @example
     * // Get one SyncHistory
     * const syncHistory = await prisma.syncHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SyncHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, SyncHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SyncHistoryClient<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SyncHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SyncHistories
     * const syncHistories = await prisma.syncHistory.findMany()
     * 
     * // Get first 10 SyncHistories
     * const syncHistories = await prisma.syncHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syncHistoryWithIdOnly = await prisma.syncHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SyncHistoryFindManyArgs>(args?: SelectSubset<T, SyncHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SyncHistory.
     * @param {SyncHistoryCreateArgs} args - Arguments to create a SyncHistory.
     * @example
     * // Create one SyncHistory
     * const SyncHistory = await prisma.syncHistory.create({
     *   data: {
     *     // ... data to create a SyncHistory
     *   }
     * })
     * 
     */
    create<T extends SyncHistoryCreateArgs>(args: SelectSubset<T, SyncHistoryCreateArgs<ExtArgs>>): Prisma__SyncHistoryClient<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SyncHistories.
     * @param {SyncHistoryCreateManyArgs} args - Arguments to create many SyncHistories.
     * @example
     * // Create many SyncHistories
     * const syncHistory = await prisma.syncHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SyncHistoryCreateManyArgs>(args?: SelectSubset<T, SyncHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SyncHistories and returns the data saved in the database.
     * @param {SyncHistoryCreateManyAndReturnArgs} args - Arguments to create many SyncHistories.
     * @example
     * // Create many SyncHistories
     * const syncHistory = await prisma.syncHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SyncHistories and only return the `id`
     * const syncHistoryWithIdOnly = await prisma.syncHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SyncHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, SyncHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SyncHistory.
     * @param {SyncHistoryDeleteArgs} args - Arguments to delete one SyncHistory.
     * @example
     * // Delete one SyncHistory
     * const SyncHistory = await prisma.syncHistory.delete({
     *   where: {
     *     // ... filter to delete one SyncHistory
     *   }
     * })
     * 
     */
    delete<T extends SyncHistoryDeleteArgs>(args: SelectSubset<T, SyncHistoryDeleteArgs<ExtArgs>>): Prisma__SyncHistoryClient<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SyncHistory.
     * @param {SyncHistoryUpdateArgs} args - Arguments to update one SyncHistory.
     * @example
     * // Update one SyncHistory
     * const syncHistory = await prisma.syncHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SyncHistoryUpdateArgs>(args: SelectSubset<T, SyncHistoryUpdateArgs<ExtArgs>>): Prisma__SyncHistoryClient<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SyncHistories.
     * @param {SyncHistoryDeleteManyArgs} args - Arguments to filter SyncHistories to delete.
     * @example
     * // Delete a few SyncHistories
     * const { count } = await prisma.syncHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SyncHistoryDeleteManyArgs>(args?: SelectSubset<T, SyncHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SyncHistories
     * const syncHistory = await prisma.syncHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SyncHistoryUpdateManyArgs>(args: SelectSubset<T, SyncHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncHistories and returns the data updated in the database.
     * @param {SyncHistoryUpdateManyAndReturnArgs} args - Arguments to update many SyncHistories.
     * @example
     * // Update many SyncHistories
     * const syncHistory = await prisma.syncHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SyncHistories and only return the `id`
     * const syncHistoryWithIdOnly = await prisma.syncHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SyncHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, SyncHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SyncHistory.
     * @param {SyncHistoryUpsertArgs} args - Arguments to update or create a SyncHistory.
     * @example
     * // Update or create a SyncHistory
     * const syncHistory = await prisma.syncHistory.upsert({
     *   create: {
     *     // ... data to create a SyncHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SyncHistory we want to update
     *   }
     * })
     */
    upsert<T extends SyncHistoryUpsertArgs>(args: SelectSubset<T, SyncHistoryUpsertArgs<ExtArgs>>): Prisma__SyncHistoryClient<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SyncHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncHistoryCountArgs} args - Arguments to filter SyncHistories to count.
     * @example
     * // Count the number of SyncHistories
     * const count = await prisma.syncHistory.count({
     *   where: {
     *     // ... the filter for the SyncHistories we want to count
     *   }
     * })
    **/
    count<T extends SyncHistoryCountArgs>(
      args?: Subset<T, SyncHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyncHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SyncHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyncHistoryAggregateArgs>(args: Subset<T, SyncHistoryAggregateArgs>): Prisma.PrismaPromise<GetSyncHistoryAggregateType<T>>

    /**
     * Group by SyncHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyncHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyncHistoryGroupByArgs['orderBy'] }
        : { orderBy?: SyncHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyncHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyncHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SyncHistory model
   */
  readonly fields: SyncHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SyncHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyncHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SyncHistory model
   */
  interface SyncHistoryFieldRefs {
    readonly id: FieldRef<"SyncHistory", 'Int'>
    readonly syncTime: FieldRef<"SyncHistory", 'DateTime'>
    readonly totalUsers: FieldRef<"SyncHistory", 'Int'>
    readonly newUsers: FieldRef<"SyncHistory", 'Int'>
    readonly updatedUsers: FieldRef<"SyncHistory", 'Int'>
    readonly status: FieldRef<"SyncHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SyncHistory findUnique
   */
  export type SyncHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * Filter, which SyncHistory to fetch.
     */
    where: SyncHistoryWhereUniqueInput
  }

  /**
   * SyncHistory findUniqueOrThrow
   */
  export type SyncHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * Filter, which SyncHistory to fetch.
     */
    where: SyncHistoryWhereUniqueInput
  }

  /**
   * SyncHistory findFirst
   */
  export type SyncHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * Filter, which SyncHistory to fetch.
     */
    where?: SyncHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncHistories to fetch.
     */
    orderBy?: SyncHistoryOrderByWithRelationInput | SyncHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncHistories.
     */
    cursor?: SyncHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncHistories.
     */
    distinct?: SyncHistoryScalarFieldEnum | SyncHistoryScalarFieldEnum[]
  }

  /**
   * SyncHistory findFirstOrThrow
   */
  export type SyncHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * Filter, which SyncHistory to fetch.
     */
    where?: SyncHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncHistories to fetch.
     */
    orderBy?: SyncHistoryOrderByWithRelationInput | SyncHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncHistories.
     */
    cursor?: SyncHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncHistories.
     */
    distinct?: SyncHistoryScalarFieldEnum | SyncHistoryScalarFieldEnum[]
  }

  /**
   * SyncHistory findMany
   */
  export type SyncHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * Filter, which SyncHistories to fetch.
     */
    where?: SyncHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncHistories to fetch.
     */
    orderBy?: SyncHistoryOrderByWithRelationInput | SyncHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SyncHistories.
     */
    cursor?: SyncHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncHistories.
     */
    skip?: number
    distinct?: SyncHistoryScalarFieldEnum | SyncHistoryScalarFieldEnum[]
  }

  /**
   * SyncHistory create
   */
  export type SyncHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * The data needed to create a SyncHistory.
     */
    data: XOR<SyncHistoryCreateInput, SyncHistoryUncheckedCreateInput>
  }

  /**
   * SyncHistory createMany
   */
  export type SyncHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SyncHistories.
     */
    data: SyncHistoryCreateManyInput | SyncHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SyncHistory createManyAndReturn
   */
  export type SyncHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many SyncHistories.
     */
    data: SyncHistoryCreateManyInput | SyncHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SyncHistory update
   */
  export type SyncHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * The data needed to update a SyncHistory.
     */
    data: XOR<SyncHistoryUpdateInput, SyncHistoryUncheckedUpdateInput>
    /**
     * Choose, which SyncHistory to update.
     */
    where: SyncHistoryWhereUniqueInput
  }

  /**
   * SyncHistory updateMany
   */
  export type SyncHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SyncHistories.
     */
    data: XOR<SyncHistoryUpdateManyMutationInput, SyncHistoryUncheckedUpdateManyInput>
    /**
     * Filter which SyncHistories to update
     */
    where?: SyncHistoryWhereInput
    /**
     * Limit how many SyncHistories to update.
     */
    limit?: number
  }

  /**
   * SyncHistory updateManyAndReturn
   */
  export type SyncHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * The data used to update SyncHistories.
     */
    data: XOR<SyncHistoryUpdateManyMutationInput, SyncHistoryUncheckedUpdateManyInput>
    /**
     * Filter which SyncHistories to update
     */
    where?: SyncHistoryWhereInput
    /**
     * Limit how many SyncHistories to update.
     */
    limit?: number
  }

  /**
   * SyncHistory upsert
   */
  export type SyncHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * The filter to search for the SyncHistory to update in case it exists.
     */
    where: SyncHistoryWhereUniqueInput
    /**
     * In case the SyncHistory found by the `where` argument doesn't exist, create a new SyncHistory with this data.
     */
    create: XOR<SyncHistoryCreateInput, SyncHistoryUncheckedCreateInput>
    /**
     * In case the SyncHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyncHistoryUpdateInput, SyncHistoryUncheckedUpdateInput>
  }

  /**
   * SyncHistory delete
   */
  export type SyncHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * Filter which SyncHistory to delete.
     */
    where: SyncHistoryWhereUniqueInput
  }

  /**
   * SyncHistory deleteMany
   */
  export type SyncHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncHistories to delete
     */
    where?: SyncHistoryWhereInput
    /**
     * Limit how many SyncHistories to delete.
     */
    limit?: number
  }

  /**
   * SyncHistory without action
   */
  export type SyncHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
  }


  /**
   * Model Punch
   */

  export type AggregatePunch = {
    _count: PunchCountAggregateOutputType | null
    _avg: PunchAvgAggregateOutputType | null
    _sum: PunchSumAggregateOutputType | null
    _min: PunchMinAggregateOutputType | null
    _max: PunchMaxAggregateOutputType | null
  }

  export type PunchAvgAggregateOutputType = {
    id: number | null
  }

  export type PunchSumAggregateOutputType = {
    id: number | null
  }

  export type PunchMinAggregateOutputType = {
    id: number | null
    employeeId: string | null
    eventTime: Date | null
    correctEventTime: Date | null
    direction: $Enums.Direction | null
    source: $Enums.Source | null
    note: string | null
    createdBy: string | null
    createdAt: Date | null
    deletedAt: Date | null
    directionCorrected: boolean | null
    originalDirection: $Enums.Direction | null
    correctedBy: string | null
    correctionNote: string | null
    correctedAt: Date | null
  }

  export type PunchMaxAggregateOutputType = {
    id: number | null
    employeeId: string | null
    eventTime: Date | null
    correctEventTime: Date | null
    direction: $Enums.Direction | null
    source: $Enums.Source | null
    note: string | null
    createdBy: string | null
    createdAt: Date | null
    deletedAt: Date | null
    directionCorrected: boolean | null
    originalDirection: $Enums.Direction | null
    correctedBy: string | null
    correctionNote: string | null
    correctedAt: Date | null
  }

  export type PunchCountAggregateOutputType = {
    id: number
    employeeId: number
    eventTime: number
    correctEventTime: number
    direction: number
    source: number
    note: number
    createdBy: number
    createdAt: number
    deletedAt: number
    directionCorrected: number
    originalDirection: number
    correctedBy: number
    correctionNote: number
    correctedAt: number
    _all: number
  }


  export type PunchAvgAggregateInputType = {
    id?: true
  }

  export type PunchSumAggregateInputType = {
    id?: true
  }

  export type PunchMinAggregateInputType = {
    id?: true
    employeeId?: true
    eventTime?: true
    correctEventTime?: true
    direction?: true
    source?: true
    note?: true
    createdBy?: true
    createdAt?: true
    deletedAt?: true
    directionCorrected?: true
    originalDirection?: true
    correctedBy?: true
    correctionNote?: true
    correctedAt?: true
  }

  export type PunchMaxAggregateInputType = {
    id?: true
    employeeId?: true
    eventTime?: true
    correctEventTime?: true
    direction?: true
    source?: true
    note?: true
    createdBy?: true
    createdAt?: true
    deletedAt?: true
    directionCorrected?: true
    originalDirection?: true
    correctedBy?: true
    correctionNote?: true
    correctedAt?: true
  }

  export type PunchCountAggregateInputType = {
    id?: true
    employeeId?: true
    eventTime?: true
    correctEventTime?: true
    direction?: true
    source?: true
    note?: true
    createdBy?: true
    createdAt?: true
    deletedAt?: true
    directionCorrected?: true
    originalDirection?: true
    correctedBy?: true
    correctionNote?: true
    correctedAt?: true
    _all?: true
  }

  export type PunchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Punch to aggregate.
     */
    where?: PunchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Punches to fetch.
     */
    orderBy?: PunchOrderByWithRelationInput | PunchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PunchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Punches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Punches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Punches
    **/
    _count?: true | PunchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PunchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PunchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PunchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PunchMaxAggregateInputType
  }

  export type GetPunchAggregateType<T extends PunchAggregateArgs> = {
        [P in keyof T & keyof AggregatePunch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePunch[P]>
      : GetScalarType<T[P], AggregatePunch[P]>
  }




  export type PunchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PunchWhereInput
    orderBy?: PunchOrderByWithAggregationInput | PunchOrderByWithAggregationInput[]
    by: PunchScalarFieldEnum[] | PunchScalarFieldEnum
    having?: PunchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PunchCountAggregateInputType | true
    _avg?: PunchAvgAggregateInputType
    _sum?: PunchSumAggregateInputType
    _min?: PunchMinAggregateInputType
    _max?: PunchMaxAggregateInputType
  }

  export type PunchGroupByOutputType = {
    id: number
    employeeId: string
    eventTime: Date
    correctEventTime: Date | null
    direction: $Enums.Direction
    source: $Enums.Source
    note: string | null
    createdBy: string | null
    createdAt: Date
    deletedAt: Date | null
    directionCorrected: boolean
    originalDirection: $Enums.Direction | null
    correctedBy: string | null
    correctionNote: string | null
    correctedAt: Date | null
    _count: PunchCountAggregateOutputType | null
    _avg: PunchAvgAggregateOutputType | null
    _sum: PunchSumAggregateOutputType | null
    _min: PunchMinAggregateOutputType | null
    _max: PunchMaxAggregateOutputType | null
  }

  type GetPunchGroupByPayload<T extends PunchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PunchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PunchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PunchGroupByOutputType[P]>
            : GetScalarType<T[P], PunchGroupByOutputType[P]>
        }
      >
    >


  export type PunchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    eventTime?: boolean
    correctEventTime?: boolean
    direction?: boolean
    source?: boolean
    note?: boolean
    createdBy?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    directionCorrected?: boolean
    originalDirection?: boolean
    correctedBy?: boolean
    correctionNote?: boolean
    correctedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["punch"]>

  export type PunchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    eventTime?: boolean
    correctEventTime?: boolean
    direction?: boolean
    source?: boolean
    note?: boolean
    createdBy?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    directionCorrected?: boolean
    originalDirection?: boolean
    correctedBy?: boolean
    correctionNote?: boolean
    correctedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["punch"]>

  export type PunchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    eventTime?: boolean
    correctEventTime?: boolean
    direction?: boolean
    source?: boolean
    note?: boolean
    createdBy?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    directionCorrected?: boolean
    originalDirection?: boolean
    correctedBy?: boolean
    correctionNote?: boolean
    correctedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["punch"]>

  export type PunchSelectScalar = {
    id?: boolean
    employeeId?: boolean
    eventTime?: boolean
    correctEventTime?: boolean
    direction?: boolean
    source?: boolean
    note?: boolean
    createdBy?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    directionCorrected?: boolean
    originalDirection?: boolean
    correctedBy?: boolean
    correctionNote?: boolean
    correctedAt?: boolean
  }

  export type PunchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "eventTime" | "correctEventTime" | "direction" | "source" | "note" | "createdBy" | "createdAt" | "deletedAt" | "directionCorrected" | "originalDirection" | "correctedBy" | "correctionNote" | "correctedAt", ExtArgs["result"]["punch"]>
  export type PunchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PunchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PunchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PunchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Punch"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: string
      eventTime: Date
      correctEventTime: Date | null
      direction: $Enums.Direction
      source: $Enums.Source
      note: string | null
      createdBy: string | null
      createdAt: Date
      deletedAt: Date | null
      directionCorrected: boolean
      originalDirection: $Enums.Direction | null
      correctedBy: string | null
      correctionNote: string | null
      correctedAt: Date | null
    }, ExtArgs["result"]["punch"]>
    composites: {}
  }

  type PunchGetPayload<S extends boolean | null | undefined | PunchDefaultArgs> = $Result.GetResult<Prisma.$PunchPayload, S>

  type PunchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PunchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PunchCountAggregateInputType | true
    }

  export interface PunchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Punch'], meta: { name: 'Punch' } }
    /**
     * Find zero or one Punch that matches the filter.
     * @param {PunchFindUniqueArgs} args - Arguments to find a Punch
     * @example
     * // Get one Punch
     * const punch = await prisma.punch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PunchFindUniqueArgs>(args: SelectSubset<T, PunchFindUniqueArgs<ExtArgs>>): Prisma__PunchClient<$Result.GetResult<Prisma.$PunchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Punch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PunchFindUniqueOrThrowArgs} args - Arguments to find a Punch
     * @example
     * // Get one Punch
     * const punch = await prisma.punch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PunchFindUniqueOrThrowArgs>(args: SelectSubset<T, PunchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PunchClient<$Result.GetResult<Prisma.$PunchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Punch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PunchFindFirstArgs} args - Arguments to find a Punch
     * @example
     * // Get one Punch
     * const punch = await prisma.punch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PunchFindFirstArgs>(args?: SelectSubset<T, PunchFindFirstArgs<ExtArgs>>): Prisma__PunchClient<$Result.GetResult<Prisma.$PunchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Punch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PunchFindFirstOrThrowArgs} args - Arguments to find a Punch
     * @example
     * // Get one Punch
     * const punch = await prisma.punch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PunchFindFirstOrThrowArgs>(args?: SelectSubset<T, PunchFindFirstOrThrowArgs<ExtArgs>>): Prisma__PunchClient<$Result.GetResult<Prisma.$PunchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Punches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PunchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Punches
     * const punches = await prisma.punch.findMany()
     * 
     * // Get first 10 Punches
     * const punches = await prisma.punch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const punchWithIdOnly = await prisma.punch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PunchFindManyArgs>(args?: SelectSubset<T, PunchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PunchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Punch.
     * @param {PunchCreateArgs} args - Arguments to create a Punch.
     * @example
     * // Create one Punch
     * const Punch = await prisma.punch.create({
     *   data: {
     *     // ... data to create a Punch
     *   }
     * })
     * 
     */
    create<T extends PunchCreateArgs>(args: SelectSubset<T, PunchCreateArgs<ExtArgs>>): Prisma__PunchClient<$Result.GetResult<Prisma.$PunchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Punches.
     * @param {PunchCreateManyArgs} args - Arguments to create many Punches.
     * @example
     * // Create many Punches
     * const punch = await prisma.punch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PunchCreateManyArgs>(args?: SelectSubset<T, PunchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Punches and returns the data saved in the database.
     * @param {PunchCreateManyAndReturnArgs} args - Arguments to create many Punches.
     * @example
     * // Create many Punches
     * const punch = await prisma.punch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Punches and only return the `id`
     * const punchWithIdOnly = await prisma.punch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PunchCreateManyAndReturnArgs>(args?: SelectSubset<T, PunchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PunchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Punch.
     * @param {PunchDeleteArgs} args - Arguments to delete one Punch.
     * @example
     * // Delete one Punch
     * const Punch = await prisma.punch.delete({
     *   where: {
     *     // ... filter to delete one Punch
     *   }
     * })
     * 
     */
    delete<T extends PunchDeleteArgs>(args: SelectSubset<T, PunchDeleteArgs<ExtArgs>>): Prisma__PunchClient<$Result.GetResult<Prisma.$PunchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Punch.
     * @param {PunchUpdateArgs} args - Arguments to update one Punch.
     * @example
     * // Update one Punch
     * const punch = await prisma.punch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PunchUpdateArgs>(args: SelectSubset<T, PunchUpdateArgs<ExtArgs>>): Prisma__PunchClient<$Result.GetResult<Prisma.$PunchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Punches.
     * @param {PunchDeleteManyArgs} args - Arguments to filter Punches to delete.
     * @example
     * // Delete a few Punches
     * const { count } = await prisma.punch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PunchDeleteManyArgs>(args?: SelectSubset<T, PunchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Punches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PunchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Punches
     * const punch = await prisma.punch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PunchUpdateManyArgs>(args: SelectSubset<T, PunchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Punches and returns the data updated in the database.
     * @param {PunchUpdateManyAndReturnArgs} args - Arguments to update many Punches.
     * @example
     * // Update many Punches
     * const punch = await prisma.punch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Punches and only return the `id`
     * const punchWithIdOnly = await prisma.punch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PunchUpdateManyAndReturnArgs>(args: SelectSubset<T, PunchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PunchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Punch.
     * @param {PunchUpsertArgs} args - Arguments to update or create a Punch.
     * @example
     * // Update or create a Punch
     * const punch = await prisma.punch.upsert({
     *   create: {
     *     // ... data to create a Punch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Punch we want to update
     *   }
     * })
     */
    upsert<T extends PunchUpsertArgs>(args: SelectSubset<T, PunchUpsertArgs<ExtArgs>>): Prisma__PunchClient<$Result.GetResult<Prisma.$PunchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Punches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PunchCountArgs} args - Arguments to filter Punches to count.
     * @example
     * // Count the number of Punches
     * const count = await prisma.punch.count({
     *   where: {
     *     // ... the filter for the Punches we want to count
     *   }
     * })
    **/
    count<T extends PunchCountArgs>(
      args?: Subset<T, PunchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PunchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Punch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PunchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PunchAggregateArgs>(args: Subset<T, PunchAggregateArgs>): Prisma.PrismaPromise<GetPunchAggregateType<T>>

    /**
     * Group by Punch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PunchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PunchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PunchGroupByArgs['orderBy'] }
        : { orderBy?: PunchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PunchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPunchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Punch model
   */
  readonly fields: PunchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Punch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PunchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Punch model
   */
  interface PunchFieldRefs {
    readonly id: FieldRef<"Punch", 'Int'>
    readonly employeeId: FieldRef<"Punch", 'String'>
    readonly eventTime: FieldRef<"Punch", 'DateTime'>
    readonly correctEventTime: FieldRef<"Punch", 'DateTime'>
    readonly direction: FieldRef<"Punch", 'Direction'>
    readonly source: FieldRef<"Punch", 'Source'>
    readonly note: FieldRef<"Punch", 'String'>
    readonly createdBy: FieldRef<"Punch", 'String'>
    readonly createdAt: FieldRef<"Punch", 'DateTime'>
    readonly deletedAt: FieldRef<"Punch", 'DateTime'>
    readonly directionCorrected: FieldRef<"Punch", 'Boolean'>
    readonly originalDirection: FieldRef<"Punch", 'Direction'>
    readonly correctedBy: FieldRef<"Punch", 'String'>
    readonly correctionNote: FieldRef<"Punch", 'String'>
    readonly correctedAt: FieldRef<"Punch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Punch findUnique
   */
  export type PunchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Punch
     */
    select?: PunchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Punch
     */
    omit?: PunchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PunchInclude<ExtArgs> | null
    /**
     * Filter, which Punch to fetch.
     */
    where: PunchWhereUniqueInput
  }

  /**
   * Punch findUniqueOrThrow
   */
  export type PunchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Punch
     */
    select?: PunchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Punch
     */
    omit?: PunchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PunchInclude<ExtArgs> | null
    /**
     * Filter, which Punch to fetch.
     */
    where: PunchWhereUniqueInput
  }

  /**
   * Punch findFirst
   */
  export type PunchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Punch
     */
    select?: PunchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Punch
     */
    omit?: PunchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PunchInclude<ExtArgs> | null
    /**
     * Filter, which Punch to fetch.
     */
    where?: PunchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Punches to fetch.
     */
    orderBy?: PunchOrderByWithRelationInput | PunchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Punches.
     */
    cursor?: PunchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Punches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Punches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Punches.
     */
    distinct?: PunchScalarFieldEnum | PunchScalarFieldEnum[]
  }

  /**
   * Punch findFirstOrThrow
   */
  export type PunchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Punch
     */
    select?: PunchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Punch
     */
    omit?: PunchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PunchInclude<ExtArgs> | null
    /**
     * Filter, which Punch to fetch.
     */
    where?: PunchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Punches to fetch.
     */
    orderBy?: PunchOrderByWithRelationInput | PunchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Punches.
     */
    cursor?: PunchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Punches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Punches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Punches.
     */
    distinct?: PunchScalarFieldEnum | PunchScalarFieldEnum[]
  }

  /**
   * Punch findMany
   */
  export type PunchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Punch
     */
    select?: PunchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Punch
     */
    omit?: PunchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PunchInclude<ExtArgs> | null
    /**
     * Filter, which Punches to fetch.
     */
    where?: PunchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Punches to fetch.
     */
    orderBy?: PunchOrderByWithRelationInput | PunchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Punches.
     */
    cursor?: PunchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Punches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Punches.
     */
    skip?: number
    distinct?: PunchScalarFieldEnum | PunchScalarFieldEnum[]
  }

  /**
   * Punch create
   */
  export type PunchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Punch
     */
    select?: PunchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Punch
     */
    omit?: PunchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PunchInclude<ExtArgs> | null
    /**
     * The data needed to create a Punch.
     */
    data: XOR<PunchCreateInput, PunchUncheckedCreateInput>
  }

  /**
   * Punch createMany
   */
  export type PunchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Punches.
     */
    data: PunchCreateManyInput | PunchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Punch createManyAndReturn
   */
  export type PunchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Punch
     */
    select?: PunchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Punch
     */
    omit?: PunchOmit<ExtArgs> | null
    /**
     * The data used to create many Punches.
     */
    data: PunchCreateManyInput | PunchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PunchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Punch update
   */
  export type PunchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Punch
     */
    select?: PunchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Punch
     */
    omit?: PunchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PunchInclude<ExtArgs> | null
    /**
     * The data needed to update a Punch.
     */
    data: XOR<PunchUpdateInput, PunchUncheckedUpdateInput>
    /**
     * Choose, which Punch to update.
     */
    where: PunchWhereUniqueInput
  }

  /**
   * Punch updateMany
   */
  export type PunchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Punches.
     */
    data: XOR<PunchUpdateManyMutationInput, PunchUncheckedUpdateManyInput>
    /**
     * Filter which Punches to update
     */
    where?: PunchWhereInput
    /**
     * Limit how many Punches to update.
     */
    limit?: number
  }

  /**
   * Punch updateManyAndReturn
   */
  export type PunchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Punch
     */
    select?: PunchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Punch
     */
    omit?: PunchOmit<ExtArgs> | null
    /**
     * The data used to update Punches.
     */
    data: XOR<PunchUpdateManyMutationInput, PunchUncheckedUpdateManyInput>
    /**
     * Filter which Punches to update
     */
    where?: PunchWhereInput
    /**
     * Limit how many Punches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PunchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Punch upsert
   */
  export type PunchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Punch
     */
    select?: PunchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Punch
     */
    omit?: PunchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PunchInclude<ExtArgs> | null
    /**
     * The filter to search for the Punch to update in case it exists.
     */
    where: PunchWhereUniqueInput
    /**
     * In case the Punch found by the `where` argument doesn't exist, create a new Punch with this data.
     */
    create: XOR<PunchCreateInput, PunchUncheckedCreateInput>
    /**
     * In case the Punch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PunchUpdateInput, PunchUncheckedUpdateInput>
  }

  /**
   * Punch delete
   */
  export type PunchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Punch
     */
    select?: PunchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Punch
     */
    omit?: PunchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PunchInclude<ExtArgs> | null
    /**
     * Filter which Punch to delete.
     */
    where: PunchWhereUniqueInput
  }

  /**
   * Punch deleteMany
   */
  export type PunchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Punches to delete
     */
    where?: PunchWhereInput
    /**
     * Limit how many Punches to delete.
     */
    limit?: number
  }

  /**
   * Punch without action
   */
  export type PunchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Punch
     */
    select?: PunchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Punch
     */
    omit?: PunchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PunchInclude<ExtArgs> | null
  }


  /**
   * Model AttendanceDay
   */

  export type AggregateAttendanceDay = {
    _count: AttendanceDayCountAggregateOutputType | null
    _avg: AttendanceDayAvgAggregateOutputType | null
    _sum: AttendanceDaySumAggregateOutputType | null
    _min: AttendanceDayMinAggregateOutputType | null
    _max: AttendanceDayMaxAggregateOutputType | null
  }

  export type AttendanceDayAvgAggregateOutputType = {
    workedSeconds: number | null
    notWorkingSeconds: number | null
    overtimeSeconds: number | null
  }

  export type AttendanceDaySumAggregateOutputType = {
    workedSeconds: number | null
    notWorkingSeconds: number | null
    overtimeSeconds: number | null
  }

  export type AttendanceDayMinAggregateOutputType = {
    employeeId: string | null
    workDate: Date | null
    startTime: string | null
    firstIn: string | null
    lastOut: string | null
    workedSeconds: number | null
    notWorkingSeconds: number | null
    overtimeSeconds: number | null
    hadManual: boolean | null
    status: $Enums.AttendanceStatus | null
    calculatedAt: Date | null
  }

  export type AttendanceDayMaxAggregateOutputType = {
    employeeId: string | null
    workDate: Date | null
    startTime: string | null
    firstIn: string | null
    lastOut: string | null
    workedSeconds: number | null
    notWorkingSeconds: number | null
    overtimeSeconds: number | null
    hadManual: boolean | null
    status: $Enums.AttendanceStatus | null
    calculatedAt: Date | null
  }

  export type AttendanceDayCountAggregateOutputType = {
    employeeId: number
    workDate: number
    startTime: number
    firstIn: number
    lastOut: number
    workedSeconds: number
    notWorkingSeconds: number
    overtimeSeconds: number
    hadManual: number
    status: number
    calculatedAt: number
    _all: number
  }


  export type AttendanceDayAvgAggregateInputType = {
    workedSeconds?: true
    notWorkingSeconds?: true
    overtimeSeconds?: true
  }

  export type AttendanceDaySumAggregateInputType = {
    workedSeconds?: true
    notWorkingSeconds?: true
    overtimeSeconds?: true
  }

  export type AttendanceDayMinAggregateInputType = {
    employeeId?: true
    workDate?: true
    startTime?: true
    firstIn?: true
    lastOut?: true
    workedSeconds?: true
    notWorkingSeconds?: true
    overtimeSeconds?: true
    hadManual?: true
    status?: true
    calculatedAt?: true
  }

  export type AttendanceDayMaxAggregateInputType = {
    employeeId?: true
    workDate?: true
    startTime?: true
    firstIn?: true
    lastOut?: true
    workedSeconds?: true
    notWorkingSeconds?: true
    overtimeSeconds?: true
    hadManual?: true
    status?: true
    calculatedAt?: true
  }

  export type AttendanceDayCountAggregateInputType = {
    employeeId?: true
    workDate?: true
    startTime?: true
    firstIn?: true
    lastOut?: true
    workedSeconds?: true
    notWorkingSeconds?: true
    overtimeSeconds?: true
    hadManual?: true
    status?: true
    calculatedAt?: true
    _all?: true
  }

  export type AttendanceDayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceDay to aggregate.
     */
    where?: AttendanceDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceDays to fetch.
     */
    orderBy?: AttendanceDayOrderByWithRelationInput | AttendanceDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendanceDays
    **/
    _count?: true | AttendanceDayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceDayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceDaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceDayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceDayMaxAggregateInputType
  }

  export type GetAttendanceDayAggregateType<T extends AttendanceDayAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendanceDay]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceDay[P]>
      : GetScalarType<T[P], AggregateAttendanceDay[P]>
  }




  export type AttendanceDayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceDayWhereInput
    orderBy?: AttendanceDayOrderByWithAggregationInput | AttendanceDayOrderByWithAggregationInput[]
    by: AttendanceDayScalarFieldEnum[] | AttendanceDayScalarFieldEnum
    having?: AttendanceDayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceDayCountAggregateInputType | true
    _avg?: AttendanceDayAvgAggregateInputType
    _sum?: AttendanceDaySumAggregateInputType
    _min?: AttendanceDayMinAggregateInputType
    _max?: AttendanceDayMaxAggregateInputType
  }

  export type AttendanceDayGroupByOutputType = {
    employeeId: string
    workDate: Date
    startTime: string | null
    firstIn: string | null
    lastOut: string | null
    workedSeconds: number
    notWorkingSeconds: number
    overtimeSeconds: number
    hadManual: boolean
    status: $Enums.AttendanceStatus
    calculatedAt: Date
    _count: AttendanceDayCountAggregateOutputType | null
    _avg: AttendanceDayAvgAggregateOutputType | null
    _sum: AttendanceDaySumAggregateOutputType | null
    _min: AttendanceDayMinAggregateOutputType | null
    _max: AttendanceDayMaxAggregateOutputType | null
  }

  type GetAttendanceDayGroupByPayload<T extends AttendanceDayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceDayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceDayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceDayGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceDayGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceDaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employeeId?: boolean
    workDate?: boolean
    startTime?: boolean
    firstIn?: boolean
    lastOut?: boolean
    workedSeconds?: boolean
    notWorkingSeconds?: boolean
    overtimeSeconds?: boolean
    hadManual?: boolean
    status?: boolean
    calculatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceDay"]>

  export type AttendanceDaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employeeId?: boolean
    workDate?: boolean
    startTime?: boolean
    firstIn?: boolean
    lastOut?: boolean
    workedSeconds?: boolean
    notWorkingSeconds?: boolean
    overtimeSeconds?: boolean
    hadManual?: boolean
    status?: boolean
    calculatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceDay"]>

  export type AttendanceDaySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employeeId?: boolean
    workDate?: boolean
    startTime?: boolean
    firstIn?: boolean
    lastOut?: boolean
    workedSeconds?: boolean
    notWorkingSeconds?: boolean
    overtimeSeconds?: boolean
    hadManual?: boolean
    status?: boolean
    calculatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceDay"]>

  export type AttendanceDaySelectScalar = {
    employeeId?: boolean
    workDate?: boolean
    startTime?: boolean
    firstIn?: boolean
    lastOut?: boolean
    workedSeconds?: boolean
    notWorkingSeconds?: boolean
    overtimeSeconds?: boolean
    hadManual?: boolean
    status?: boolean
    calculatedAt?: boolean
  }

  export type AttendanceDayOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"employeeId" | "workDate" | "startTime" | "firstIn" | "lastOut" | "workedSeconds" | "notWorkingSeconds" | "overtimeSeconds" | "hadManual" | "status" | "calculatedAt", ExtArgs["result"]["attendanceDay"]>
  export type AttendanceDayInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AttendanceDayIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AttendanceDayIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AttendanceDayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttendanceDay"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      employeeId: string
      workDate: Date
      startTime: string | null
      firstIn: string | null
      lastOut: string | null
      workedSeconds: number
      notWorkingSeconds: number
      overtimeSeconds: number
      hadManual: boolean
      status: $Enums.AttendanceStatus
      calculatedAt: Date
    }, ExtArgs["result"]["attendanceDay"]>
    composites: {}
  }

  type AttendanceDayGetPayload<S extends boolean | null | undefined | AttendanceDayDefaultArgs> = $Result.GetResult<Prisma.$AttendanceDayPayload, S>

  type AttendanceDayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceDayFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceDayCountAggregateInputType | true
    }

  export interface AttendanceDayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendanceDay'], meta: { name: 'AttendanceDay' } }
    /**
     * Find zero or one AttendanceDay that matches the filter.
     * @param {AttendanceDayFindUniqueArgs} args - Arguments to find a AttendanceDay
     * @example
     * // Get one AttendanceDay
     * const attendanceDay = await prisma.attendanceDay.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceDayFindUniqueArgs>(args: SelectSubset<T, AttendanceDayFindUniqueArgs<ExtArgs>>): Prisma__AttendanceDayClient<$Result.GetResult<Prisma.$AttendanceDayPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AttendanceDay that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceDayFindUniqueOrThrowArgs} args - Arguments to find a AttendanceDay
     * @example
     * // Get one AttendanceDay
     * const attendanceDay = await prisma.attendanceDay.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceDayFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceDayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceDayClient<$Result.GetResult<Prisma.$AttendanceDayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceDay that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceDayFindFirstArgs} args - Arguments to find a AttendanceDay
     * @example
     * // Get one AttendanceDay
     * const attendanceDay = await prisma.attendanceDay.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceDayFindFirstArgs>(args?: SelectSubset<T, AttendanceDayFindFirstArgs<ExtArgs>>): Prisma__AttendanceDayClient<$Result.GetResult<Prisma.$AttendanceDayPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceDay that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceDayFindFirstOrThrowArgs} args - Arguments to find a AttendanceDay
     * @example
     * // Get one AttendanceDay
     * const attendanceDay = await prisma.attendanceDay.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceDayFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceDayFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceDayClient<$Result.GetResult<Prisma.$AttendanceDayPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AttendanceDays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceDayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceDays
     * const attendanceDays = await prisma.attendanceDay.findMany()
     * 
     * // Get first 10 AttendanceDays
     * const attendanceDays = await prisma.attendanceDay.findMany({ take: 10 })
     * 
     * // Only select the `employeeId`
     * const attendanceDayWithEmployeeIdOnly = await prisma.attendanceDay.findMany({ select: { employeeId: true } })
     * 
     */
    findMany<T extends AttendanceDayFindManyArgs>(args?: SelectSubset<T, AttendanceDayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceDayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AttendanceDay.
     * @param {AttendanceDayCreateArgs} args - Arguments to create a AttendanceDay.
     * @example
     * // Create one AttendanceDay
     * const AttendanceDay = await prisma.attendanceDay.create({
     *   data: {
     *     // ... data to create a AttendanceDay
     *   }
     * })
     * 
     */
    create<T extends AttendanceDayCreateArgs>(args: SelectSubset<T, AttendanceDayCreateArgs<ExtArgs>>): Prisma__AttendanceDayClient<$Result.GetResult<Prisma.$AttendanceDayPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AttendanceDays.
     * @param {AttendanceDayCreateManyArgs} args - Arguments to create many AttendanceDays.
     * @example
     * // Create many AttendanceDays
     * const attendanceDay = await prisma.attendanceDay.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceDayCreateManyArgs>(args?: SelectSubset<T, AttendanceDayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttendanceDays and returns the data saved in the database.
     * @param {AttendanceDayCreateManyAndReturnArgs} args - Arguments to create many AttendanceDays.
     * @example
     * // Create many AttendanceDays
     * const attendanceDay = await prisma.attendanceDay.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttendanceDays and only return the `employeeId`
     * const attendanceDayWithEmployeeIdOnly = await prisma.attendanceDay.createManyAndReturn({
     *   select: { employeeId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceDayCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceDayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceDayPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AttendanceDay.
     * @param {AttendanceDayDeleteArgs} args - Arguments to delete one AttendanceDay.
     * @example
     * // Delete one AttendanceDay
     * const AttendanceDay = await prisma.attendanceDay.delete({
     *   where: {
     *     // ... filter to delete one AttendanceDay
     *   }
     * })
     * 
     */
    delete<T extends AttendanceDayDeleteArgs>(args: SelectSubset<T, AttendanceDayDeleteArgs<ExtArgs>>): Prisma__AttendanceDayClient<$Result.GetResult<Prisma.$AttendanceDayPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AttendanceDay.
     * @param {AttendanceDayUpdateArgs} args - Arguments to update one AttendanceDay.
     * @example
     * // Update one AttendanceDay
     * const attendanceDay = await prisma.attendanceDay.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceDayUpdateArgs>(args: SelectSubset<T, AttendanceDayUpdateArgs<ExtArgs>>): Prisma__AttendanceDayClient<$Result.GetResult<Prisma.$AttendanceDayPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AttendanceDays.
     * @param {AttendanceDayDeleteManyArgs} args - Arguments to filter AttendanceDays to delete.
     * @example
     * // Delete a few AttendanceDays
     * const { count } = await prisma.attendanceDay.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceDayDeleteManyArgs>(args?: SelectSubset<T, AttendanceDayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceDayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceDays
     * const attendanceDay = await prisma.attendanceDay.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceDayUpdateManyArgs>(args: SelectSubset<T, AttendanceDayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceDays and returns the data updated in the database.
     * @param {AttendanceDayUpdateManyAndReturnArgs} args - Arguments to update many AttendanceDays.
     * @example
     * // Update many AttendanceDays
     * const attendanceDay = await prisma.attendanceDay.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AttendanceDays and only return the `employeeId`
     * const attendanceDayWithEmployeeIdOnly = await prisma.attendanceDay.updateManyAndReturn({
     *   select: { employeeId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceDayUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceDayUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceDayPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AttendanceDay.
     * @param {AttendanceDayUpsertArgs} args - Arguments to update or create a AttendanceDay.
     * @example
     * // Update or create a AttendanceDay
     * const attendanceDay = await prisma.attendanceDay.upsert({
     *   create: {
     *     // ... data to create a AttendanceDay
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceDay we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceDayUpsertArgs>(args: SelectSubset<T, AttendanceDayUpsertArgs<ExtArgs>>): Prisma__AttendanceDayClient<$Result.GetResult<Prisma.$AttendanceDayPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AttendanceDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceDayCountArgs} args - Arguments to filter AttendanceDays to count.
     * @example
     * // Count the number of AttendanceDays
     * const count = await prisma.attendanceDay.count({
     *   where: {
     *     // ... the filter for the AttendanceDays we want to count
     *   }
     * })
    **/
    count<T extends AttendanceDayCountArgs>(
      args?: Subset<T, AttendanceDayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceDayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendanceDay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceDayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceDayAggregateArgs>(args: Subset<T, AttendanceDayAggregateArgs>): Prisma.PrismaPromise<GetAttendanceDayAggregateType<T>>

    /**
     * Group by AttendanceDay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceDayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceDayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceDayGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceDayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceDayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceDayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttendanceDay model
   */
  readonly fields: AttendanceDayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceDay.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceDayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttendanceDay model
   */
  interface AttendanceDayFieldRefs {
    readonly employeeId: FieldRef<"AttendanceDay", 'String'>
    readonly workDate: FieldRef<"AttendanceDay", 'DateTime'>
    readonly startTime: FieldRef<"AttendanceDay", 'String'>
    readonly firstIn: FieldRef<"AttendanceDay", 'String'>
    readonly lastOut: FieldRef<"AttendanceDay", 'String'>
    readonly workedSeconds: FieldRef<"AttendanceDay", 'Int'>
    readonly notWorkingSeconds: FieldRef<"AttendanceDay", 'Int'>
    readonly overtimeSeconds: FieldRef<"AttendanceDay", 'Int'>
    readonly hadManual: FieldRef<"AttendanceDay", 'Boolean'>
    readonly status: FieldRef<"AttendanceDay", 'AttendanceStatus'>
    readonly calculatedAt: FieldRef<"AttendanceDay", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AttendanceDay findUnique
   */
  export type AttendanceDayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDay
     */
    select?: AttendanceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDay
     */
    omit?: AttendanceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDayInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceDay to fetch.
     */
    where: AttendanceDayWhereUniqueInput
  }

  /**
   * AttendanceDay findUniqueOrThrow
   */
  export type AttendanceDayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDay
     */
    select?: AttendanceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDay
     */
    omit?: AttendanceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDayInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceDay to fetch.
     */
    where: AttendanceDayWhereUniqueInput
  }

  /**
   * AttendanceDay findFirst
   */
  export type AttendanceDayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDay
     */
    select?: AttendanceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDay
     */
    omit?: AttendanceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDayInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceDay to fetch.
     */
    where?: AttendanceDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceDays to fetch.
     */
    orderBy?: AttendanceDayOrderByWithRelationInput | AttendanceDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceDays.
     */
    cursor?: AttendanceDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceDays.
     */
    distinct?: AttendanceDayScalarFieldEnum | AttendanceDayScalarFieldEnum[]
  }

  /**
   * AttendanceDay findFirstOrThrow
   */
  export type AttendanceDayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDay
     */
    select?: AttendanceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDay
     */
    omit?: AttendanceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDayInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceDay to fetch.
     */
    where?: AttendanceDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceDays to fetch.
     */
    orderBy?: AttendanceDayOrderByWithRelationInput | AttendanceDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceDays.
     */
    cursor?: AttendanceDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceDays.
     */
    distinct?: AttendanceDayScalarFieldEnum | AttendanceDayScalarFieldEnum[]
  }

  /**
   * AttendanceDay findMany
   */
  export type AttendanceDayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDay
     */
    select?: AttendanceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDay
     */
    omit?: AttendanceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDayInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceDays to fetch.
     */
    where?: AttendanceDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceDays to fetch.
     */
    orderBy?: AttendanceDayOrderByWithRelationInput | AttendanceDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendanceDays.
     */
    cursor?: AttendanceDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceDays.
     */
    skip?: number
    distinct?: AttendanceDayScalarFieldEnum | AttendanceDayScalarFieldEnum[]
  }

  /**
   * AttendanceDay create
   */
  export type AttendanceDayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDay
     */
    select?: AttendanceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDay
     */
    omit?: AttendanceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDayInclude<ExtArgs> | null
    /**
     * The data needed to create a AttendanceDay.
     */
    data: XOR<AttendanceDayCreateInput, AttendanceDayUncheckedCreateInput>
  }

  /**
   * AttendanceDay createMany
   */
  export type AttendanceDayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendanceDays.
     */
    data: AttendanceDayCreateManyInput | AttendanceDayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttendanceDay createManyAndReturn
   */
  export type AttendanceDayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDay
     */
    select?: AttendanceDaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDay
     */
    omit?: AttendanceDayOmit<ExtArgs> | null
    /**
     * The data used to create many AttendanceDays.
     */
    data: AttendanceDayCreateManyInput | AttendanceDayCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDayIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceDay update
   */
  export type AttendanceDayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDay
     */
    select?: AttendanceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDay
     */
    omit?: AttendanceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDayInclude<ExtArgs> | null
    /**
     * The data needed to update a AttendanceDay.
     */
    data: XOR<AttendanceDayUpdateInput, AttendanceDayUncheckedUpdateInput>
    /**
     * Choose, which AttendanceDay to update.
     */
    where: AttendanceDayWhereUniqueInput
  }

  /**
   * AttendanceDay updateMany
   */
  export type AttendanceDayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendanceDays.
     */
    data: XOR<AttendanceDayUpdateManyMutationInput, AttendanceDayUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceDays to update
     */
    where?: AttendanceDayWhereInput
    /**
     * Limit how many AttendanceDays to update.
     */
    limit?: number
  }

  /**
   * AttendanceDay updateManyAndReturn
   */
  export type AttendanceDayUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDay
     */
    select?: AttendanceDaySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDay
     */
    omit?: AttendanceDayOmit<ExtArgs> | null
    /**
     * The data used to update AttendanceDays.
     */
    data: XOR<AttendanceDayUpdateManyMutationInput, AttendanceDayUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceDays to update
     */
    where?: AttendanceDayWhereInput
    /**
     * Limit how many AttendanceDays to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDayIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceDay upsert
   */
  export type AttendanceDayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDay
     */
    select?: AttendanceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDay
     */
    omit?: AttendanceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDayInclude<ExtArgs> | null
    /**
     * The filter to search for the AttendanceDay to update in case it exists.
     */
    where: AttendanceDayWhereUniqueInput
    /**
     * In case the AttendanceDay found by the `where` argument doesn't exist, create a new AttendanceDay with this data.
     */
    create: XOR<AttendanceDayCreateInput, AttendanceDayUncheckedCreateInput>
    /**
     * In case the AttendanceDay was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceDayUpdateInput, AttendanceDayUncheckedUpdateInput>
  }

  /**
   * AttendanceDay delete
   */
  export type AttendanceDayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDay
     */
    select?: AttendanceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDay
     */
    omit?: AttendanceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDayInclude<ExtArgs> | null
    /**
     * Filter which AttendanceDay to delete.
     */
    where: AttendanceDayWhereUniqueInput
  }

  /**
   * AttendanceDay deleteMany
   */
  export type AttendanceDayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceDays to delete
     */
    where?: AttendanceDayWhereInput
    /**
     * Limit how many AttendanceDays to delete.
     */
    limit?: number
  }

  /**
   * AttendanceDay without action
   */
  export type AttendanceDayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDay
     */
    select?: AttendanceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDay
     */
    omit?: AttendanceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDayInclude<ExtArgs> | null
  }


  /**
   * Model DeviceConfig
   */

  export type AggregateDeviceConfig = {
    _count: DeviceConfigCountAggregateOutputType | null
    _avg: DeviceConfigAvgAggregateOutputType | null
    _sum: DeviceConfigSumAggregateOutputType | null
    _min: DeviceConfigMinAggregateOutputType | null
    _max: DeviceConfigMaxAggregateOutputType | null
  }

  export type DeviceConfigAvgAggregateOutputType = {
    id: number | null
    authFailureCount: number | null
  }

  export type DeviceConfigSumAggregateOutputType = {
    id: number | null
    authFailureCount: number | null
  }

  export type DeviceConfigMinAggregateOutputType = {
    id: number | null
    ip: string | null
    username: string | null
    passwordEnc: string | null
    lastEventTime: string | null
    authFailedAt: Date | null
    authFailureCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeviceConfigMaxAggregateOutputType = {
    id: number | null
    ip: string | null
    username: string | null
    passwordEnc: string | null
    lastEventTime: string | null
    authFailedAt: Date | null
    authFailureCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeviceConfigCountAggregateOutputType = {
    id: number
    ip: number
    username: number
    passwordEnc: number
    lastEventTime: number
    authFailedAt: number
    authFailureCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeviceConfigAvgAggregateInputType = {
    id?: true
    authFailureCount?: true
  }

  export type DeviceConfigSumAggregateInputType = {
    id?: true
    authFailureCount?: true
  }

  export type DeviceConfigMinAggregateInputType = {
    id?: true
    ip?: true
    username?: true
    passwordEnc?: true
    lastEventTime?: true
    authFailedAt?: true
    authFailureCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeviceConfigMaxAggregateInputType = {
    id?: true
    ip?: true
    username?: true
    passwordEnc?: true
    lastEventTime?: true
    authFailedAt?: true
    authFailureCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeviceConfigCountAggregateInputType = {
    id?: true
    ip?: true
    username?: true
    passwordEnc?: true
    lastEventTime?: true
    authFailedAt?: true
    authFailureCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeviceConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceConfig to aggregate.
     */
    where?: DeviceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceConfigs to fetch.
     */
    orderBy?: DeviceConfigOrderByWithRelationInput | DeviceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceConfigs
    **/
    _count?: true | DeviceConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceConfigMaxAggregateInputType
  }

  export type GetDeviceConfigAggregateType<T extends DeviceConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceConfig[P]>
      : GetScalarType<T[P], AggregateDeviceConfig[P]>
  }




  export type DeviceConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceConfigWhereInput
    orderBy?: DeviceConfigOrderByWithAggregationInput | DeviceConfigOrderByWithAggregationInput[]
    by: DeviceConfigScalarFieldEnum[] | DeviceConfigScalarFieldEnum
    having?: DeviceConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceConfigCountAggregateInputType | true
    _avg?: DeviceConfigAvgAggregateInputType
    _sum?: DeviceConfigSumAggregateInputType
    _min?: DeviceConfigMinAggregateInputType
    _max?: DeviceConfigMaxAggregateInputType
  }

  export type DeviceConfigGroupByOutputType = {
    id: number
    ip: string
    username: string
    passwordEnc: string
    lastEventTime: string | null
    authFailedAt: Date | null
    authFailureCount: number
    createdAt: Date
    updatedAt: Date
    _count: DeviceConfigCountAggregateOutputType | null
    _avg: DeviceConfigAvgAggregateOutputType | null
    _sum: DeviceConfigSumAggregateOutputType | null
    _min: DeviceConfigMinAggregateOutputType | null
    _max: DeviceConfigMaxAggregateOutputType | null
  }

  type GetDeviceConfigGroupByPayload<T extends DeviceConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceConfigGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceConfigGroupByOutputType[P]>
        }
      >
    >


  export type DeviceConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ip?: boolean
    username?: boolean
    passwordEnc?: boolean
    lastEventTime?: boolean
    authFailedAt?: boolean
    authFailureCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["deviceConfig"]>

  export type DeviceConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ip?: boolean
    username?: boolean
    passwordEnc?: boolean
    lastEventTime?: boolean
    authFailedAt?: boolean
    authFailureCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["deviceConfig"]>

  export type DeviceConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ip?: boolean
    username?: boolean
    passwordEnc?: boolean
    lastEventTime?: boolean
    authFailedAt?: boolean
    authFailureCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["deviceConfig"]>

  export type DeviceConfigSelectScalar = {
    id?: boolean
    ip?: boolean
    username?: boolean
    passwordEnc?: boolean
    lastEventTime?: boolean
    authFailedAt?: boolean
    authFailureCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeviceConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ip" | "username" | "passwordEnc" | "lastEventTime" | "authFailedAt" | "authFailureCount" | "createdAt" | "updatedAt", ExtArgs["result"]["deviceConfig"]>

  export type $DeviceConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ip: string
      username: string
      passwordEnc: string
      lastEventTime: string | null
      authFailedAt: Date | null
      authFailureCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deviceConfig"]>
    composites: {}
  }

  type DeviceConfigGetPayload<S extends boolean | null | undefined | DeviceConfigDefaultArgs> = $Result.GetResult<Prisma.$DeviceConfigPayload, S>

  type DeviceConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceConfigCountAggregateInputType | true
    }

  export interface DeviceConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceConfig'], meta: { name: 'DeviceConfig' } }
    /**
     * Find zero or one DeviceConfig that matches the filter.
     * @param {DeviceConfigFindUniqueArgs} args - Arguments to find a DeviceConfig
     * @example
     * // Get one DeviceConfig
     * const deviceConfig = await prisma.deviceConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceConfigFindUniqueArgs>(args: SelectSubset<T, DeviceConfigFindUniqueArgs<ExtArgs>>): Prisma__DeviceConfigClient<$Result.GetResult<Prisma.$DeviceConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceConfigFindUniqueOrThrowArgs} args - Arguments to find a DeviceConfig
     * @example
     * // Get one DeviceConfig
     * const deviceConfig = await prisma.deviceConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceConfigClient<$Result.GetResult<Prisma.$DeviceConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceConfigFindFirstArgs} args - Arguments to find a DeviceConfig
     * @example
     * // Get one DeviceConfig
     * const deviceConfig = await prisma.deviceConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceConfigFindFirstArgs>(args?: SelectSubset<T, DeviceConfigFindFirstArgs<ExtArgs>>): Prisma__DeviceConfigClient<$Result.GetResult<Prisma.$DeviceConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceConfigFindFirstOrThrowArgs} args - Arguments to find a DeviceConfig
     * @example
     * // Get one DeviceConfig
     * const deviceConfig = await prisma.deviceConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceConfigClient<$Result.GetResult<Prisma.$DeviceConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceConfigs
     * const deviceConfigs = await prisma.deviceConfig.findMany()
     * 
     * // Get first 10 DeviceConfigs
     * const deviceConfigs = await prisma.deviceConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceConfigWithIdOnly = await prisma.deviceConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceConfigFindManyArgs>(args?: SelectSubset<T, DeviceConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceConfig.
     * @param {DeviceConfigCreateArgs} args - Arguments to create a DeviceConfig.
     * @example
     * // Create one DeviceConfig
     * const DeviceConfig = await prisma.deviceConfig.create({
     *   data: {
     *     // ... data to create a DeviceConfig
     *   }
     * })
     * 
     */
    create<T extends DeviceConfigCreateArgs>(args: SelectSubset<T, DeviceConfigCreateArgs<ExtArgs>>): Prisma__DeviceConfigClient<$Result.GetResult<Prisma.$DeviceConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceConfigs.
     * @param {DeviceConfigCreateManyArgs} args - Arguments to create many DeviceConfigs.
     * @example
     * // Create many DeviceConfigs
     * const deviceConfig = await prisma.deviceConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceConfigCreateManyArgs>(args?: SelectSubset<T, DeviceConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceConfigs and returns the data saved in the database.
     * @param {DeviceConfigCreateManyAndReturnArgs} args - Arguments to create many DeviceConfigs.
     * @example
     * // Create many DeviceConfigs
     * const deviceConfig = await prisma.deviceConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceConfigs and only return the `id`
     * const deviceConfigWithIdOnly = await prisma.deviceConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeviceConfig.
     * @param {DeviceConfigDeleteArgs} args - Arguments to delete one DeviceConfig.
     * @example
     * // Delete one DeviceConfig
     * const DeviceConfig = await prisma.deviceConfig.delete({
     *   where: {
     *     // ... filter to delete one DeviceConfig
     *   }
     * })
     * 
     */
    delete<T extends DeviceConfigDeleteArgs>(args: SelectSubset<T, DeviceConfigDeleteArgs<ExtArgs>>): Prisma__DeviceConfigClient<$Result.GetResult<Prisma.$DeviceConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceConfig.
     * @param {DeviceConfigUpdateArgs} args - Arguments to update one DeviceConfig.
     * @example
     * // Update one DeviceConfig
     * const deviceConfig = await prisma.deviceConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceConfigUpdateArgs>(args: SelectSubset<T, DeviceConfigUpdateArgs<ExtArgs>>): Prisma__DeviceConfigClient<$Result.GetResult<Prisma.$DeviceConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceConfigs.
     * @param {DeviceConfigDeleteManyArgs} args - Arguments to filter DeviceConfigs to delete.
     * @example
     * // Delete a few DeviceConfigs
     * const { count } = await prisma.deviceConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceConfigDeleteManyArgs>(args?: SelectSubset<T, DeviceConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceConfigs
     * const deviceConfig = await prisma.deviceConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceConfigUpdateManyArgs>(args: SelectSubset<T, DeviceConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceConfigs and returns the data updated in the database.
     * @param {DeviceConfigUpdateManyAndReturnArgs} args - Arguments to update many DeviceConfigs.
     * @example
     * // Update many DeviceConfigs
     * const deviceConfig = await prisma.deviceConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeviceConfigs and only return the `id`
     * const deviceConfigWithIdOnly = await prisma.deviceConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeviceConfig.
     * @param {DeviceConfigUpsertArgs} args - Arguments to update or create a DeviceConfig.
     * @example
     * // Update or create a DeviceConfig
     * const deviceConfig = await prisma.deviceConfig.upsert({
     *   create: {
     *     // ... data to create a DeviceConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceConfig we want to update
     *   }
     * })
     */
    upsert<T extends DeviceConfigUpsertArgs>(args: SelectSubset<T, DeviceConfigUpsertArgs<ExtArgs>>): Prisma__DeviceConfigClient<$Result.GetResult<Prisma.$DeviceConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceConfigCountArgs} args - Arguments to filter DeviceConfigs to count.
     * @example
     * // Count the number of DeviceConfigs
     * const count = await prisma.deviceConfig.count({
     *   where: {
     *     // ... the filter for the DeviceConfigs we want to count
     *   }
     * })
    **/
    count<T extends DeviceConfigCountArgs>(
      args?: Subset<T, DeviceConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceConfigAggregateArgs>(args: Subset<T, DeviceConfigAggregateArgs>): Prisma.PrismaPromise<GetDeviceConfigAggregateType<T>>

    /**
     * Group by DeviceConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceConfigGroupByArgs['orderBy'] }
        : { orderBy?: DeviceConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceConfig model
   */
  readonly fields: DeviceConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceConfig model
   */
  interface DeviceConfigFieldRefs {
    readonly id: FieldRef<"DeviceConfig", 'Int'>
    readonly ip: FieldRef<"DeviceConfig", 'String'>
    readonly username: FieldRef<"DeviceConfig", 'String'>
    readonly passwordEnc: FieldRef<"DeviceConfig", 'String'>
    readonly lastEventTime: FieldRef<"DeviceConfig", 'String'>
    readonly authFailedAt: FieldRef<"DeviceConfig", 'DateTime'>
    readonly authFailureCount: FieldRef<"DeviceConfig", 'Int'>
    readonly createdAt: FieldRef<"DeviceConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"DeviceConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeviceConfig findUnique
   */
  export type DeviceConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConfig
     */
    select?: DeviceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceConfig
     */
    omit?: DeviceConfigOmit<ExtArgs> | null
    /**
     * Filter, which DeviceConfig to fetch.
     */
    where: DeviceConfigWhereUniqueInput
  }

  /**
   * DeviceConfig findUniqueOrThrow
   */
  export type DeviceConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConfig
     */
    select?: DeviceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceConfig
     */
    omit?: DeviceConfigOmit<ExtArgs> | null
    /**
     * Filter, which DeviceConfig to fetch.
     */
    where: DeviceConfigWhereUniqueInput
  }

  /**
   * DeviceConfig findFirst
   */
  export type DeviceConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConfig
     */
    select?: DeviceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceConfig
     */
    omit?: DeviceConfigOmit<ExtArgs> | null
    /**
     * Filter, which DeviceConfig to fetch.
     */
    where?: DeviceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceConfigs to fetch.
     */
    orderBy?: DeviceConfigOrderByWithRelationInput | DeviceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceConfigs.
     */
    cursor?: DeviceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceConfigs.
     */
    distinct?: DeviceConfigScalarFieldEnum | DeviceConfigScalarFieldEnum[]
  }

  /**
   * DeviceConfig findFirstOrThrow
   */
  export type DeviceConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConfig
     */
    select?: DeviceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceConfig
     */
    omit?: DeviceConfigOmit<ExtArgs> | null
    /**
     * Filter, which DeviceConfig to fetch.
     */
    where?: DeviceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceConfigs to fetch.
     */
    orderBy?: DeviceConfigOrderByWithRelationInput | DeviceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceConfigs.
     */
    cursor?: DeviceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceConfigs.
     */
    distinct?: DeviceConfigScalarFieldEnum | DeviceConfigScalarFieldEnum[]
  }

  /**
   * DeviceConfig findMany
   */
  export type DeviceConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConfig
     */
    select?: DeviceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceConfig
     */
    omit?: DeviceConfigOmit<ExtArgs> | null
    /**
     * Filter, which DeviceConfigs to fetch.
     */
    where?: DeviceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceConfigs to fetch.
     */
    orderBy?: DeviceConfigOrderByWithRelationInput | DeviceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceConfigs.
     */
    cursor?: DeviceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceConfigs.
     */
    skip?: number
    distinct?: DeviceConfigScalarFieldEnum | DeviceConfigScalarFieldEnum[]
  }

  /**
   * DeviceConfig create
   */
  export type DeviceConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConfig
     */
    select?: DeviceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceConfig
     */
    omit?: DeviceConfigOmit<ExtArgs> | null
    /**
     * The data needed to create a DeviceConfig.
     */
    data: XOR<DeviceConfigCreateInput, DeviceConfigUncheckedCreateInput>
  }

  /**
   * DeviceConfig createMany
   */
  export type DeviceConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceConfigs.
     */
    data: DeviceConfigCreateManyInput | DeviceConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceConfig createManyAndReturn
   */
  export type DeviceConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConfig
     */
    select?: DeviceConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceConfig
     */
    omit?: DeviceConfigOmit<ExtArgs> | null
    /**
     * The data used to create many DeviceConfigs.
     */
    data: DeviceConfigCreateManyInput | DeviceConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceConfig update
   */
  export type DeviceConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConfig
     */
    select?: DeviceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceConfig
     */
    omit?: DeviceConfigOmit<ExtArgs> | null
    /**
     * The data needed to update a DeviceConfig.
     */
    data: XOR<DeviceConfigUpdateInput, DeviceConfigUncheckedUpdateInput>
    /**
     * Choose, which DeviceConfig to update.
     */
    where: DeviceConfigWhereUniqueInput
  }

  /**
   * DeviceConfig updateMany
   */
  export type DeviceConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceConfigs.
     */
    data: XOR<DeviceConfigUpdateManyMutationInput, DeviceConfigUncheckedUpdateManyInput>
    /**
     * Filter which DeviceConfigs to update
     */
    where?: DeviceConfigWhereInput
    /**
     * Limit how many DeviceConfigs to update.
     */
    limit?: number
  }

  /**
   * DeviceConfig updateManyAndReturn
   */
  export type DeviceConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConfig
     */
    select?: DeviceConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceConfig
     */
    omit?: DeviceConfigOmit<ExtArgs> | null
    /**
     * The data used to update DeviceConfigs.
     */
    data: XOR<DeviceConfigUpdateManyMutationInput, DeviceConfigUncheckedUpdateManyInput>
    /**
     * Filter which DeviceConfigs to update
     */
    where?: DeviceConfigWhereInput
    /**
     * Limit how many DeviceConfigs to update.
     */
    limit?: number
  }

  /**
   * DeviceConfig upsert
   */
  export type DeviceConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConfig
     */
    select?: DeviceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceConfig
     */
    omit?: DeviceConfigOmit<ExtArgs> | null
    /**
     * The filter to search for the DeviceConfig to update in case it exists.
     */
    where: DeviceConfigWhereUniqueInput
    /**
     * In case the DeviceConfig found by the `where` argument doesn't exist, create a new DeviceConfig with this data.
     */
    create: XOR<DeviceConfigCreateInput, DeviceConfigUncheckedCreateInput>
    /**
     * In case the DeviceConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceConfigUpdateInput, DeviceConfigUncheckedUpdateInput>
  }

  /**
   * DeviceConfig delete
   */
  export type DeviceConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConfig
     */
    select?: DeviceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceConfig
     */
    omit?: DeviceConfigOmit<ExtArgs> | null
    /**
     * Filter which DeviceConfig to delete.
     */
    where: DeviceConfigWhereUniqueInput
  }

  /**
   * DeviceConfig deleteMany
   */
  export type DeviceConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceConfigs to delete
     */
    where?: DeviceConfigWhereInput
    /**
     * Limit how many DeviceConfigs to delete.
     */
    limit?: number
  }

  /**
   * DeviceConfig without action
   */
  export type DeviceConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConfig
     */
    select?: DeviceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceConfig
     */
    omit?: DeviceConfigOmit<ExtArgs> | null
  }


  /**
   * Model AttendanceConfig
   */

  export type AggregateAttendanceConfig = {
    _count: AttendanceConfigCountAggregateOutputType | null
    _avg: AttendanceConfigAvgAggregateOutputType | null
    _sum: AttendanceConfigSumAggregateOutputType | null
    _min: AttendanceConfigMinAggregateOutputType | null
    _max: AttendanceConfigMaxAggregateOutputType | null
  }

  export type AttendanceConfigAvgAggregateOutputType = {
    id: number | null
  }

  export type AttendanceConfigSumAggregateOutputType = {
    id: number | null
  }

  export type AttendanceConfigMinAggregateOutputType = {
    id: number | null
    workStart: Date | null
    workEnd: Date | null
    otEnd: Date | null
    earlyStart: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceConfigMaxAggregateOutputType = {
    id: number | null
    workStart: Date | null
    workEnd: Date | null
    otEnd: Date | null
    earlyStart: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceConfigCountAggregateOutputType = {
    id: number
    workStart: number
    workEnd: number
    otEnd: number
    earlyStart: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttendanceConfigAvgAggregateInputType = {
    id?: true
  }

  export type AttendanceConfigSumAggregateInputType = {
    id?: true
  }

  export type AttendanceConfigMinAggregateInputType = {
    id?: true
    workStart?: true
    workEnd?: true
    otEnd?: true
    earlyStart?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceConfigMaxAggregateInputType = {
    id?: true
    workStart?: true
    workEnd?: true
    otEnd?: true
    earlyStart?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceConfigCountAggregateInputType = {
    id?: true
    workStart?: true
    workEnd?: true
    otEnd?: true
    earlyStart?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttendanceConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceConfig to aggregate.
     */
    where?: AttendanceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceConfigs to fetch.
     */
    orderBy?: AttendanceConfigOrderByWithRelationInput | AttendanceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendanceConfigs
    **/
    _count?: true | AttendanceConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceConfigMaxAggregateInputType
  }

  export type GetAttendanceConfigAggregateType<T extends AttendanceConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendanceConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceConfig[P]>
      : GetScalarType<T[P], AggregateAttendanceConfig[P]>
  }




  export type AttendanceConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceConfigWhereInput
    orderBy?: AttendanceConfigOrderByWithAggregationInput | AttendanceConfigOrderByWithAggregationInput[]
    by: AttendanceConfigScalarFieldEnum[] | AttendanceConfigScalarFieldEnum
    having?: AttendanceConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceConfigCountAggregateInputType | true
    _avg?: AttendanceConfigAvgAggregateInputType
    _sum?: AttendanceConfigSumAggregateInputType
    _min?: AttendanceConfigMinAggregateInputType
    _max?: AttendanceConfigMaxAggregateInputType
  }

  export type AttendanceConfigGroupByOutputType = {
    id: number
    workStart: Date
    workEnd: Date
    otEnd: Date
    earlyStart: Date
    createdAt: Date
    updatedAt: Date
    _count: AttendanceConfigCountAggregateOutputType | null
    _avg: AttendanceConfigAvgAggregateOutputType | null
    _sum: AttendanceConfigSumAggregateOutputType | null
    _min: AttendanceConfigMinAggregateOutputType | null
    _max: AttendanceConfigMaxAggregateOutputType | null
  }

  type GetAttendanceConfigGroupByPayload<T extends AttendanceConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceConfigGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceConfigGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workStart?: boolean
    workEnd?: boolean
    otEnd?: boolean
    earlyStart?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["attendanceConfig"]>

  export type AttendanceConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workStart?: boolean
    workEnd?: boolean
    otEnd?: boolean
    earlyStart?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["attendanceConfig"]>

  export type AttendanceConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workStart?: boolean
    workEnd?: boolean
    otEnd?: boolean
    earlyStart?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["attendanceConfig"]>

  export type AttendanceConfigSelectScalar = {
    id?: boolean
    workStart?: boolean
    workEnd?: boolean
    otEnd?: boolean
    earlyStart?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AttendanceConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workStart" | "workEnd" | "otEnd" | "earlyStart" | "createdAt" | "updatedAt", ExtArgs["result"]["attendanceConfig"]>

  export type $AttendanceConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttendanceConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      workStart: Date
      workEnd: Date
      otEnd: Date
      earlyStart: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["attendanceConfig"]>
    composites: {}
  }

  type AttendanceConfigGetPayload<S extends boolean | null | undefined | AttendanceConfigDefaultArgs> = $Result.GetResult<Prisma.$AttendanceConfigPayload, S>

  type AttendanceConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceConfigCountAggregateInputType | true
    }

  export interface AttendanceConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendanceConfig'], meta: { name: 'AttendanceConfig' } }
    /**
     * Find zero or one AttendanceConfig that matches the filter.
     * @param {AttendanceConfigFindUniqueArgs} args - Arguments to find a AttendanceConfig
     * @example
     * // Get one AttendanceConfig
     * const attendanceConfig = await prisma.attendanceConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceConfigFindUniqueArgs>(args: SelectSubset<T, AttendanceConfigFindUniqueArgs<ExtArgs>>): Prisma__AttendanceConfigClient<$Result.GetResult<Prisma.$AttendanceConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AttendanceConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceConfigFindUniqueOrThrowArgs} args - Arguments to find a AttendanceConfig
     * @example
     * // Get one AttendanceConfig
     * const attendanceConfig = await prisma.attendanceConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceConfigClient<$Result.GetResult<Prisma.$AttendanceConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceConfigFindFirstArgs} args - Arguments to find a AttendanceConfig
     * @example
     * // Get one AttendanceConfig
     * const attendanceConfig = await prisma.attendanceConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceConfigFindFirstArgs>(args?: SelectSubset<T, AttendanceConfigFindFirstArgs<ExtArgs>>): Prisma__AttendanceConfigClient<$Result.GetResult<Prisma.$AttendanceConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceConfigFindFirstOrThrowArgs} args - Arguments to find a AttendanceConfig
     * @example
     * // Get one AttendanceConfig
     * const attendanceConfig = await prisma.attendanceConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceConfigClient<$Result.GetResult<Prisma.$AttendanceConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AttendanceConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceConfigs
     * const attendanceConfigs = await prisma.attendanceConfig.findMany()
     * 
     * // Get first 10 AttendanceConfigs
     * const attendanceConfigs = await prisma.attendanceConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceConfigWithIdOnly = await prisma.attendanceConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceConfigFindManyArgs>(args?: SelectSubset<T, AttendanceConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AttendanceConfig.
     * @param {AttendanceConfigCreateArgs} args - Arguments to create a AttendanceConfig.
     * @example
     * // Create one AttendanceConfig
     * const AttendanceConfig = await prisma.attendanceConfig.create({
     *   data: {
     *     // ... data to create a AttendanceConfig
     *   }
     * })
     * 
     */
    create<T extends AttendanceConfigCreateArgs>(args: SelectSubset<T, AttendanceConfigCreateArgs<ExtArgs>>): Prisma__AttendanceConfigClient<$Result.GetResult<Prisma.$AttendanceConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AttendanceConfigs.
     * @param {AttendanceConfigCreateManyArgs} args - Arguments to create many AttendanceConfigs.
     * @example
     * // Create many AttendanceConfigs
     * const attendanceConfig = await prisma.attendanceConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceConfigCreateManyArgs>(args?: SelectSubset<T, AttendanceConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttendanceConfigs and returns the data saved in the database.
     * @param {AttendanceConfigCreateManyAndReturnArgs} args - Arguments to create many AttendanceConfigs.
     * @example
     * // Create many AttendanceConfigs
     * const attendanceConfig = await prisma.attendanceConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttendanceConfigs and only return the `id`
     * const attendanceConfigWithIdOnly = await prisma.attendanceConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AttendanceConfig.
     * @param {AttendanceConfigDeleteArgs} args - Arguments to delete one AttendanceConfig.
     * @example
     * // Delete one AttendanceConfig
     * const AttendanceConfig = await prisma.attendanceConfig.delete({
     *   where: {
     *     // ... filter to delete one AttendanceConfig
     *   }
     * })
     * 
     */
    delete<T extends AttendanceConfigDeleteArgs>(args: SelectSubset<T, AttendanceConfigDeleteArgs<ExtArgs>>): Prisma__AttendanceConfigClient<$Result.GetResult<Prisma.$AttendanceConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AttendanceConfig.
     * @param {AttendanceConfigUpdateArgs} args - Arguments to update one AttendanceConfig.
     * @example
     * // Update one AttendanceConfig
     * const attendanceConfig = await prisma.attendanceConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceConfigUpdateArgs>(args: SelectSubset<T, AttendanceConfigUpdateArgs<ExtArgs>>): Prisma__AttendanceConfigClient<$Result.GetResult<Prisma.$AttendanceConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AttendanceConfigs.
     * @param {AttendanceConfigDeleteManyArgs} args - Arguments to filter AttendanceConfigs to delete.
     * @example
     * // Delete a few AttendanceConfigs
     * const { count } = await prisma.attendanceConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceConfigDeleteManyArgs>(args?: SelectSubset<T, AttendanceConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceConfigs
     * const attendanceConfig = await prisma.attendanceConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceConfigUpdateManyArgs>(args: SelectSubset<T, AttendanceConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceConfigs and returns the data updated in the database.
     * @param {AttendanceConfigUpdateManyAndReturnArgs} args - Arguments to update many AttendanceConfigs.
     * @example
     * // Update many AttendanceConfigs
     * const attendanceConfig = await prisma.attendanceConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AttendanceConfigs and only return the `id`
     * const attendanceConfigWithIdOnly = await prisma.attendanceConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AttendanceConfig.
     * @param {AttendanceConfigUpsertArgs} args - Arguments to update or create a AttendanceConfig.
     * @example
     * // Update or create a AttendanceConfig
     * const attendanceConfig = await prisma.attendanceConfig.upsert({
     *   create: {
     *     // ... data to create a AttendanceConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceConfig we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceConfigUpsertArgs>(args: SelectSubset<T, AttendanceConfigUpsertArgs<ExtArgs>>): Prisma__AttendanceConfigClient<$Result.GetResult<Prisma.$AttendanceConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AttendanceConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceConfigCountArgs} args - Arguments to filter AttendanceConfigs to count.
     * @example
     * // Count the number of AttendanceConfigs
     * const count = await prisma.attendanceConfig.count({
     *   where: {
     *     // ... the filter for the AttendanceConfigs we want to count
     *   }
     * })
    **/
    count<T extends AttendanceConfigCountArgs>(
      args?: Subset<T, AttendanceConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendanceConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceConfigAggregateArgs>(args: Subset<T, AttendanceConfigAggregateArgs>): Prisma.PrismaPromise<GetAttendanceConfigAggregateType<T>>

    /**
     * Group by AttendanceConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceConfigGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttendanceConfig model
   */
  readonly fields: AttendanceConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttendanceConfig model
   */
  interface AttendanceConfigFieldRefs {
    readonly id: FieldRef<"AttendanceConfig", 'Int'>
    readonly workStart: FieldRef<"AttendanceConfig", 'DateTime'>
    readonly workEnd: FieldRef<"AttendanceConfig", 'DateTime'>
    readonly otEnd: FieldRef<"AttendanceConfig", 'DateTime'>
    readonly earlyStart: FieldRef<"AttendanceConfig", 'DateTime'>
    readonly createdAt: FieldRef<"AttendanceConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"AttendanceConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AttendanceConfig findUnique
   */
  export type AttendanceConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceConfig
     */
    select?: AttendanceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceConfig
     */
    omit?: AttendanceConfigOmit<ExtArgs> | null
    /**
     * Filter, which AttendanceConfig to fetch.
     */
    where: AttendanceConfigWhereUniqueInput
  }

  /**
   * AttendanceConfig findUniqueOrThrow
   */
  export type AttendanceConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceConfig
     */
    select?: AttendanceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceConfig
     */
    omit?: AttendanceConfigOmit<ExtArgs> | null
    /**
     * Filter, which AttendanceConfig to fetch.
     */
    where: AttendanceConfigWhereUniqueInput
  }

  /**
   * AttendanceConfig findFirst
   */
  export type AttendanceConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceConfig
     */
    select?: AttendanceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceConfig
     */
    omit?: AttendanceConfigOmit<ExtArgs> | null
    /**
     * Filter, which AttendanceConfig to fetch.
     */
    where?: AttendanceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceConfigs to fetch.
     */
    orderBy?: AttendanceConfigOrderByWithRelationInput | AttendanceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceConfigs.
     */
    cursor?: AttendanceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceConfigs.
     */
    distinct?: AttendanceConfigScalarFieldEnum | AttendanceConfigScalarFieldEnum[]
  }

  /**
   * AttendanceConfig findFirstOrThrow
   */
  export type AttendanceConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceConfig
     */
    select?: AttendanceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceConfig
     */
    omit?: AttendanceConfigOmit<ExtArgs> | null
    /**
     * Filter, which AttendanceConfig to fetch.
     */
    where?: AttendanceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceConfigs to fetch.
     */
    orderBy?: AttendanceConfigOrderByWithRelationInput | AttendanceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceConfigs.
     */
    cursor?: AttendanceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceConfigs.
     */
    distinct?: AttendanceConfigScalarFieldEnum | AttendanceConfigScalarFieldEnum[]
  }

  /**
   * AttendanceConfig findMany
   */
  export type AttendanceConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceConfig
     */
    select?: AttendanceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceConfig
     */
    omit?: AttendanceConfigOmit<ExtArgs> | null
    /**
     * Filter, which AttendanceConfigs to fetch.
     */
    where?: AttendanceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceConfigs to fetch.
     */
    orderBy?: AttendanceConfigOrderByWithRelationInput | AttendanceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendanceConfigs.
     */
    cursor?: AttendanceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceConfigs.
     */
    skip?: number
    distinct?: AttendanceConfigScalarFieldEnum | AttendanceConfigScalarFieldEnum[]
  }

  /**
   * AttendanceConfig create
   */
  export type AttendanceConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceConfig
     */
    select?: AttendanceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceConfig
     */
    omit?: AttendanceConfigOmit<ExtArgs> | null
    /**
     * The data needed to create a AttendanceConfig.
     */
    data: XOR<AttendanceConfigCreateInput, AttendanceConfigUncheckedCreateInput>
  }

  /**
   * AttendanceConfig createMany
   */
  export type AttendanceConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendanceConfigs.
     */
    data: AttendanceConfigCreateManyInput | AttendanceConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttendanceConfig createManyAndReturn
   */
  export type AttendanceConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceConfig
     */
    select?: AttendanceConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceConfig
     */
    omit?: AttendanceConfigOmit<ExtArgs> | null
    /**
     * The data used to create many AttendanceConfigs.
     */
    data: AttendanceConfigCreateManyInput | AttendanceConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttendanceConfig update
   */
  export type AttendanceConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceConfig
     */
    select?: AttendanceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceConfig
     */
    omit?: AttendanceConfigOmit<ExtArgs> | null
    /**
     * The data needed to update a AttendanceConfig.
     */
    data: XOR<AttendanceConfigUpdateInput, AttendanceConfigUncheckedUpdateInput>
    /**
     * Choose, which AttendanceConfig to update.
     */
    where: AttendanceConfigWhereUniqueInput
  }

  /**
   * AttendanceConfig updateMany
   */
  export type AttendanceConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendanceConfigs.
     */
    data: XOR<AttendanceConfigUpdateManyMutationInput, AttendanceConfigUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceConfigs to update
     */
    where?: AttendanceConfigWhereInput
    /**
     * Limit how many AttendanceConfigs to update.
     */
    limit?: number
  }

  /**
   * AttendanceConfig updateManyAndReturn
   */
  export type AttendanceConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceConfig
     */
    select?: AttendanceConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceConfig
     */
    omit?: AttendanceConfigOmit<ExtArgs> | null
    /**
     * The data used to update AttendanceConfigs.
     */
    data: XOR<AttendanceConfigUpdateManyMutationInput, AttendanceConfigUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceConfigs to update
     */
    where?: AttendanceConfigWhereInput
    /**
     * Limit how many AttendanceConfigs to update.
     */
    limit?: number
  }

  /**
   * AttendanceConfig upsert
   */
  export type AttendanceConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceConfig
     */
    select?: AttendanceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceConfig
     */
    omit?: AttendanceConfigOmit<ExtArgs> | null
    /**
     * The filter to search for the AttendanceConfig to update in case it exists.
     */
    where: AttendanceConfigWhereUniqueInput
    /**
     * In case the AttendanceConfig found by the `where` argument doesn't exist, create a new AttendanceConfig with this data.
     */
    create: XOR<AttendanceConfigCreateInput, AttendanceConfigUncheckedCreateInput>
    /**
     * In case the AttendanceConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceConfigUpdateInput, AttendanceConfigUncheckedUpdateInput>
  }

  /**
   * AttendanceConfig delete
   */
  export type AttendanceConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceConfig
     */
    select?: AttendanceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceConfig
     */
    omit?: AttendanceConfigOmit<ExtArgs> | null
    /**
     * Filter which AttendanceConfig to delete.
     */
    where: AttendanceConfigWhereUniqueInput
  }

  /**
   * AttendanceConfig deleteMany
   */
  export type AttendanceConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceConfigs to delete
     */
    where?: AttendanceConfigWhereInput
    /**
     * Limit how many AttendanceConfigs to delete.
     */
    limit?: number
  }

  /**
   * AttendanceConfig without action
   */
  export type AttendanceConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceConfig
     */
    select?: AttendanceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceConfig
     */
    omit?: AttendanceConfigOmit<ExtArgs> | null
  }


  /**
   * Model SalaryConfig
   */

  export type AggregateSalaryConfig = {
    _count: SalaryConfigCountAggregateOutputType | null
    _avg: SalaryConfigAvgAggregateOutputType | null
    _sum: SalaryConfigSumAggregateOutputType | null
    _min: SalaryConfigMinAggregateOutputType | null
    _max: SalaryConfigMaxAggregateOutputType | null
  }

  export type SalaryConfigAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    basicSalary: number | null
    otRate: number | null
    allowance: number | null
    deduction: number | null
  }

  export type SalaryConfigSumAggregateOutputType = {
    id: number | null
    userId: number | null
    basicSalary: number | null
    otRate: number | null
    allowance: number | null
    deduction: number | null
  }

  export type SalaryConfigMinAggregateOutputType = {
    id: number | null
    userId: number | null
    basicSalary: number | null
    otRate: number | null
    allowance: number | null
    deduction: number | null
    effectiveFrom: Date | null
  }

  export type SalaryConfigMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    basicSalary: number | null
    otRate: number | null
    allowance: number | null
    deduction: number | null
    effectiveFrom: Date | null
  }

  export type SalaryConfigCountAggregateOutputType = {
    id: number
    userId: number
    basicSalary: number
    otRate: number
    allowance: number
    deduction: number
    effectiveFrom: number
    _all: number
  }


  export type SalaryConfigAvgAggregateInputType = {
    id?: true
    userId?: true
    basicSalary?: true
    otRate?: true
    allowance?: true
    deduction?: true
  }

  export type SalaryConfigSumAggregateInputType = {
    id?: true
    userId?: true
    basicSalary?: true
    otRate?: true
    allowance?: true
    deduction?: true
  }

  export type SalaryConfigMinAggregateInputType = {
    id?: true
    userId?: true
    basicSalary?: true
    otRate?: true
    allowance?: true
    deduction?: true
    effectiveFrom?: true
  }

  export type SalaryConfigMaxAggregateInputType = {
    id?: true
    userId?: true
    basicSalary?: true
    otRate?: true
    allowance?: true
    deduction?: true
    effectiveFrom?: true
  }

  export type SalaryConfigCountAggregateInputType = {
    id?: true
    userId?: true
    basicSalary?: true
    otRate?: true
    allowance?: true
    deduction?: true
    effectiveFrom?: true
    _all?: true
  }

  export type SalaryConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryConfig to aggregate.
     */
    where?: SalaryConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryConfigs to fetch.
     */
    orderBy?: SalaryConfigOrderByWithRelationInput | SalaryConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalaryConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalaryConfigs
    **/
    _count?: true | SalaryConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalaryConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalaryConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalaryConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalaryConfigMaxAggregateInputType
  }

  export type GetSalaryConfigAggregateType<T extends SalaryConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateSalaryConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalaryConfig[P]>
      : GetScalarType<T[P], AggregateSalaryConfig[P]>
  }




  export type SalaryConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryConfigWhereInput
    orderBy?: SalaryConfigOrderByWithAggregationInput | SalaryConfigOrderByWithAggregationInput[]
    by: SalaryConfigScalarFieldEnum[] | SalaryConfigScalarFieldEnum
    having?: SalaryConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalaryConfigCountAggregateInputType | true
    _avg?: SalaryConfigAvgAggregateInputType
    _sum?: SalaryConfigSumAggregateInputType
    _min?: SalaryConfigMinAggregateInputType
    _max?: SalaryConfigMaxAggregateInputType
  }

  export type SalaryConfigGroupByOutputType = {
    id: number
    userId: number
    basicSalary: number
    otRate: number | null
    allowance: number | null
    deduction: number | null
    effectiveFrom: Date
    _count: SalaryConfigCountAggregateOutputType | null
    _avg: SalaryConfigAvgAggregateOutputType | null
    _sum: SalaryConfigSumAggregateOutputType | null
    _min: SalaryConfigMinAggregateOutputType | null
    _max: SalaryConfigMaxAggregateOutputType | null
  }

  type GetSalaryConfigGroupByPayload<T extends SalaryConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalaryConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalaryConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalaryConfigGroupByOutputType[P]>
            : GetScalarType<T[P], SalaryConfigGroupByOutputType[P]>
        }
      >
    >


  export type SalaryConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    basicSalary?: boolean
    otRate?: boolean
    allowance?: boolean
    deduction?: boolean
    effectiveFrom?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryConfig"]>

  export type SalaryConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    basicSalary?: boolean
    otRate?: boolean
    allowance?: boolean
    deduction?: boolean
    effectiveFrom?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryConfig"]>

  export type SalaryConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    basicSalary?: boolean
    otRate?: boolean
    allowance?: boolean
    deduction?: boolean
    effectiveFrom?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryConfig"]>

  export type SalaryConfigSelectScalar = {
    id?: boolean
    userId?: boolean
    basicSalary?: boolean
    otRate?: boolean
    allowance?: boolean
    deduction?: boolean
    effectiveFrom?: boolean
  }

  export type SalaryConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "basicSalary" | "otRate" | "allowance" | "deduction" | "effectiveFrom", ExtArgs["result"]["salaryConfig"]>
  export type SalaryConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SalaryConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SalaryConfigIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SalaryConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalaryConfig"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      basicSalary: number
      otRate: number | null
      allowance: number | null
      deduction: number | null
      effectiveFrom: Date
    }, ExtArgs["result"]["salaryConfig"]>
    composites: {}
  }

  type SalaryConfigGetPayload<S extends boolean | null | undefined | SalaryConfigDefaultArgs> = $Result.GetResult<Prisma.$SalaryConfigPayload, S>

  type SalaryConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalaryConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalaryConfigCountAggregateInputType | true
    }

  export interface SalaryConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalaryConfig'], meta: { name: 'SalaryConfig' } }
    /**
     * Find zero or one SalaryConfig that matches the filter.
     * @param {SalaryConfigFindUniqueArgs} args - Arguments to find a SalaryConfig
     * @example
     * // Get one SalaryConfig
     * const salaryConfig = await prisma.salaryConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalaryConfigFindUniqueArgs>(args: SelectSubset<T, SalaryConfigFindUniqueArgs<ExtArgs>>): Prisma__SalaryConfigClient<$Result.GetResult<Prisma.$SalaryConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalaryConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalaryConfigFindUniqueOrThrowArgs} args - Arguments to find a SalaryConfig
     * @example
     * // Get one SalaryConfig
     * const salaryConfig = await prisma.salaryConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalaryConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, SalaryConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalaryConfigClient<$Result.GetResult<Prisma.$SalaryConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalaryConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryConfigFindFirstArgs} args - Arguments to find a SalaryConfig
     * @example
     * // Get one SalaryConfig
     * const salaryConfig = await prisma.salaryConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalaryConfigFindFirstArgs>(args?: SelectSubset<T, SalaryConfigFindFirstArgs<ExtArgs>>): Prisma__SalaryConfigClient<$Result.GetResult<Prisma.$SalaryConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalaryConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryConfigFindFirstOrThrowArgs} args - Arguments to find a SalaryConfig
     * @example
     * // Get one SalaryConfig
     * const salaryConfig = await prisma.salaryConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalaryConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, SalaryConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalaryConfigClient<$Result.GetResult<Prisma.$SalaryConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalaryConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalaryConfigs
     * const salaryConfigs = await prisma.salaryConfig.findMany()
     * 
     * // Get first 10 SalaryConfigs
     * const salaryConfigs = await prisma.salaryConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salaryConfigWithIdOnly = await prisma.salaryConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalaryConfigFindManyArgs>(args?: SelectSubset<T, SalaryConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalaryConfig.
     * @param {SalaryConfigCreateArgs} args - Arguments to create a SalaryConfig.
     * @example
     * // Create one SalaryConfig
     * const SalaryConfig = await prisma.salaryConfig.create({
     *   data: {
     *     // ... data to create a SalaryConfig
     *   }
     * })
     * 
     */
    create<T extends SalaryConfigCreateArgs>(args: SelectSubset<T, SalaryConfigCreateArgs<ExtArgs>>): Prisma__SalaryConfigClient<$Result.GetResult<Prisma.$SalaryConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalaryConfigs.
     * @param {SalaryConfigCreateManyArgs} args - Arguments to create many SalaryConfigs.
     * @example
     * // Create many SalaryConfigs
     * const salaryConfig = await prisma.salaryConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalaryConfigCreateManyArgs>(args?: SelectSubset<T, SalaryConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalaryConfigs and returns the data saved in the database.
     * @param {SalaryConfigCreateManyAndReturnArgs} args - Arguments to create many SalaryConfigs.
     * @example
     * // Create many SalaryConfigs
     * const salaryConfig = await prisma.salaryConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalaryConfigs and only return the `id`
     * const salaryConfigWithIdOnly = await prisma.salaryConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalaryConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, SalaryConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalaryConfig.
     * @param {SalaryConfigDeleteArgs} args - Arguments to delete one SalaryConfig.
     * @example
     * // Delete one SalaryConfig
     * const SalaryConfig = await prisma.salaryConfig.delete({
     *   where: {
     *     // ... filter to delete one SalaryConfig
     *   }
     * })
     * 
     */
    delete<T extends SalaryConfigDeleteArgs>(args: SelectSubset<T, SalaryConfigDeleteArgs<ExtArgs>>): Prisma__SalaryConfigClient<$Result.GetResult<Prisma.$SalaryConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalaryConfig.
     * @param {SalaryConfigUpdateArgs} args - Arguments to update one SalaryConfig.
     * @example
     * // Update one SalaryConfig
     * const salaryConfig = await prisma.salaryConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalaryConfigUpdateArgs>(args: SelectSubset<T, SalaryConfigUpdateArgs<ExtArgs>>): Prisma__SalaryConfigClient<$Result.GetResult<Prisma.$SalaryConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalaryConfigs.
     * @param {SalaryConfigDeleteManyArgs} args - Arguments to filter SalaryConfigs to delete.
     * @example
     * // Delete a few SalaryConfigs
     * const { count } = await prisma.salaryConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalaryConfigDeleteManyArgs>(args?: SelectSubset<T, SalaryConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalaryConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalaryConfigs
     * const salaryConfig = await prisma.salaryConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalaryConfigUpdateManyArgs>(args: SelectSubset<T, SalaryConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalaryConfigs and returns the data updated in the database.
     * @param {SalaryConfigUpdateManyAndReturnArgs} args - Arguments to update many SalaryConfigs.
     * @example
     * // Update many SalaryConfigs
     * const salaryConfig = await prisma.salaryConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalaryConfigs and only return the `id`
     * const salaryConfigWithIdOnly = await prisma.salaryConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalaryConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, SalaryConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalaryConfig.
     * @param {SalaryConfigUpsertArgs} args - Arguments to update or create a SalaryConfig.
     * @example
     * // Update or create a SalaryConfig
     * const salaryConfig = await prisma.salaryConfig.upsert({
     *   create: {
     *     // ... data to create a SalaryConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalaryConfig we want to update
     *   }
     * })
     */
    upsert<T extends SalaryConfigUpsertArgs>(args: SelectSubset<T, SalaryConfigUpsertArgs<ExtArgs>>): Prisma__SalaryConfigClient<$Result.GetResult<Prisma.$SalaryConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalaryConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryConfigCountArgs} args - Arguments to filter SalaryConfigs to count.
     * @example
     * // Count the number of SalaryConfigs
     * const count = await prisma.salaryConfig.count({
     *   where: {
     *     // ... the filter for the SalaryConfigs we want to count
     *   }
     * })
    **/
    count<T extends SalaryConfigCountArgs>(
      args?: Subset<T, SalaryConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalaryConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalaryConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalaryConfigAggregateArgs>(args: Subset<T, SalaryConfigAggregateArgs>): Prisma.PrismaPromise<GetSalaryConfigAggregateType<T>>

    /**
     * Group by SalaryConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalaryConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalaryConfigGroupByArgs['orderBy'] }
        : { orderBy?: SalaryConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalaryConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalaryConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalaryConfig model
   */
  readonly fields: SalaryConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalaryConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalaryConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalaryConfig model
   */
  interface SalaryConfigFieldRefs {
    readonly id: FieldRef<"SalaryConfig", 'Int'>
    readonly userId: FieldRef<"SalaryConfig", 'Int'>
    readonly basicSalary: FieldRef<"SalaryConfig", 'Float'>
    readonly otRate: FieldRef<"SalaryConfig", 'Float'>
    readonly allowance: FieldRef<"SalaryConfig", 'Float'>
    readonly deduction: FieldRef<"SalaryConfig", 'Float'>
    readonly effectiveFrom: FieldRef<"SalaryConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalaryConfig findUnique
   */
  export type SalaryConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryConfig
     */
    select?: SalaryConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryConfig
     */
    omit?: SalaryConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryConfigInclude<ExtArgs> | null
    /**
     * Filter, which SalaryConfig to fetch.
     */
    where: SalaryConfigWhereUniqueInput
  }

  /**
   * SalaryConfig findUniqueOrThrow
   */
  export type SalaryConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryConfig
     */
    select?: SalaryConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryConfig
     */
    omit?: SalaryConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryConfigInclude<ExtArgs> | null
    /**
     * Filter, which SalaryConfig to fetch.
     */
    where: SalaryConfigWhereUniqueInput
  }

  /**
   * SalaryConfig findFirst
   */
  export type SalaryConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryConfig
     */
    select?: SalaryConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryConfig
     */
    omit?: SalaryConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryConfigInclude<ExtArgs> | null
    /**
     * Filter, which SalaryConfig to fetch.
     */
    where?: SalaryConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryConfigs to fetch.
     */
    orderBy?: SalaryConfigOrderByWithRelationInput | SalaryConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryConfigs.
     */
    cursor?: SalaryConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryConfigs.
     */
    distinct?: SalaryConfigScalarFieldEnum | SalaryConfigScalarFieldEnum[]
  }

  /**
   * SalaryConfig findFirstOrThrow
   */
  export type SalaryConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryConfig
     */
    select?: SalaryConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryConfig
     */
    omit?: SalaryConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryConfigInclude<ExtArgs> | null
    /**
     * Filter, which SalaryConfig to fetch.
     */
    where?: SalaryConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryConfigs to fetch.
     */
    orderBy?: SalaryConfigOrderByWithRelationInput | SalaryConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryConfigs.
     */
    cursor?: SalaryConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryConfigs.
     */
    distinct?: SalaryConfigScalarFieldEnum | SalaryConfigScalarFieldEnum[]
  }

  /**
   * SalaryConfig findMany
   */
  export type SalaryConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryConfig
     */
    select?: SalaryConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryConfig
     */
    omit?: SalaryConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryConfigInclude<ExtArgs> | null
    /**
     * Filter, which SalaryConfigs to fetch.
     */
    where?: SalaryConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryConfigs to fetch.
     */
    orderBy?: SalaryConfigOrderByWithRelationInput | SalaryConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalaryConfigs.
     */
    cursor?: SalaryConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryConfigs.
     */
    skip?: number
    distinct?: SalaryConfigScalarFieldEnum | SalaryConfigScalarFieldEnum[]
  }

  /**
   * SalaryConfig create
   */
  export type SalaryConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryConfig
     */
    select?: SalaryConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryConfig
     */
    omit?: SalaryConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a SalaryConfig.
     */
    data: XOR<SalaryConfigCreateInput, SalaryConfigUncheckedCreateInput>
  }

  /**
   * SalaryConfig createMany
   */
  export type SalaryConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalaryConfigs.
     */
    data: SalaryConfigCreateManyInput | SalaryConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalaryConfig createManyAndReturn
   */
  export type SalaryConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryConfig
     */
    select?: SalaryConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryConfig
     */
    omit?: SalaryConfigOmit<ExtArgs> | null
    /**
     * The data used to create many SalaryConfigs.
     */
    data: SalaryConfigCreateManyInput | SalaryConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalaryConfig update
   */
  export type SalaryConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryConfig
     */
    select?: SalaryConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryConfig
     */
    omit?: SalaryConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a SalaryConfig.
     */
    data: XOR<SalaryConfigUpdateInput, SalaryConfigUncheckedUpdateInput>
    /**
     * Choose, which SalaryConfig to update.
     */
    where: SalaryConfigWhereUniqueInput
  }

  /**
   * SalaryConfig updateMany
   */
  export type SalaryConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalaryConfigs.
     */
    data: XOR<SalaryConfigUpdateManyMutationInput, SalaryConfigUncheckedUpdateManyInput>
    /**
     * Filter which SalaryConfigs to update
     */
    where?: SalaryConfigWhereInput
    /**
     * Limit how many SalaryConfigs to update.
     */
    limit?: number
  }

  /**
   * SalaryConfig updateManyAndReturn
   */
  export type SalaryConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryConfig
     */
    select?: SalaryConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryConfig
     */
    omit?: SalaryConfigOmit<ExtArgs> | null
    /**
     * The data used to update SalaryConfigs.
     */
    data: XOR<SalaryConfigUpdateManyMutationInput, SalaryConfigUncheckedUpdateManyInput>
    /**
     * Filter which SalaryConfigs to update
     */
    where?: SalaryConfigWhereInput
    /**
     * Limit how many SalaryConfigs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryConfigIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalaryConfig upsert
   */
  export type SalaryConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryConfig
     */
    select?: SalaryConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryConfig
     */
    omit?: SalaryConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the SalaryConfig to update in case it exists.
     */
    where: SalaryConfigWhereUniqueInput
    /**
     * In case the SalaryConfig found by the `where` argument doesn't exist, create a new SalaryConfig with this data.
     */
    create: XOR<SalaryConfigCreateInput, SalaryConfigUncheckedCreateInput>
    /**
     * In case the SalaryConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalaryConfigUpdateInput, SalaryConfigUncheckedUpdateInput>
  }

  /**
   * SalaryConfig delete
   */
  export type SalaryConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryConfig
     */
    select?: SalaryConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryConfig
     */
    omit?: SalaryConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryConfigInclude<ExtArgs> | null
    /**
     * Filter which SalaryConfig to delete.
     */
    where: SalaryConfigWhereUniqueInput
  }

  /**
   * SalaryConfig deleteMany
   */
  export type SalaryConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryConfigs to delete
     */
    where?: SalaryConfigWhereInput
    /**
     * Limit how many SalaryConfigs to delete.
     */
    limit?: number
  }

  /**
   * SalaryConfig without action
   */
  export type SalaryConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryConfig
     */
    select?: SalaryConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryConfig
     */
    omit?: SalaryConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryConfigInclude<ExtArgs> | null
  }


  /**
   * Model SalaryRecord
   */

  export type AggregateSalaryRecord = {
    _count: SalaryRecordCountAggregateOutputType | null
    _avg: SalaryRecordAvgAggregateOutputType | null
    _sum: SalaryRecordSumAggregateOutputType | null
    _min: SalaryRecordMinAggregateOutputType | null
    _max: SalaryRecordMaxAggregateOutputType | null
  }

  export type SalaryRecordAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    month: number | null
    year: number | null
    basicSalary: number | null
    totalLeave: number | null
    leaveDeductions: number | null
    overtimePay: number | null
    netSalary: number | null
  }

  export type SalaryRecordSumAggregateOutputType = {
    id: number | null
    userId: number | null
    month: number | null
    year: number | null
    basicSalary: number | null
    totalLeave: number | null
    leaveDeductions: number | null
    overtimePay: number | null
    netSalary: number | null
  }

  export type SalaryRecordMinAggregateOutputType = {
    id: number | null
    userId: number | null
    month: number | null
    year: number | null
    basicSalary: number | null
    totalLeave: number | null
    leaveDeductions: number | null
    overtimePay: number | null
    netSalary: number | null
    generatedAt: Date | null
  }

  export type SalaryRecordMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    month: number | null
    year: number | null
    basicSalary: number | null
    totalLeave: number | null
    leaveDeductions: number | null
    overtimePay: number | null
    netSalary: number | null
    generatedAt: Date | null
  }

  export type SalaryRecordCountAggregateOutputType = {
    id: number
    userId: number
    month: number
    year: number
    basicSalary: number
    totalLeave: number
    leaveDeductions: number
    overtimePay: number
    netSalary: number
    generatedAt: number
    _all: number
  }


  export type SalaryRecordAvgAggregateInputType = {
    id?: true
    userId?: true
    month?: true
    year?: true
    basicSalary?: true
    totalLeave?: true
    leaveDeductions?: true
    overtimePay?: true
    netSalary?: true
  }

  export type SalaryRecordSumAggregateInputType = {
    id?: true
    userId?: true
    month?: true
    year?: true
    basicSalary?: true
    totalLeave?: true
    leaveDeductions?: true
    overtimePay?: true
    netSalary?: true
  }

  export type SalaryRecordMinAggregateInputType = {
    id?: true
    userId?: true
    month?: true
    year?: true
    basicSalary?: true
    totalLeave?: true
    leaveDeductions?: true
    overtimePay?: true
    netSalary?: true
    generatedAt?: true
  }

  export type SalaryRecordMaxAggregateInputType = {
    id?: true
    userId?: true
    month?: true
    year?: true
    basicSalary?: true
    totalLeave?: true
    leaveDeductions?: true
    overtimePay?: true
    netSalary?: true
    generatedAt?: true
  }

  export type SalaryRecordCountAggregateInputType = {
    id?: true
    userId?: true
    month?: true
    year?: true
    basicSalary?: true
    totalLeave?: true
    leaveDeductions?: true
    overtimePay?: true
    netSalary?: true
    generatedAt?: true
    _all?: true
  }

  export type SalaryRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryRecord to aggregate.
     */
    where?: SalaryRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryRecords to fetch.
     */
    orderBy?: SalaryRecordOrderByWithRelationInput | SalaryRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalaryRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalaryRecords
    **/
    _count?: true | SalaryRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalaryRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalaryRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalaryRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalaryRecordMaxAggregateInputType
  }

  export type GetSalaryRecordAggregateType<T extends SalaryRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateSalaryRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalaryRecord[P]>
      : GetScalarType<T[P], AggregateSalaryRecord[P]>
  }




  export type SalaryRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryRecordWhereInput
    orderBy?: SalaryRecordOrderByWithAggregationInput | SalaryRecordOrderByWithAggregationInput[]
    by: SalaryRecordScalarFieldEnum[] | SalaryRecordScalarFieldEnum
    having?: SalaryRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalaryRecordCountAggregateInputType | true
    _avg?: SalaryRecordAvgAggregateInputType
    _sum?: SalaryRecordSumAggregateInputType
    _min?: SalaryRecordMinAggregateInputType
    _max?: SalaryRecordMaxAggregateInputType
  }

  export type SalaryRecordGroupByOutputType = {
    id: number
    userId: number
    month: number
    year: number
    basicSalary: number
    totalLeave: number
    leaveDeductions: number
    overtimePay: number
    netSalary: number
    generatedAt: Date
    _count: SalaryRecordCountAggregateOutputType | null
    _avg: SalaryRecordAvgAggregateOutputType | null
    _sum: SalaryRecordSumAggregateOutputType | null
    _min: SalaryRecordMinAggregateOutputType | null
    _max: SalaryRecordMaxAggregateOutputType | null
  }

  type GetSalaryRecordGroupByPayload<T extends SalaryRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalaryRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalaryRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalaryRecordGroupByOutputType[P]>
            : GetScalarType<T[P], SalaryRecordGroupByOutputType[P]>
        }
      >
    >


  export type SalaryRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    month?: boolean
    year?: boolean
    basicSalary?: boolean
    totalLeave?: boolean
    leaveDeductions?: boolean
    overtimePay?: boolean
    netSalary?: boolean
    generatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryRecord"]>

  export type SalaryRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    month?: boolean
    year?: boolean
    basicSalary?: boolean
    totalLeave?: boolean
    leaveDeductions?: boolean
    overtimePay?: boolean
    netSalary?: boolean
    generatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryRecord"]>

  export type SalaryRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    month?: boolean
    year?: boolean
    basicSalary?: boolean
    totalLeave?: boolean
    leaveDeductions?: boolean
    overtimePay?: boolean
    netSalary?: boolean
    generatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryRecord"]>

  export type SalaryRecordSelectScalar = {
    id?: boolean
    userId?: boolean
    month?: boolean
    year?: boolean
    basicSalary?: boolean
    totalLeave?: boolean
    leaveDeductions?: boolean
    overtimePay?: boolean
    netSalary?: boolean
    generatedAt?: boolean
  }

  export type SalaryRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "month" | "year" | "basicSalary" | "totalLeave" | "leaveDeductions" | "overtimePay" | "netSalary" | "generatedAt", ExtArgs["result"]["salaryRecord"]>
  export type SalaryRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SalaryRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SalaryRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SalaryRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalaryRecord"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      month: number
      year: number
      basicSalary: number
      totalLeave: number
      leaveDeductions: number
      overtimePay: number
      netSalary: number
      generatedAt: Date
    }, ExtArgs["result"]["salaryRecord"]>
    composites: {}
  }

  type SalaryRecordGetPayload<S extends boolean | null | undefined | SalaryRecordDefaultArgs> = $Result.GetResult<Prisma.$SalaryRecordPayload, S>

  type SalaryRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalaryRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalaryRecordCountAggregateInputType | true
    }

  export interface SalaryRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalaryRecord'], meta: { name: 'SalaryRecord' } }
    /**
     * Find zero or one SalaryRecord that matches the filter.
     * @param {SalaryRecordFindUniqueArgs} args - Arguments to find a SalaryRecord
     * @example
     * // Get one SalaryRecord
     * const salaryRecord = await prisma.salaryRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalaryRecordFindUniqueArgs>(args: SelectSubset<T, SalaryRecordFindUniqueArgs<ExtArgs>>): Prisma__SalaryRecordClient<$Result.GetResult<Prisma.$SalaryRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalaryRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalaryRecordFindUniqueOrThrowArgs} args - Arguments to find a SalaryRecord
     * @example
     * // Get one SalaryRecord
     * const salaryRecord = await prisma.salaryRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalaryRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, SalaryRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalaryRecordClient<$Result.GetResult<Prisma.$SalaryRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalaryRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryRecordFindFirstArgs} args - Arguments to find a SalaryRecord
     * @example
     * // Get one SalaryRecord
     * const salaryRecord = await prisma.salaryRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalaryRecordFindFirstArgs>(args?: SelectSubset<T, SalaryRecordFindFirstArgs<ExtArgs>>): Prisma__SalaryRecordClient<$Result.GetResult<Prisma.$SalaryRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalaryRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryRecordFindFirstOrThrowArgs} args - Arguments to find a SalaryRecord
     * @example
     * // Get one SalaryRecord
     * const salaryRecord = await prisma.salaryRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalaryRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, SalaryRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalaryRecordClient<$Result.GetResult<Prisma.$SalaryRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalaryRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalaryRecords
     * const salaryRecords = await prisma.salaryRecord.findMany()
     * 
     * // Get first 10 SalaryRecords
     * const salaryRecords = await prisma.salaryRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salaryRecordWithIdOnly = await prisma.salaryRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalaryRecordFindManyArgs>(args?: SelectSubset<T, SalaryRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalaryRecord.
     * @param {SalaryRecordCreateArgs} args - Arguments to create a SalaryRecord.
     * @example
     * // Create one SalaryRecord
     * const SalaryRecord = await prisma.salaryRecord.create({
     *   data: {
     *     // ... data to create a SalaryRecord
     *   }
     * })
     * 
     */
    create<T extends SalaryRecordCreateArgs>(args: SelectSubset<T, SalaryRecordCreateArgs<ExtArgs>>): Prisma__SalaryRecordClient<$Result.GetResult<Prisma.$SalaryRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalaryRecords.
     * @param {SalaryRecordCreateManyArgs} args - Arguments to create many SalaryRecords.
     * @example
     * // Create many SalaryRecords
     * const salaryRecord = await prisma.salaryRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalaryRecordCreateManyArgs>(args?: SelectSubset<T, SalaryRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalaryRecords and returns the data saved in the database.
     * @param {SalaryRecordCreateManyAndReturnArgs} args - Arguments to create many SalaryRecords.
     * @example
     * // Create many SalaryRecords
     * const salaryRecord = await prisma.salaryRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalaryRecords and only return the `id`
     * const salaryRecordWithIdOnly = await prisma.salaryRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalaryRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, SalaryRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalaryRecord.
     * @param {SalaryRecordDeleteArgs} args - Arguments to delete one SalaryRecord.
     * @example
     * // Delete one SalaryRecord
     * const SalaryRecord = await prisma.salaryRecord.delete({
     *   where: {
     *     // ... filter to delete one SalaryRecord
     *   }
     * })
     * 
     */
    delete<T extends SalaryRecordDeleteArgs>(args: SelectSubset<T, SalaryRecordDeleteArgs<ExtArgs>>): Prisma__SalaryRecordClient<$Result.GetResult<Prisma.$SalaryRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalaryRecord.
     * @param {SalaryRecordUpdateArgs} args - Arguments to update one SalaryRecord.
     * @example
     * // Update one SalaryRecord
     * const salaryRecord = await prisma.salaryRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalaryRecordUpdateArgs>(args: SelectSubset<T, SalaryRecordUpdateArgs<ExtArgs>>): Prisma__SalaryRecordClient<$Result.GetResult<Prisma.$SalaryRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalaryRecords.
     * @param {SalaryRecordDeleteManyArgs} args - Arguments to filter SalaryRecords to delete.
     * @example
     * // Delete a few SalaryRecords
     * const { count } = await prisma.salaryRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalaryRecordDeleteManyArgs>(args?: SelectSubset<T, SalaryRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalaryRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalaryRecords
     * const salaryRecord = await prisma.salaryRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalaryRecordUpdateManyArgs>(args: SelectSubset<T, SalaryRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalaryRecords and returns the data updated in the database.
     * @param {SalaryRecordUpdateManyAndReturnArgs} args - Arguments to update many SalaryRecords.
     * @example
     * // Update many SalaryRecords
     * const salaryRecord = await prisma.salaryRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalaryRecords and only return the `id`
     * const salaryRecordWithIdOnly = await prisma.salaryRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalaryRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, SalaryRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalaryRecord.
     * @param {SalaryRecordUpsertArgs} args - Arguments to update or create a SalaryRecord.
     * @example
     * // Update or create a SalaryRecord
     * const salaryRecord = await prisma.salaryRecord.upsert({
     *   create: {
     *     // ... data to create a SalaryRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalaryRecord we want to update
     *   }
     * })
     */
    upsert<T extends SalaryRecordUpsertArgs>(args: SelectSubset<T, SalaryRecordUpsertArgs<ExtArgs>>): Prisma__SalaryRecordClient<$Result.GetResult<Prisma.$SalaryRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalaryRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryRecordCountArgs} args - Arguments to filter SalaryRecords to count.
     * @example
     * // Count the number of SalaryRecords
     * const count = await prisma.salaryRecord.count({
     *   where: {
     *     // ... the filter for the SalaryRecords we want to count
     *   }
     * })
    **/
    count<T extends SalaryRecordCountArgs>(
      args?: Subset<T, SalaryRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalaryRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalaryRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalaryRecordAggregateArgs>(args: Subset<T, SalaryRecordAggregateArgs>): Prisma.PrismaPromise<GetSalaryRecordAggregateType<T>>

    /**
     * Group by SalaryRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalaryRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalaryRecordGroupByArgs['orderBy'] }
        : { orderBy?: SalaryRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalaryRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalaryRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalaryRecord model
   */
  readonly fields: SalaryRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalaryRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalaryRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalaryRecord model
   */
  interface SalaryRecordFieldRefs {
    readonly id: FieldRef<"SalaryRecord", 'Int'>
    readonly userId: FieldRef<"SalaryRecord", 'Int'>
    readonly month: FieldRef<"SalaryRecord", 'Int'>
    readonly year: FieldRef<"SalaryRecord", 'Int'>
    readonly basicSalary: FieldRef<"SalaryRecord", 'Float'>
    readonly totalLeave: FieldRef<"SalaryRecord", 'Int'>
    readonly leaveDeductions: FieldRef<"SalaryRecord", 'Float'>
    readonly overtimePay: FieldRef<"SalaryRecord", 'Float'>
    readonly netSalary: FieldRef<"SalaryRecord", 'Float'>
    readonly generatedAt: FieldRef<"SalaryRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalaryRecord findUnique
   */
  export type SalaryRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRecord
     */
    select?: SalaryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryRecord
     */
    omit?: SalaryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRecordInclude<ExtArgs> | null
    /**
     * Filter, which SalaryRecord to fetch.
     */
    where: SalaryRecordWhereUniqueInput
  }

  /**
   * SalaryRecord findUniqueOrThrow
   */
  export type SalaryRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRecord
     */
    select?: SalaryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryRecord
     */
    omit?: SalaryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRecordInclude<ExtArgs> | null
    /**
     * Filter, which SalaryRecord to fetch.
     */
    where: SalaryRecordWhereUniqueInput
  }

  /**
   * SalaryRecord findFirst
   */
  export type SalaryRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRecord
     */
    select?: SalaryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryRecord
     */
    omit?: SalaryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRecordInclude<ExtArgs> | null
    /**
     * Filter, which SalaryRecord to fetch.
     */
    where?: SalaryRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryRecords to fetch.
     */
    orderBy?: SalaryRecordOrderByWithRelationInput | SalaryRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryRecords.
     */
    cursor?: SalaryRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryRecords.
     */
    distinct?: SalaryRecordScalarFieldEnum | SalaryRecordScalarFieldEnum[]
  }

  /**
   * SalaryRecord findFirstOrThrow
   */
  export type SalaryRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRecord
     */
    select?: SalaryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryRecord
     */
    omit?: SalaryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRecordInclude<ExtArgs> | null
    /**
     * Filter, which SalaryRecord to fetch.
     */
    where?: SalaryRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryRecords to fetch.
     */
    orderBy?: SalaryRecordOrderByWithRelationInput | SalaryRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryRecords.
     */
    cursor?: SalaryRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryRecords.
     */
    distinct?: SalaryRecordScalarFieldEnum | SalaryRecordScalarFieldEnum[]
  }

  /**
   * SalaryRecord findMany
   */
  export type SalaryRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRecord
     */
    select?: SalaryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryRecord
     */
    omit?: SalaryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRecordInclude<ExtArgs> | null
    /**
     * Filter, which SalaryRecords to fetch.
     */
    where?: SalaryRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryRecords to fetch.
     */
    orderBy?: SalaryRecordOrderByWithRelationInput | SalaryRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalaryRecords.
     */
    cursor?: SalaryRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryRecords.
     */
    skip?: number
    distinct?: SalaryRecordScalarFieldEnum | SalaryRecordScalarFieldEnum[]
  }

  /**
   * SalaryRecord create
   */
  export type SalaryRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRecord
     */
    select?: SalaryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryRecord
     */
    omit?: SalaryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a SalaryRecord.
     */
    data: XOR<SalaryRecordCreateInput, SalaryRecordUncheckedCreateInput>
  }

  /**
   * SalaryRecord createMany
   */
  export type SalaryRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalaryRecords.
     */
    data: SalaryRecordCreateManyInput | SalaryRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalaryRecord createManyAndReturn
   */
  export type SalaryRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRecord
     */
    select?: SalaryRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryRecord
     */
    omit?: SalaryRecordOmit<ExtArgs> | null
    /**
     * The data used to create many SalaryRecords.
     */
    data: SalaryRecordCreateManyInput | SalaryRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalaryRecord update
   */
  export type SalaryRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRecord
     */
    select?: SalaryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryRecord
     */
    omit?: SalaryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a SalaryRecord.
     */
    data: XOR<SalaryRecordUpdateInput, SalaryRecordUncheckedUpdateInput>
    /**
     * Choose, which SalaryRecord to update.
     */
    where: SalaryRecordWhereUniqueInput
  }

  /**
   * SalaryRecord updateMany
   */
  export type SalaryRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalaryRecords.
     */
    data: XOR<SalaryRecordUpdateManyMutationInput, SalaryRecordUncheckedUpdateManyInput>
    /**
     * Filter which SalaryRecords to update
     */
    where?: SalaryRecordWhereInput
    /**
     * Limit how many SalaryRecords to update.
     */
    limit?: number
  }

  /**
   * SalaryRecord updateManyAndReturn
   */
  export type SalaryRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRecord
     */
    select?: SalaryRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryRecord
     */
    omit?: SalaryRecordOmit<ExtArgs> | null
    /**
     * The data used to update SalaryRecords.
     */
    data: XOR<SalaryRecordUpdateManyMutationInput, SalaryRecordUncheckedUpdateManyInput>
    /**
     * Filter which SalaryRecords to update
     */
    where?: SalaryRecordWhereInput
    /**
     * Limit how many SalaryRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalaryRecord upsert
   */
  export type SalaryRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRecord
     */
    select?: SalaryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryRecord
     */
    omit?: SalaryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the SalaryRecord to update in case it exists.
     */
    where: SalaryRecordWhereUniqueInput
    /**
     * In case the SalaryRecord found by the `where` argument doesn't exist, create a new SalaryRecord with this data.
     */
    create: XOR<SalaryRecordCreateInput, SalaryRecordUncheckedCreateInput>
    /**
     * In case the SalaryRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalaryRecordUpdateInput, SalaryRecordUncheckedUpdateInput>
  }

  /**
   * SalaryRecord delete
   */
  export type SalaryRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRecord
     */
    select?: SalaryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryRecord
     */
    omit?: SalaryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRecordInclude<ExtArgs> | null
    /**
     * Filter which SalaryRecord to delete.
     */
    where: SalaryRecordWhereUniqueInput
  }

  /**
   * SalaryRecord deleteMany
   */
  export type SalaryRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryRecords to delete
     */
    where?: SalaryRecordWhereInput
    /**
     * Limit how many SalaryRecords to delete.
     */
    limit?: number
  }

  /**
   * SalaryRecord without action
   */
  export type SalaryRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRecord
     */
    select?: SalaryRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryRecord
     */
    omit?: SalaryRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRecordInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    isAdmin: 'isAdmin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    refreshToken: 'refreshToken',
    employeeId: 'employeeId',
    cardNumber: 'cardNumber',
    validFrom: 'validFrom',
    validTo: 'validTo',
    epfNo: 'epfNo',
    nic: 'nic',
    jobPosition: 'jobPosition',
    imagePath: 'imagePath',
    active: 'active',
    joinDate: 'joinDate',
    address: 'address'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const Leave_requestScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    approvedBy: 'approvedBy',
    leaveType: 'leaveType',
    status: 'status',
    reason: 'reason',
    requestedAt: 'requestedAt',
    approvedAt: 'approvedAt',
    rejectedAt: 'rejectedAt'
  };

  export type Leave_requestScalarFieldEnum = (typeof Leave_requestScalarFieldEnum)[keyof typeof Leave_requestScalarFieldEnum]


  export const Leave_request_dateScalarFieldEnum: {
    id: 'id',
    requestId: 'requestId',
    leaveDate: 'leaveDate',
    isHalfDay: 'isHalfDay',
    halfdayType: 'halfdayType'
  };

  export type Leave_request_dateScalarFieldEnum = (typeof Leave_request_dateScalarFieldEnum)[keyof typeof Leave_request_dateScalarFieldEnum]


  export const Leave_balanceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    year: 'year',
    leaveType: 'leaveType',
    balance: 'balance'
  };

  export type Leave_balanceScalarFieldEnum = (typeof Leave_balanceScalarFieldEnum)[keyof typeof Leave_balanceScalarFieldEnum]


  export const Leave_policyScalarFieldEnum: {
    leaveType: 'leaveType',
    defaultBalance: 'defaultBalance'
  };

  export type Leave_policyScalarFieldEnum = (typeof Leave_policyScalarFieldEnum)[keyof typeof Leave_policyScalarFieldEnum]


  export const SyncHistoryScalarFieldEnum: {
    id: 'id',
    syncTime: 'syncTime',
    totalUsers: 'totalUsers',
    newUsers: 'newUsers',
    updatedUsers: 'updatedUsers',
    status: 'status'
  };

  export type SyncHistoryScalarFieldEnum = (typeof SyncHistoryScalarFieldEnum)[keyof typeof SyncHistoryScalarFieldEnum]


  export const PunchScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    eventTime: 'eventTime',
    correctEventTime: 'correctEventTime',
    direction: 'direction',
    source: 'source',
    note: 'note',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt',
    directionCorrected: 'directionCorrected',
    originalDirection: 'originalDirection',
    correctedBy: 'correctedBy',
    correctionNote: 'correctionNote',
    correctedAt: 'correctedAt'
  };

  export type PunchScalarFieldEnum = (typeof PunchScalarFieldEnum)[keyof typeof PunchScalarFieldEnum]


  export const AttendanceDayScalarFieldEnum: {
    employeeId: 'employeeId',
    workDate: 'workDate',
    startTime: 'startTime',
    firstIn: 'firstIn',
    lastOut: 'lastOut',
    workedSeconds: 'workedSeconds',
    notWorkingSeconds: 'notWorkingSeconds',
    overtimeSeconds: 'overtimeSeconds',
    hadManual: 'hadManual',
    status: 'status',
    calculatedAt: 'calculatedAt'
  };

  export type AttendanceDayScalarFieldEnum = (typeof AttendanceDayScalarFieldEnum)[keyof typeof AttendanceDayScalarFieldEnum]


  export const DeviceConfigScalarFieldEnum: {
    id: 'id',
    ip: 'ip',
    username: 'username',
    passwordEnc: 'passwordEnc',
    lastEventTime: 'lastEventTime',
    authFailedAt: 'authFailedAt',
    authFailureCount: 'authFailureCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeviceConfigScalarFieldEnum = (typeof DeviceConfigScalarFieldEnum)[keyof typeof DeviceConfigScalarFieldEnum]


  export const AttendanceConfigScalarFieldEnum: {
    id: 'id',
    workStart: 'workStart',
    workEnd: 'workEnd',
    otEnd: 'otEnd',
    earlyStart: 'earlyStart',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttendanceConfigScalarFieldEnum = (typeof AttendanceConfigScalarFieldEnum)[keyof typeof AttendanceConfigScalarFieldEnum]


  export const SalaryConfigScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    basicSalary: 'basicSalary',
    otRate: 'otRate',
    allowance: 'allowance',
    deduction: 'deduction',
    effectiveFrom: 'effectiveFrom'
  };

  export type SalaryConfigScalarFieldEnum = (typeof SalaryConfigScalarFieldEnum)[keyof typeof SalaryConfigScalarFieldEnum]


  export const SalaryRecordScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    month: 'month',
    year: 'year',
    basicSalary: 'basicSalary',
    totalLeave: 'totalLeave',
    leaveDeductions: 'leaveDeductions',
    overtimePay: 'overtimePay',
    netSalary: 'netSalary',
    generatedAt: 'generatedAt'
  };

  export type SalaryRecordScalarFieldEnum = (typeof SalaryRecordScalarFieldEnum)[keyof typeof SalaryRecordScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'LeaveType'
   */
  export type EnumLeaveTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveType'>
    


  /**
   * Reference to a field of type 'LeaveType[]'
   */
  export type ListEnumLeaveTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveType[]'>
    


  /**
   * Reference to a field of type 'LeaveStatus'
   */
  export type EnumLeaveStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveStatus'>
    


  /**
   * Reference to a field of type 'LeaveStatus[]'
   */
  export type ListEnumLeaveStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveStatus[]'>
    


  /**
   * Reference to a field of type 'HalfdayType'
   */
  export type EnumHalfdayTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HalfdayType'>
    


  /**
   * Reference to a field of type 'HalfdayType[]'
   */
  export type ListEnumHalfdayTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HalfdayType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Direction'
   */
  export type EnumDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Direction'>
    


  /**
   * Reference to a field of type 'Direction[]'
   */
  export type ListEnumDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Direction[]'>
    


  /**
   * Reference to a field of type 'Source'
   */
  export type EnumSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Source'>
    


  /**
   * Reference to a field of type 'Source[]'
   */
  export type ListEnumSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Source[]'>
    


  /**
   * Reference to a field of type 'AttendanceStatus'
   */
  export type EnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus'>
    


  /**
   * Reference to a field of type 'AttendanceStatus[]'
   */
  export type ListEnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    isAdmin?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    refreshToken?: StringNullableFilter<"User"> | string | null
    employeeId?: StringNullableFilter<"User"> | string | null
    cardNumber?: StringNullableFilter<"User"> | string | null
    validFrom?: DateTimeNullableFilter<"User"> | Date | string | null
    validTo?: DateTimeNullableFilter<"User"> | Date | string | null
    epfNo?: StringNullableFilter<"User"> | string | null
    nic?: StringNullableFilter<"User"> | string | null
    jobPosition?: StringNullableFilter<"User"> | string | null
    imagePath?: StringNullableFilter<"User"> | string | null
    active?: BoolFilter<"User"> | boolean
    joinDate?: DateTimeNullableFilter<"User"> | Date | string | null
    address?: StringNullableFilter<"User"> | string | null
    leaveRequests?: Leave_requestListRelationFilter
    approvedRequests?: Leave_requestListRelationFilter
    leaveBalances?: Leave_balanceListRelationFilter
    punches?: PunchListRelationFilter
    attendanceDays?: AttendanceDayListRelationFilter
    salaryConfigs?: SalaryConfigListRelationFilter
    salaryRecords?: SalaryRecordListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    employeeId?: SortOrderInput | SortOrder
    cardNumber?: SortOrderInput | SortOrder
    validFrom?: SortOrderInput | SortOrder
    validTo?: SortOrderInput | SortOrder
    epfNo?: SortOrderInput | SortOrder
    nic?: SortOrderInput | SortOrder
    jobPosition?: SortOrderInput | SortOrder
    imagePath?: SortOrderInput | SortOrder
    active?: SortOrder
    joinDate?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    leaveRequests?: Leave_requestOrderByRelationAggregateInput
    approvedRequests?: Leave_requestOrderByRelationAggregateInput
    leaveBalances?: Leave_balanceOrderByRelationAggregateInput
    punches?: PunchOrderByRelationAggregateInput
    attendanceDays?: AttendanceDayOrderByRelationAggregateInput
    salaryConfigs?: SalaryConfigOrderByRelationAggregateInput
    salaryRecords?: SalaryRecordOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    employeeId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    isAdmin?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    refreshToken?: StringNullableFilter<"User"> | string | null
    cardNumber?: StringNullableFilter<"User"> | string | null
    validFrom?: DateTimeNullableFilter<"User"> | Date | string | null
    validTo?: DateTimeNullableFilter<"User"> | Date | string | null
    epfNo?: StringNullableFilter<"User"> | string | null
    nic?: StringNullableFilter<"User"> | string | null
    jobPosition?: StringNullableFilter<"User"> | string | null
    imagePath?: StringNullableFilter<"User"> | string | null
    active?: BoolFilter<"User"> | boolean
    joinDate?: DateTimeNullableFilter<"User"> | Date | string | null
    address?: StringNullableFilter<"User"> | string | null
    leaveRequests?: Leave_requestListRelationFilter
    approvedRequests?: Leave_requestListRelationFilter
    leaveBalances?: Leave_balanceListRelationFilter
    punches?: PunchListRelationFilter
    attendanceDays?: AttendanceDayListRelationFilter
    salaryConfigs?: SalaryConfigListRelationFilter
    salaryRecords?: SalaryRecordListRelationFilter
  }, "id" | "email" | "employeeId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    employeeId?: SortOrderInput | SortOrder
    cardNumber?: SortOrderInput | SortOrder
    validFrom?: SortOrderInput | SortOrder
    validTo?: SortOrderInput | SortOrder
    epfNo?: SortOrderInput | SortOrder
    nic?: SortOrderInput | SortOrder
    jobPosition?: SortOrderInput | SortOrder
    imagePath?: SortOrderInput | SortOrder
    active?: SortOrder
    joinDate?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    isAdmin?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    refreshToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    employeeId?: StringNullableWithAggregatesFilter<"User"> | string | null
    cardNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    validFrom?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    validTo?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    epfNo?: StringNullableWithAggregatesFilter<"User"> | string | null
    nic?: StringNullableWithAggregatesFilter<"User"> | string | null
    jobPosition?: StringNullableWithAggregatesFilter<"User"> | string | null
    imagePath?: StringNullableWithAggregatesFilter<"User"> | string | null
    active?: BoolWithAggregatesFilter<"User"> | boolean
    joinDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type Leave_requestWhereInput = {
    AND?: Leave_requestWhereInput | Leave_requestWhereInput[]
    OR?: Leave_requestWhereInput[]
    NOT?: Leave_requestWhereInput | Leave_requestWhereInput[]
    id?: IntFilter<"Leave_request"> | number
    userId?: IntFilter<"Leave_request"> | number
    approvedBy?: IntNullableFilter<"Leave_request"> | number | null
    leaveType?: EnumLeaveTypeFilter<"Leave_request"> | $Enums.LeaveType
    status?: EnumLeaveStatusNullableFilter<"Leave_request"> | $Enums.LeaveStatus | null
    reason?: StringNullableFilter<"Leave_request"> | string | null
    requestedAt?: DateTimeFilter<"Leave_request"> | Date | string
    approvedAt?: DateTimeNullableFilter<"Leave_request"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"Leave_request"> | Date | string | null
    dates?: Leave_request_dateListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    approvedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type Leave_requestOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    leaveType?: SortOrder
    status?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    dates?: Leave_request_dateOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    approvedByUser?: UserOrderByWithRelationInput
  }

  export type Leave_requestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: Leave_requestWhereInput | Leave_requestWhereInput[]
    OR?: Leave_requestWhereInput[]
    NOT?: Leave_requestWhereInput | Leave_requestWhereInput[]
    userId?: IntFilter<"Leave_request"> | number
    approvedBy?: IntNullableFilter<"Leave_request"> | number | null
    leaveType?: EnumLeaveTypeFilter<"Leave_request"> | $Enums.LeaveType
    status?: EnumLeaveStatusNullableFilter<"Leave_request"> | $Enums.LeaveStatus | null
    reason?: StringNullableFilter<"Leave_request"> | string | null
    requestedAt?: DateTimeFilter<"Leave_request"> | Date | string
    approvedAt?: DateTimeNullableFilter<"Leave_request"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"Leave_request"> | Date | string | null
    dates?: Leave_request_dateListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    approvedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type Leave_requestOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    leaveType?: SortOrder
    status?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    _count?: Leave_requestCountOrderByAggregateInput
    _avg?: Leave_requestAvgOrderByAggregateInput
    _max?: Leave_requestMaxOrderByAggregateInput
    _min?: Leave_requestMinOrderByAggregateInput
    _sum?: Leave_requestSumOrderByAggregateInput
  }

  export type Leave_requestScalarWhereWithAggregatesInput = {
    AND?: Leave_requestScalarWhereWithAggregatesInput | Leave_requestScalarWhereWithAggregatesInput[]
    OR?: Leave_requestScalarWhereWithAggregatesInput[]
    NOT?: Leave_requestScalarWhereWithAggregatesInput | Leave_requestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Leave_request"> | number
    userId?: IntWithAggregatesFilter<"Leave_request"> | number
    approvedBy?: IntNullableWithAggregatesFilter<"Leave_request"> | number | null
    leaveType?: EnumLeaveTypeWithAggregatesFilter<"Leave_request"> | $Enums.LeaveType
    status?: EnumLeaveStatusNullableWithAggregatesFilter<"Leave_request"> | $Enums.LeaveStatus | null
    reason?: StringNullableWithAggregatesFilter<"Leave_request"> | string | null
    requestedAt?: DateTimeWithAggregatesFilter<"Leave_request"> | Date | string
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Leave_request"> | Date | string | null
    rejectedAt?: DateTimeNullableWithAggregatesFilter<"Leave_request"> | Date | string | null
  }

  export type Leave_request_dateWhereInput = {
    AND?: Leave_request_dateWhereInput | Leave_request_dateWhereInput[]
    OR?: Leave_request_dateWhereInput[]
    NOT?: Leave_request_dateWhereInput | Leave_request_dateWhereInput[]
    id?: IntFilter<"Leave_request_date"> | number
    requestId?: IntFilter<"Leave_request_date"> | number
    leaveDate?: DateTimeFilter<"Leave_request_date"> | Date | string
    isHalfDay?: BoolFilter<"Leave_request_date"> | boolean
    halfdayType?: EnumHalfdayTypeNullableFilter<"Leave_request_date"> | $Enums.HalfdayType | null
    request?: XOR<Leave_requestScalarRelationFilter, Leave_requestWhereInput>
  }

  export type Leave_request_dateOrderByWithRelationInput = {
    id?: SortOrder
    requestId?: SortOrder
    leaveDate?: SortOrder
    isHalfDay?: SortOrder
    halfdayType?: SortOrderInput | SortOrder
    request?: Leave_requestOrderByWithRelationInput
  }

  export type Leave_request_dateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: Leave_request_dateWhereInput | Leave_request_dateWhereInput[]
    OR?: Leave_request_dateWhereInput[]
    NOT?: Leave_request_dateWhereInput | Leave_request_dateWhereInput[]
    requestId?: IntFilter<"Leave_request_date"> | number
    leaveDate?: DateTimeFilter<"Leave_request_date"> | Date | string
    isHalfDay?: BoolFilter<"Leave_request_date"> | boolean
    halfdayType?: EnumHalfdayTypeNullableFilter<"Leave_request_date"> | $Enums.HalfdayType | null
    request?: XOR<Leave_requestScalarRelationFilter, Leave_requestWhereInput>
  }, "id">

  export type Leave_request_dateOrderByWithAggregationInput = {
    id?: SortOrder
    requestId?: SortOrder
    leaveDate?: SortOrder
    isHalfDay?: SortOrder
    halfdayType?: SortOrderInput | SortOrder
    _count?: Leave_request_dateCountOrderByAggregateInput
    _avg?: Leave_request_dateAvgOrderByAggregateInput
    _max?: Leave_request_dateMaxOrderByAggregateInput
    _min?: Leave_request_dateMinOrderByAggregateInput
    _sum?: Leave_request_dateSumOrderByAggregateInput
  }

  export type Leave_request_dateScalarWhereWithAggregatesInput = {
    AND?: Leave_request_dateScalarWhereWithAggregatesInput | Leave_request_dateScalarWhereWithAggregatesInput[]
    OR?: Leave_request_dateScalarWhereWithAggregatesInput[]
    NOT?: Leave_request_dateScalarWhereWithAggregatesInput | Leave_request_dateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Leave_request_date"> | number
    requestId?: IntWithAggregatesFilter<"Leave_request_date"> | number
    leaveDate?: DateTimeWithAggregatesFilter<"Leave_request_date"> | Date | string
    isHalfDay?: BoolWithAggregatesFilter<"Leave_request_date"> | boolean
    halfdayType?: EnumHalfdayTypeNullableWithAggregatesFilter<"Leave_request_date"> | $Enums.HalfdayType | null
  }

  export type Leave_balanceWhereInput = {
    AND?: Leave_balanceWhereInput | Leave_balanceWhereInput[]
    OR?: Leave_balanceWhereInput[]
    NOT?: Leave_balanceWhereInput | Leave_balanceWhereInput[]
    id?: IntFilter<"Leave_balance"> | number
    userId?: IntFilter<"Leave_balance"> | number
    year?: IntFilter<"Leave_balance"> | number
    leaveType?: EnumLeaveTypeFilter<"Leave_balance"> | $Enums.LeaveType
    balance?: FloatFilter<"Leave_balance"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type Leave_balanceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    leaveType?: SortOrder
    balance?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type Leave_balanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_year_leaveType?: Leave_balanceUserIdYearLeaveTypeCompoundUniqueInput
    AND?: Leave_balanceWhereInput | Leave_balanceWhereInput[]
    OR?: Leave_balanceWhereInput[]
    NOT?: Leave_balanceWhereInput | Leave_balanceWhereInput[]
    userId?: IntFilter<"Leave_balance"> | number
    year?: IntFilter<"Leave_balance"> | number
    leaveType?: EnumLeaveTypeFilter<"Leave_balance"> | $Enums.LeaveType
    balance?: FloatFilter<"Leave_balance"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_year_leaveType">

  export type Leave_balanceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    leaveType?: SortOrder
    balance?: SortOrder
    _count?: Leave_balanceCountOrderByAggregateInput
    _avg?: Leave_balanceAvgOrderByAggregateInput
    _max?: Leave_balanceMaxOrderByAggregateInput
    _min?: Leave_balanceMinOrderByAggregateInput
    _sum?: Leave_balanceSumOrderByAggregateInput
  }

  export type Leave_balanceScalarWhereWithAggregatesInput = {
    AND?: Leave_balanceScalarWhereWithAggregatesInput | Leave_balanceScalarWhereWithAggregatesInput[]
    OR?: Leave_balanceScalarWhereWithAggregatesInput[]
    NOT?: Leave_balanceScalarWhereWithAggregatesInput | Leave_balanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Leave_balance"> | number
    userId?: IntWithAggregatesFilter<"Leave_balance"> | number
    year?: IntWithAggregatesFilter<"Leave_balance"> | number
    leaveType?: EnumLeaveTypeWithAggregatesFilter<"Leave_balance"> | $Enums.LeaveType
    balance?: FloatWithAggregatesFilter<"Leave_balance"> | number
  }

  export type Leave_policyWhereInput = {
    AND?: Leave_policyWhereInput | Leave_policyWhereInput[]
    OR?: Leave_policyWhereInput[]
    NOT?: Leave_policyWhereInput | Leave_policyWhereInput[]
    leaveType?: EnumLeaveTypeFilter<"Leave_policy"> | $Enums.LeaveType
    defaultBalance?: FloatFilter<"Leave_policy"> | number
  }

  export type Leave_policyOrderByWithRelationInput = {
    leaveType?: SortOrder
    defaultBalance?: SortOrder
  }

  export type Leave_policyWhereUniqueInput = Prisma.AtLeast<{
    leaveType?: $Enums.LeaveType
    AND?: Leave_policyWhereInput | Leave_policyWhereInput[]
    OR?: Leave_policyWhereInput[]
    NOT?: Leave_policyWhereInput | Leave_policyWhereInput[]
    defaultBalance?: FloatFilter<"Leave_policy"> | number
  }, "leaveType">

  export type Leave_policyOrderByWithAggregationInput = {
    leaveType?: SortOrder
    defaultBalance?: SortOrder
    _count?: Leave_policyCountOrderByAggregateInput
    _avg?: Leave_policyAvgOrderByAggregateInput
    _max?: Leave_policyMaxOrderByAggregateInput
    _min?: Leave_policyMinOrderByAggregateInput
    _sum?: Leave_policySumOrderByAggregateInput
  }

  export type Leave_policyScalarWhereWithAggregatesInput = {
    AND?: Leave_policyScalarWhereWithAggregatesInput | Leave_policyScalarWhereWithAggregatesInput[]
    OR?: Leave_policyScalarWhereWithAggregatesInput[]
    NOT?: Leave_policyScalarWhereWithAggregatesInput | Leave_policyScalarWhereWithAggregatesInput[]
    leaveType?: EnumLeaveTypeWithAggregatesFilter<"Leave_policy"> | $Enums.LeaveType
    defaultBalance?: FloatWithAggregatesFilter<"Leave_policy"> | number
  }

  export type SyncHistoryWhereInput = {
    AND?: SyncHistoryWhereInput | SyncHistoryWhereInput[]
    OR?: SyncHistoryWhereInput[]
    NOT?: SyncHistoryWhereInput | SyncHistoryWhereInput[]
    id?: IntFilter<"SyncHistory"> | number
    syncTime?: DateTimeFilter<"SyncHistory"> | Date | string
    totalUsers?: IntFilter<"SyncHistory"> | number
    newUsers?: IntFilter<"SyncHistory"> | number
    updatedUsers?: IntFilter<"SyncHistory"> | number
    status?: StringFilter<"SyncHistory"> | string
  }

  export type SyncHistoryOrderByWithRelationInput = {
    id?: SortOrder
    syncTime?: SortOrder
    totalUsers?: SortOrder
    newUsers?: SortOrder
    updatedUsers?: SortOrder
    status?: SortOrder
  }

  export type SyncHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SyncHistoryWhereInput | SyncHistoryWhereInput[]
    OR?: SyncHistoryWhereInput[]
    NOT?: SyncHistoryWhereInput | SyncHistoryWhereInput[]
    syncTime?: DateTimeFilter<"SyncHistory"> | Date | string
    totalUsers?: IntFilter<"SyncHistory"> | number
    newUsers?: IntFilter<"SyncHistory"> | number
    updatedUsers?: IntFilter<"SyncHistory"> | number
    status?: StringFilter<"SyncHistory"> | string
  }, "id">

  export type SyncHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    syncTime?: SortOrder
    totalUsers?: SortOrder
    newUsers?: SortOrder
    updatedUsers?: SortOrder
    status?: SortOrder
    _count?: SyncHistoryCountOrderByAggregateInput
    _avg?: SyncHistoryAvgOrderByAggregateInput
    _max?: SyncHistoryMaxOrderByAggregateInput
    _min?: SyncHistoryMinOrderByAggregateInput
    _sum?: SyncHistorySumOrderByAggregateInput
  }

  export type SyncHistoryScalarWhereWithAggregatesInput = {
    AND?: SyncHistoryScalarWhereWithAggregatesInput | SyncHistoryScalarWhereWithAggregatesInput[]
    OR?: SyncHistoryScalarWhereWithAggregatesInput[]
    NOT?: SyncHistoryScalarWhereWithAggregatesInput | SyncHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SyncHistory"> | number
    syncTime?: DateTimeWithAggregatesFilter<"SyncHistory"> | Date | string
    totalUsers?: IntWithAggregatesFilter<"SyncHistory"> | number
    newUsers?: IntWithAggregatesFilter<"SyncHistory"> | number
    updatedUsers?: IntWithAggregatesFilter<"SyncHistory"> | number
    status?: StringWithAggregatesFilter<"SyncHistory"> | string
  }

  export type PunchWhereInput = {
    AND?: PunchWhereInput | PunchWhereInput[]
    OR?: PunchWhereInput[]
    NOT?: PunchWhereInput | PunchWhereInput[]
    id?: IntFilter<"Punch"> | number
    employeeId?: StringFilter<"Punch"> | string
    eventTime?: DateTimeFilter<"Punch"> | Date | string
    correctEventTime?: DateTimeNullableFilter<"Punch"> | Date | string | null
    direction?: EnumDirectionFilter<"Punch"> | $Enums.Direction
    source?: EnumSourceFilter<"Punch"> | $Enums.Source
    note?: StringNullableFilter<"Punch"> | string | null
    createdBy?: StringNullableFilter<"Punch"> | string | null
    createdAt?: DateTimeFilter<"Punch"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Punch"> | Date | string | null
    directionCorrected?: BoolFilter<"Punch"> | boolean
    originalDirection?: EnumDirectionNullableFilter<"Punch"> | $Enums.Direction | null
    correctedBy?: StringNullableFilter<"Punch"> | string | null
    correctionNote?: StringNullableFilter<"Punch"> | string | null
    correctedAt?: DateTimeNullableFilter<"Punch"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PunchOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    eventTime?: SortOrder
    correctEventTime?: SortOrderInput | SortOrder
    direction?: SortOrder
    source?: SortOrder
    note?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    directionCorrected?: SortOrder
    originalDirection?: SortOrderInput | SortOrder
    correctedBy?: SortOrderInput | SortOrder
    correctionNote?: SortOrderInput | SortOrder
    correctedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PunchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    employeeId_eventTime_direction_source?: PunchEmployeeIdEventTimeDirectionSourceCompoundUniqueInput
    AND?: PunchWhereInput | PunchWhereInput[]
    OR?: PunchWhereInput[]
    NOT?: PunchWhereInput | PunchWhereInput[]
    employeeId?: StringFilter<"Punch"> | string
    eventTime?: DateTimeFilter<"Punch"> | Date | string
    correctEventTime?: DateTimeNullableFilter<"Punch"> | Date | string | null
    direction?: EnumDirectionFilter<"Punch"> | $Enums.Direction
    source?: EnumSourceFilter<"Punch"> | $Enums.Source
    note?: StringNullableFilter<"Punch"> | string | null
    createdBy?: StringNullableFilter<"Punch"> | string | null
    createdAt?: DateTimeFilter<"Punch"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Punch"> | Date | string | null
    directionCorrected?: BoolFilter<"Punch"> | boolean
    originalDirection?: EnumDirectionNullableFilter<"Punch"> | $Enums.Direction | null
    correctedBy?: StringNullableFilter<"Punch"> | string | null
    correctionNote?: StringNullableFilter<"Punch"> | string | null
    correctedAt?: DateTimeNullableFilter<"Punch"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "employeeId_eventTime_direction_source">

  export type PunchOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    eventTime?: SortOrder
    correctEventTime?: SortOrderInput | SortOrder
    direction?: SortOrder
    source?: SortOrder
    note?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    directionCorrected?: SortOrder
    originalDirection?: SortOrderInput | SortOrder
    correctedBy?: SortOrderInput | SortOrder
    correctionNote?: SortOrderInput | SortOrder
    correctedAt?: SortOrderInput | SortOrder
    _count?: PunchCountOrderByAggregateInput
    _avg?: PunchAvgOrderByAggregateInput
    _max?: PunchMaxOrderByAggregateInput
    _min?: PunchMinOrderByAggregateInput
    _sum?: PunchSumOrderByAggregateInput
  }

  export type PunchScalarWhereWithAggregatesInput = {
    AND?: PunchScalarWhereWithAggregatesInput | PunchScalarWhereWithAggregatesInput[]
    OR?: PunchScalarWhereWithAggregatesInput[]
    NOT?: PunchScalarWhereWithAggregatesInput | PunchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Punch"> | number
    employeeId?: StringWithAggregatesFilter<"Punch"> | string
    eventTime?: DateTimeWithAggregatesFilter<"Punch"> | Date | string
    correctEventTime?: DateTimeNullableWithAggregatesFilter<"Punch"> | Date | string | null
    direction?: EnumDirectionWithAggregatesFilter<"Punch"> | $Enums.Direction
    source?: EnumSourceWithAggregatesFilter<"Punch"> | $Enums.Source
    note?: StringNullableWithAggregatesFilter<"Punch"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"Punch"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Punch"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Punch"> | Date | string | null
    directionCorrected?: BoolWithAggregatesFilter<"Punch"> | boolean
    originalDirection?: EnumDirectionNullableWithAggregatesFilter<"Punch"> | $Enums.Direction | null
    correctedBy?: StringNullableWithAggregatesFilter<"Punch"> | string | null
    correctionNote?: StringNullableWithAggregatesFilter<"Punch"> | string | null
    correctedAt?: DateTimeNullableWithAggregatesFilter<"Punch"> | Date | string | null
  }

  export type AttendanceDayWhereInput = {
    AND?: AttendanceDayWhereInput | AttendanceDayWhereInput[]
    OR?: AttendanceDayWhereInput[]
    NOT?: AttendanceDayWhereInput | AttendanceDayWhereInput[]
    employeeId?: StringFilter<"AttendanceDay"> | string
    workDate?: DateTimeFilter<"AttendanceDay"> | Date | string
    startTime?: StringNullableFilter<"AttendanceDay"> | string | null
    firstIn?: StringNullableFilter<"AttendanceDay"> | string | null
    lastOut?: StringNullableFilter<"AttendanceDay"> | string | null
    workedSeconds?: IntFilter<"AttendanceDay"> | number
    notWorkingSeconds?: IntFilter<"AttendanceDay"> | number
    overtimeSeconds?: IntFilter<"AttendanceDay"> | number
    hadManual?: BoolFilter<"AttendanceDay"> | boolean
    status?: EnumAttendanceStatusFilter<"AttendanceDay"> | $Enums.AttendanceStatus
    calculatedAt?: DateTimeFilter<"AttendanceDay"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AttendanceDayOrderByWithRelationInput = {
    employeeId?: SortOrder
    workDate?: SortOrder
    startTime?: SortOrderInput | SortOrder
    firstIn?: SortOrderInput | SortOrder
    lastOut?: SortOrderInput | SortOrder
    workedSeconds?: SortOrder
    notWorkingSeconds?: SortOrder
    overtimeSeconds?: SortOrder
    hadManual?: SortOrder
    status?: SortOrder
    calculatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AttendanceDayWhereUniqueInput = Prisma.AtLeast<{
    employeeId_workDate?: AttendanceDayEmployeeIdWorkDateCompoundUniqueInput
    AND?: AttendanceDayWhereInput | AttendanceDayWhereInput[]
    OR?: AttendanceDayWhereInput[]
    NOT?: AttendanceDayWhereInput | AttendanceDayWhereInput[]
    employeeId?: StringFilter<"AttendanceDay"> | string
    workDate?: DateTimeFilter<"AttendanceDay"> | Date | string
    startTime?: StringNullableFilter<"AttendanceDay"> | string | null
    firstIn?: StringNullableFilter<"AttendanceDay"> | string | null
    lastOut?: StringNullableFilter<"AttendanceDay"> | string | null
    workedSeconds?: IntFilter<"AttendanceDay"> | number
    notWorkingSeconds?: IntFilter<"AttendanceDay"> | number
    overtimeSeconds?: IntFilter<"AttendanceDay"> | number
    hadManual?: BoolFilter<"AttendanceDay"> | boolean
    status?: EnumAttendanceStatusFilter<"AttendanceDay"> | $Enums.AttendanceStatus
    calculatedAt?: DateTimeFilter<"AttendanceDay"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "employeeId_workDate">

  export type AttendanceDayOrderByWithAggregationInput = {
    employeeId?: SortOrder
    workDate?: SortOrder
    startTime?: SortOrderInput | SortOrder
    firstIn?: SortOrderInput | SortOrder
    lastOut?: SortOrderInput | SortOrder
    workedSeconds?: SortOrder
    notWorkingSeconds?: SortOrder
    overtimeSeconds?: SortOrder
    hadManual?: SortOrder
    status?: SortOrder
    calculatedAt?: SortOrder
    _count?: AttendanceDayCountOrderByAggregateInput
    _avg?: AttendanceDayAvgOrderByAggregateInput
    _max?: AttendanceDayMaxOrderByAggregateInput
    _min?: AttendanceDayMinOrderByAggregateInput
    _sum?: AttendanceDaySumOrderByAggregateInput
  }

  export type AttendanceDayScalarWhereWithAggregatesInput = {
    AND?: AttendanceDayScalarWhereWithAggregatesInput | AttendanceDayScalarWhereWithAggregatesInput[]
    OR?: AttendanceDayScalarWhereWithAggregatesInput[]
    NOT?: AttendanceDayScalarWhereWithAggregatesInput | AttendanceDayScalarWhereWithAggregatesInput[]
    employeeId?: StringWithAggregatesFilter<"AttendanceDay"> | string
    workDate?: DateTimeWithAggregatesFilter<"AttendanceDay"> | Date | string
    startTime?: StringNullableWithAggregatesFilter<"AttendanceDay"> | string | null
    firstIn?: StringNullableWithAggregatesFilter<"AttendanceDay"> | string | null
    lastOut?: StringNullableWithAggregatesFilter<"AttendanceDay"> | string | null
    workedSeconds?: IntWithAggregatesFilter<"AttendanceDay"> | number
    notWorkingSeconds?: IntWithAggregatesFilter<"AttendanceDay"> | number
    overtimeSeconds?: IntWithAggregatesFilter<"AttendanceDay"> | number
    hadManual?: BoolWithAggregatesFilter<"AttendanceDay"> | boolean
    status?: EnumAttendanceStatusWithAggregatesFilter<"AttendanceDay"> | $Enums.AttendanceStatus
    calculatedAt?: DateTimeWithAggregatesFilter<"AttendanceDay"> | Date | string
  }

  export type DeviceConfigWhereInput = {
    AND?: DeviceConfigWhereInput | DeviceConfigWhereInput[]
    OR?: DeviceConfigWhereInput[]
    NOT?: DeviceConfigWhereInput | DeviceConfigWhereInput[]
    id?: IntFilter<"DeviceConfig"> | number
    ip?: StringFilter<"DeviceConfig"> | string
    username?: StringFilter<"DeviceConfig"> | string
    passwordEnc?: StringFilter<"DeviceConfig"> | string
    lastEventTime?: StringNullableFilter<"DeviceConfig"> | string | null
    authFailedAt?: DateTimeNullableFilter<"DeviceConfig"> | Date | string | null
    authFailureCount?: IntFilter<"DeviceConfig"> | number
    createdAt?: DateTimeFilter<"DeviceConfig"> | Date | string
    updatedAt?: DateTimeFilter<"DeviceConfig"> | Date | string
  }

  export type DeviceConfigOrderByWithRelationInput = {
    id?: SortOrder
    ip?: SortOrder
    username?: SortOrder
    passwordEnc?: SortOrder
    lastEventTime?: SortOrderInput | SortOrder
    authFailedAt?: SortOrderInput | SortOrder
    authFailureCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviceConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DeviceConfigWhereInput | DeviceConfigWhereInput[]
    OR?: DeviceConfigWhereInput[]
    NOT?: DeviceConfigWhereInput | DeviceConfigWhereInput[]
    ip?: StringFilter<"DeviceConfig"> | string
    username?: StringFilter<"DeviceConfig"> | string
    passwordEnc?: StringFilter<"DeviceConfig"> | string
    lastEventTime?: StringNullableFilter<"DeviceConfig"> | string | null
    authFailedAt?: DateTimeNullableFilter<"DeviceConfig"> | Date | string | null
    authFailureCount?: IntFilter<"DeviceConfig"> | number
    createdAt?: DateTimeFilter<"DeviceConfig"> | Date | string
    updatedAt?: DateTimeFilter<"DeviceConfig"> | Date | string
  }, "id">

  export type DeviceConfigOrderByWithAggregationInput = {
    id?: SortOrder
    ip?: SortOrder
    username?: SortOrder
    passwordEnc?: SortOrder
    lastEventTime?: SortOrderInput | SortOrder
    authFailedAt?: SortOrderInput | SortOrder
    authFailureCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeviceConfigCountOrderByAggregateInput
    _avg?: DeviceConfigAvgOrderByAggregateInput
    _max?: DeviceConfigMaxOrderByAggregateInput
    _min?: DeviceConfigMinOrderByAggregateInput
    _sum?: DeviceConfigSumOrderByAggregateInput
  }

  export type DeviceConfigScalarWhereWithAggregatesInput = {
    AND?: DeviceConfigScalarWhereWithAggregatesInput | DeviceConfigScalarWhereWithAggregatesInput[]
    OR?: DeviceConfigScalarWhereWithAggregatesInput[]
    NOT?: DeviceConfigScalarWhereWithAggregatesInput | DeviceConfigScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DeviceConfig"> | number
    ip?: StringWithAggregatesFilter<"DeviceConfig"> | string
    username?: StringWithAggregatesFilter<"DeviceConfig"> | string
    passwordEnc?: StringWithAggregatesFilter<"DeviceConfig"> | string
    lastEventTime?: StringNullableWithAggregatesFilter<"DeviceConfig"> | string | null
    authFailedAt?: DateTimeNullableWithAggregatesFilter<"DeviceConfig"> | Date | string | null
    authFailureCount?: IntWithAggregatesFilter<"DeviceConfig"> | number
    createdAt?: DateTimeWithAggregatesFilter<"DeviceConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DeviceConfig"> | Date | string
  }

  export type AttendanceConfigWhereInput = {
    AND?: AttendanceConfigWhereInput | AttendanceConfigWhereInput[]
    OR?: AttendanceConfigWhereInput[]
    NOT?: AttendanceConfigWhereInput | AttendanceConfigWhereInput[]
    id?: IntFilter<"AttendanceConfig"> | number
    workStart?: DateTimeFilter<"AttendanceConfig"> | Date | string
    workEnd?: DateTimeFilter<"AttendanceConfig"> | Date | string
    otEnd?: DateTimeFilter<"AttendanceConfig"> | Date | string
    earlyStart?: DateTimeFilter<"AttendanceConfig"> | Date | string
    createdAt?: DateTimeFilter<"AttendanceConfig"> | Date | string
    updatedAt?: DateTimeFilter<"AttendanceConfig"> | Date | string
  }

  export type AttendanceConfigOrderByWithRelationInput = {
    id?: SortOrder
    workStart?: SortOrder
    workEnd?: SortOrder
    otEnd?: SortOrder
    earlyStart?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AttendanceConfigWhereInput | AttendanceConfigWhereInput[]
    OR?: AttendanceConfigWhereInput[]
    NOT?: AttendanceConfigWhereInput | AttendanceConfigWhereInput[]
    workStart?: DateTimeFilter<"AttendanceConfig"> | Date | string
    workEnd?: DateTimeFilter<"AttendanceConfig"> | Date | string
    otEnd?: DateTimeFilter<"AttendanceConfig"> | Date | string
    earlyStart?: DateTimeFilter<"AttendanceConfig"> | Date | string
    createdAt?: DateTimeFilter<"AttendanceConfig"> | Date | string
    updatedAt?: DateTimeFilter<"AttendanceConfig"> | Date | string
  }, "id">

  export type AttendanceConfigOrderByWithAggregationInput = {
    id?: SortOrder
    workStart?: SortOrder
    workEnd?: SortOrder
    otEnd?: SortOrder
    earlyStart?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AttendanceConfigCountOrderByAggregateInput
    _avg?: AttendanceConfigAvgOrderByAggregateInput
    _max?: AttendanceConfigMaxOrderByAggregateInput
    _min?: AttendanceConfigMinOrderByAggregateInput
    _sum?: AttendanceConfigSumOrderByAggregateInput
  }

  export type AttendanceConfigScalarWhereWithAggregatesInput = {
    AND?: AttendanceConfigScalarWhereWithAggregatesInput | AttendanceConfigScalarWhereWithAggregatesInput[]
    OR?: AttendanceConfigScalarWhereWithAggregatesInput[]
    NOT?: AttendanceConfigScalarWhereWithAggregatesInput | AttendanceConfigScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AttendanceConfig"> | number
    workStart?: DateTimeWithAggregatesFilter<"AttendanceConfig"> | Date | string
    workEnd?: DateTimeWithAggregatesFilter<"AttendanceConfig"> | Date | string
    otEnd?: DateTimeWithAggregatesFilter<"AttendanceConfig"> | Date | string
    earlyStart?: DateTimeWithAggregatesFilter<"AttendanceConfig"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AttendanceConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AttendanceConfig"> | Date | string
  }

  export type SalaryConfigWhereInput = {
    AND?: SalaryConfigWhereInput | SalaryConfigWhereInput[]
    OR?: SalaryConfigWhereInput[]
    NOT?: SalaryConfigWhereInput | SalaryConfigWhereInput[]
    id?: IntFilter<"SalaryConfig"> | number
    userId?: IntFilter<"SalaryConfig"> | number
    basicSalary?: FloatFilter<"SalaryConfig"> | number
    otRate?: FloatNullableFilter<"SalaryConfig"> | number | null
    allowance?: FloatNullableFilter<"SalaryConfig"> | number | null
    deduction?: FloatNullableFilter<"SalaryConfig"> | number | null
    effectiveFrom?: DateTimeFilter<"SalaryConfig"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SalaryConfigOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    basicSalary?: SortOrder
    otRate?: SortOrderInput | SortOrder
    allowance?: SortOrderInput | SortOrder
    deduction?: SortOrderInput | SortOrder
    effectiveFrom?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SalaryConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SalaryConfigWhereInput | SalaryConfigWhereInput[]
    OR?: SalaryConfigWhereInput[]
    NOT?: SalaryConfigWhereInput | SalaryConfigWhereInput[]
    userId?: IntFilter<"SalaryConfig"> | number
    basicSalary?: FloatFilter<"SalaryConfig"> | number
    otRate?: FloatNullableFilter<"SalaryConfig"> | number | null
    allowance?: FloatNullableFilter<"SalaryConfig"> | number | null
    deduction?: FloatNullableFilter<"SalaryConfig"> | number | null
    effectiveFrom?: DateTimeFilter<"SalaryConfig"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SalaryConfigOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    basicSalary?: SortOrder
    otRate?: SortOrderInput | SortOrder
    allowance?: SortOrderInput | SortOrder
    deduction?: SortOrderInput | SortOrder
    effectiveFrom?: SortOrder
    _count?: SalaryConfigCountOrderByAggregateInput
    _avg?: SalaryConfigAvgOrderByAggregateInput
    _max?: SalaryConfigMaxOrderByAggregateInput
    _min?: SalaryConfigMinOrderByAggregateInput
    _sum?: SalaryConfigSumOrderByAggregateInput
  }

  export type SalaryConfigScalarWhereWithAggregatesInput = {
    AND?: SalaryConfigScalarWhereWithAggregatesInput | SalaryConfigScalarWhereWithAggregatesInput[]
    OR?: SalaryConfigScalarWhereWithAggregatesInput[]
    NOT?: SalaryConfigScalarWhereWithAggregatesInput | SalaryConfigScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SalaryConfig"> | number
    userId?: IntWithAggregatesFilter<"SalaryConfig"> | number
    basicSalary?: FloatWithAggregatesFilter<"SalaryConfig"> | number
    otRate?: FloatNullableWithAggregatesFilter<"SalaryConfig"> | number | null
    allowance?: FloatNullableWithAggregatesFilter<"SalaryConfig"> | number | null
    deduction?: FloatNullableWithAggregatesFilter<"SalaryConfig"> | number | null
    effectiveFrom?: DateTimeWithAggregatesFilter<"SalaryConfig"> | Date | string
  }

  export type SalaryRecordWhereInput = {
    AND?: SalaryRecordWhereInput | SalaryRecordWhereInput[]
    OR?: SalaryRecordWhereInput[]
    NOT?: SalaryRecordWhereInput | SalaryRecordWhereInput[]
    id?: IntFilter<"SalaryRecord"> | number
    userId?: IntFilter<"SalaryRecord"> | number
    month?: IntFilter<"SalaryRecord"> | number
    year?: IntFilter<"SalaryRecord"> | number
    basicSalary?: FloatFilter<"SalaryRecord"> | number
    totalLeave?: IntFilter<"SalaryRecord"> | number
    leaveDeductions?: FloatFilter<"SalaryRecord"> | number
    overtimePay?: FloatFilter<"SalaryRecord"> | number
    netSalary?: FloatFilter<"SalaryRecord"> | number
    generatedAt?: DateTimeFilter<"SalaryRecord"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SalaryRecordOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    basicSalary?: SortOrder
    totalLeave?: SortOrder
    leaveDeductions?: SortOrder
    overtimePay?: SortOrder
    netSalary?: SortOrder
    generatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SalaryRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_month_year?: SalaryRecordUserIdMonthYearCompoundUniqueInput
    AND?: SalaryRecordWhereInput | SalaryRecordWhereInput[]
    OR?: SalaryRecordWhereInput[]
    NOT?: SalaryRecordWhereInput | SalaryRecordWhereInput[]
    userId?: IntFilter<"SalaryRecord"> | number
    month?: IntFilter<"SalaryRecord"> | number
    year?: IntFilter<"SalaryRecord"> | number
    basicSalary?: FloatFilter<"SalaryRecord"> | number
    totalLeave?: IntFilter<"SalaryRecord"> | number
    leaveDeductions?: FloatFilter<"SalaryRecord"> | number
    overtimePay?: FloatFilter<"SalaryRecord"> | number
    netSalary?: FloatFilter<"SalaryRecord"> | number
    generatedAt?: DateTimeFilter<"SalaryRecord"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_month_year">

  export type SalaryRecordOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    basicSalary?: SortOrder
    totalLeave?: SortOrder
    leaveDeductions?: SortOrder
    overtimePay?: SortOrder
    netSalary?: SortOrder
    generatedAt?: SortOrder
    _count?: SalaryRecordCountOrderByAggregateInput
    _avg?: SalaryRecordAvgOrderByAggregateInput
    _max?: SalaryRecordMaxOrderByAggregateInput
    _min?: SalaryRecordMinOrderByAggregateInput
    _sum?: SalaryRecordSumOrderByAggregateInput
  }

  export type SalaryRecordScalarWhereWithAggregatesInput = {
    AND?: SalaryRecordScalarWhereWithAggregatesInput | SalaryRecordScalarWhereWithAggregatesInput[]
    OR?: SalaryRecordScalarWhereWithAggregatesInput[]
    NOT?: SalaryRecordScalarWhereWithAggregatesInput | SalaryRecordScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SalaryRecord"> | number
    userId?: IntWithAggregatesFilter<"SalaryRecord"> | number
    month?: IntWithAggregatesFilter<"SalaryRecord"> | number
    year?: IntWithAggregatesFilter<"SalaryRecord"> | number
    basicSalary?: FloatWithAggregatesFilter<"SalaryRecord"> | number
    totalLeave?: IntWithAggregatesFilter<"SalaryRecord"> | number
    leaveDeductions?: FloatWithAggregatesFilter<"SalaryRecord"> | number
    overtimePay?: FloatWithAggregatesFilter<"SalaryRecord"> | number
    netSalary?: FloatWithAggregatesFilter<"SalaryRecord"> | number
    generatedAt?: DateTimeWithAggregatesFilter<"SalaryRecord"> | Date | string
  }

  export type UserCreateInput = {
    email: string
    password: string
    name: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshToken?: string | null
    employeeId?: string | null
    cardNumber?: string | null
    validFrom?: Date | string | null
    validTo?: Date | string | null
    epfNo?: string | null
    nic?: string | null
    jobPosition?: string | null
    imagePath?: string | null
    active?: boolean
    joinDate?: Date | string | null
    address?: string | null
    leaveRequests?: Leave_requestCreateNestedManyWithoutUserInput
    approvedRequests?: Leave_requestCreateNestedManyWithoutApprovedByUserInput
    leaveBalances?: Leave_balanceCreateNestedManyWithoutUserInput
    punches?: PunchCreateNestedManyWithoutUserInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutUserInput
    salaryConfigs?: SalaryConfigCreateNestedManyWithoutUserInput
    salaryRecords?: SalaryRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    name: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshToken?: string | null
    employeeId?: string | null
    cardNumber?: string | null
    validFrom?: Date | string | null
    validTo?: Date | string | null
    epfNo?: string | null
    nic?: string | null
    jobPosition?: string | null
    imagePath?: string | null
    active?: boolean
    joinDate?: Date | string | null
    address?: string | null
    leaveRequests?: Leave_requestUncheckedCreateNestedManyWithoutUserInput
    approvedRequests?: Leave_requestUncheckedCreateNestedManyWithoutApprovedByUserInput
    leaveBalances?: Leave_balanceUncheckedCreateNestedManyWithoutUserInput
    punches?: PunchUncheckedCreateNestedManyWithoutUserInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutUserInput
    salaryConfigs?: SalaryConfigUncheckedCreateNestedManyWithoutUserInput
    salaryRecords?: SalaryRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    epfNo?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    jobPosition?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    leaveRequests?: Leave_requestUpdateManyWithoutUserNestedInput
    approvedRequests?: Leave_requestUpdateManyWithoutApprovedByUserNestedInput
    leaveBalances?: Leave_balanceUpdateManyWithoutUserNestedInput
    punches?: PunchUpdateManyWithoutUserNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutUserNestedInput
    salaryConfigs?: SalaryConfigUpdateManyWithoutUserNestedInput
    salaryRecords?: SalaryRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    epfNo?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    jobPosition?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    leaveRequests?: Leave_requestUncheckedUpdateManyWithoutUserNestedInput
    approvedRequests?: Leave_requestUncheckedUpdateManyWithoutApprovedByUserNestedInput
    leaveBalances?: Leave_balanceUncheckedUpdateManyWithoutUserNestedInput
    punches?: PunchUncheckedUpdateManyWithoutUserNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutUserNestedInput
    salaryConfigs?: SalaryConfigUncheckedUpdateManyWithoutUserNestedInput
    salaryRecords?: SalaryRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    name: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshToken?: string | null
    employeeId?: string | null
    cardNumber?: string | null
    validFrom?: Date | string | null
    validTo?: Date | string | null
    epfNo?: string | null
    nic?: string | null
    jobPosition?: string | null
    imagePath?: string | null
    active?: boolean
    joinDate?: Date | string | null
    address?: string | null
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    epfNo?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    jobPosition?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    epfNo?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    jobPosition?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Leave_requestCreateInput = {
    leaveType: $Enums.LeaveType
    status?: $Enums.LeaveStatus | null
    reason?: string | null
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    dates?: Leave_request_dateCreateNestedManyWithoutRequestInput
    user: UserCreateNestedOneWithoutLeaveRequestsInput
    approvedByUser?: UserCreateNestedOneWithoutApprovedRequestsInput
  }

  export type Leave_requestUncheckedCreateInput = {
    id?: number
    userId: number
    approvedBy?: number | null
    leaveType: $Enums.LeaveType
    status?: $Enums.LeaveStatus | null
    reason?: string | null
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    dates?: Leave_request_dateUncheckedCreateNestedManyWithoutRequestInput
  }

  export type Leave_requestUpdateInput = {
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    status?: NullableEnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dates?: Leave_request_dateUpdateManyWithoutRequestNestedInput
    user?: UserUpdateOneRequiredWithoutLeaveRequestsNestedInput
    approvedByUser?: UserUpdateOneWithoutApprovedRequestsNestedInput
  }

  export type Leave_requestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    status?: NullableEnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dates?: Leave_request_dateUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type Leave_requestCreateManyInput = {
    id?: number
    userId: number
    approvedBy?: number | null
    leaveType: $Enums.LeaveType
    status?: $Enums.LeaveStatus | null
    reason?: string | null
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
  }

  export type Leave_requestUpdateManyMutationInput = {
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    status?: NullableEnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Leave_requestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    status?: NullableEnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Leave_request_dateCreateInput = {
    leaveDate: Date | string
    isHalfDay?: boolean
    halfdayType?: $Enums.HalfdayType | null
    request: Leave_requestCreateNestedOneWithoutDatesInput
  }

  export type Leave_request_dateUncheckedCreateInput = {
    id?: number
    requestId: number
    leaveDate: Date | string
    isHalfDay?: boolean
    halfdayType?: $Enums.HalfdayType | null
  }

  export type Leave_request_dateUpdateInput = {
    leaveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isHalfDay?: BoolFieldUpdateOperationsInput | boolean
    halfdayType?: NullableEnumHalfdayTypeFieldUpdateOperationsInput | $Enums.HalfdayType | null
    request?: Leave_requestUpdateOneRequiredWithoutDatesNestedInput
  }

  export type Leave_request_dateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestId?: IntFieldUpdateOperationsInput | number
    leaveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isHalfDay?: BoolFieldUpdateOperationsInput | boolean
    halfdayType?: NullableEnumHalfdayTypeFieldUpdateOperationsInput | $Enums.HalfdayType | null
  }

  export type Leave_request_dateCreateManyInput = {
    id?: number
    requestId: number
    leaveDate: Date | string
    isHalfDay?: boolean
    halfdayType?: $Enums.HalfdayType | null
  }

  export type Leave_request_dateUpdateManyMutationInput = {
    leaveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isHalfDay?: BoolFieldUpdateOperationsInput | boolean
    halfdayType?: NullableEnumHalfdayTypeFieldUpdateOperationsInput | $Enums.HalfdayType | null
  }

  export type Leave_request_dateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestId?: IntFieldUpdateOperationsInput | number
    leaveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isHalfDay?: BoolFieldUpdateOperationsInput | boolean
    halfdayType?: NullableEnumHalfdayTypeFieldUpdateOperationsInput | $Enums.HalfdayType | null
  }

  export type Leave_balanceCreateInput = {
    year: number
    leaveType: $Enums.LeaveType
    balance: number
    user: UserCreateNestedOneWithoutLeaveBalancesInput
  }

  export type Leave_balanceUncheckedCreateInput = {
    id?: number
    userId: number
    year: number
    leaveType: $Enums.LeaveType
    balance: number
  }

  export type Leave_balanceUpdateInput = {
    year?: IntFieldUpdateOperationsInput | number
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    balance?: FloatFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutLeaveBalancesNestedInput
  }

  export type Leave_balanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    balance?: FloatFieldUpdateOperationsInput | number
  }

  export type Leave_balanceCreateManyInput = {
    id?: number
    userId: number
    year: number
    leaveType: $Enums.LeaveType
    balance: number
  }

  export type Leave_balanceUpdateManyMutationInput = {
    year?: IntFieldUpdateOperationsInput | number
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    balance?: FloatFieldUpdateOperationsInput | number
  }

  export type Leave_balanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    balance?: FloatFieldUpdateOperationsInput | number
  }

  export type Leave_policyCreateInput = {
    leaveType: $Enums.LeaveType
    defaultBalance: number
  }

  export type Leave_policyUncheckedCreateInput = {
    leaveType: $Enums.LeaveType
    defaultBalance: number
  }

  export type Leave_policyUpdateInput = {
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    defaultBalance?: FloatFieldUpdateOperationsInput | number
  }

  export type Leave_policyUncheckedUpdateInput = {
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    defaultBalance?: FloatFieldUpdateOperationsInput | number
  }

  export type Leave_policyCreateManyInput = {
    leaveType: $Enums.LeaveType
    defaultBalance: number
  }

  export type Leave_policyUpdateManyMutationInput = {
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    defaultBalance?: FloatFieldUpdateOperationsInput | number
  }

  export type Leave_policyUncheckedUpdateManyInput = {
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    defaultBalance?: FloatFieldUpdateOperationsInput | number
  }

  export type SyncHistoryCreateInput = {
    syncTime?: Date | string
    totalUsers: number
    newUsers: number
    updatedUsers: number
    status: string
  }

  export type SyncHistoryUncheckedCreateInput = {
    id?: number
    syncTime?: Date | string
    totalUsers: number
    newUsers: number
    updatedUsers: number
    status: string
  }

  export type SyncHistoryUpdateInput = {
    syncTime?: DateTimeFieldUpdateOperationsInput | Date | string
    totalUsers?: IntFieldUpdateOperationsInput | number
    newUsers?: IntFieldUpdateOperationsInput | number
    updatedUsers?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type SyncHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    syncTime?: DateTimeFieldUpdateOperationsInput | Date | string
    totalUsers?: IntFieldUpdateOperationsInput | number
    newUsers?: IntFieldUpdateOperationsInput | number
    updatedUsers?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type SyncHistoryCreateManyInput = {
    id?: number
    syncTime?: Date | string
    totalUsers: number
    newUsers: number
    updatedUsers: number
    status: string
  }

  export type SyncHistoryUpdateManyMutationInput = {
    syncTime?: DateTimeFieldUpdateOperationsInput | Date | string
    totalUsers?: IntFieldUpdateOperationsInput | number
    newUsers?: IntFieldUpdateOperationsInput | number
    updatedUsers?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type SyncHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    syncTime?: DateTimeFieldUpdateOperationsInput | Date | string
    totalUsers?: IntFieldUpdateOperationsInput | number
    newUsers?: IntFieldUpdateOperationsInput | number
    updatedUsers?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type PunchCreateInput = {
    eventTime: Date | string
    correctEventTime?: Date | string | null
    direction: $Enums.Direction
    source: $Enums.Source
    note?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    directionCorrected?: boolean
    originalDirection?: $Enums.Direction | null
    correctedBy?: string | null
    correctionNote?: string | null
    correctedAt?: Date | string | null
    user: UserCreateNestedOneWithoutPunchesInput
  }

  export type PunchUncheckedCreateInput = {
    id?: number
    employeeId: string
    eventTime: Date | string
    correctEventTime?: Date | string | null
    direction: $Enums.Direction
    source: $Enums.Source
    note?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    directionCorrected?: boolean
    originalDirection?: $Enums.Direction | null
    correctedBy?: string | null
    correctionNote?: string | null
    correctedAt?: Date | string | null
  }

  export type PunchUpdateInput = {
    eventTime?: DateTimeFieldUpdateOperationsInput | Date | string
    correctEventTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direction?: EnumDirectionFieldUpdateOperationsInput | $Enums.Direction
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directionCorrected?: BoolFieldUpdateOperationsInput | boolean
    originalDirection?: NullableEnumDirectionFieldUpdateOperationsInput | $Enums.Direction | null
    correctedBy?: NullableStringFieldUpdateOperationsInput | string | null
    correctionNote?: NullableStringFieldUpdateOperationsInput | string | null
    correctedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPunchesNestedInput
  }

  export type PunchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    eventTime?: DateTimeFieldUpdateOperationsInput | Date | string
    correctEventTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direction?: EnumDirectionFieldUpdateOperationsInput | $Enums.Direction
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directionCorrected?: BoolFieldUpdateOperationsInput | boolean
    originalDirection?: NullableEnumDirectionFieldUpdateOperationsInput | $Enums.Direction | null
    correctedBy?: NullableStringFieldUpdateOperationsInput | string | null
    correctionNote?: NullableStringFieldUpdateOperationsInput | string | null
    correctedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PunchCreateManyInput = {
    id?: number
    employeeId: string
    eventTime: Date | string
    correctEventTime?: Date | string | null
    direction: $Enums.Direction
    source: $Enums.Source
    note?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    directionCorrected?: boolean
    originalDirection?: $Enums.Direction | null
    correctedBy?: string | null
    correctionNote?: string | null
    correctedAt?: Date | string | null
  }

  export type PunchUpdateManyMutationInput = {
    eventTime?: DateTimeFieldUpdateOperationsInput | Date | string
    correctEventTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direction?: EnumDirectionFieldUpdateOperationsInput | $Enums.Direction
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directionCorrected?: BoolFieldUpdateOperationsInput | boolean
    originalDirection?: NullableEnumDirectionFieldUpdateOperationsInput | $Enums.Direction | null
    correctedBy?: NullableStringFieldUpdateOperationsInput | string | null
    correctionNote?: NullableStringFieldUpdateOperationsInput | string | null
    correctedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PunchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    eventTime?: DateTimeFieldUpdateOperationsInput | Date | string
    correctEventTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direction?: EnumDirectionFieldUpdateOperationsInput | $Enums.Direction
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directionCorrected?: BoolFieldUpdateOperationsInput | boolean
    originalDirection?: NullableEnumDirectionFieldUpdateOperationsInput | $Enums.Direction | null
    correctedBy?: NullableStringFieldUpdateOperationsInput | string | null
    correctionNote?: NullableStringFieldUpdateOperationsInput | string | null
    correctedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceDayCreateInput = {
    workDate: Date | string
    startTime?: string | null
    firstIn?: string | null
    lastOut?: string | null
    workedSeconds?: number
    notWorkingSeconds?: number
    overtimeSeconds?: number
    hadManual?: boolean
    status?: $Enums.AttendanceStatus
    calculatedAt?: Date | string
    user: UserCreateNestedOneWithoutAttendanceDaysInput
  }

  export type AttendanceDayUncheckedCreateInput = {
    employeeId: string
    workDate: Date | string
    startTime?: string | null
    firstIn?: string | null
    lastOut?: string | null
    workedSeconds?: number
    notWorkingSeconds?: number
    overtimeSeconds?: number
    hadManual?: boolean
    status?: $Enums.AttendanceStatus
    calculatedAt?: Date | string
  }

  export type AttendanceDayUpdateInput = {
    workDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    firstIn?: NullableStringFieldUpdateOperationsInput | string | null
    lastOut?: NullableStringFieldUpdateOperationsInput | string | null
    workedSeconds?: IntFieldUpdateOperationsInput | number
    notWorkingSeconds?: IntFieldUpdateOperationsInput | number
    overtimeSeconds?: IntFieldUpdateOperationsInput | number
    hadManual?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAttendanceDaysNestedInput
  }

  export type AttendanceDayUncheckedUpdateInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    workDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    firstIn?: NullableStringFieldUpdateOperationsInput | string | null
    lastOut?: NullableStringFieldUpdateOperationsInput | string | null
    workedSeconds?: IntFieldUpdateOperationsInput | number
    notWorkingSeconds?: IntFieldUpdateOperationsInput | number
    overtimeSeconds?: IntFieldUpdateOperationsInput | number
    hadManual?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceDayCreateManyInput = {
    employeeId: string
    workDate: Date | string
    startTime?: string | null
    firstIn?: string | null
    lastOut?: string | null
    workedSeconds?: number
    notWorkingSeconds?: number
    overtimeSeconds?: number
    hadManual?: boolean
    status?: $Enums.AttendanceStatus
    calculatedAt?: Date | string
  }

  export type AttendanceDayUpdateManyMutationInput = {
    workDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    firstIn?: NullableStringFieldUpdateOperationsInput | string | null
    lastOut?: NullableStringFieldUpdateOperationsInput | string | null
    workedSeconds?: IntFieldUpdateOperationsInput | number
    notWorkingSeconds?: IntFieldUpdateOperationsInput | number
    overtimeSeconds?: IntFieldUpdateOperationsInput | number
    hadManual?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceDayUncheckedUpdateManyInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    workDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    firstIn?: NullableStringFieldUpdateOperationsInput | string | null
    lastOut?: NullableStringFieldUpdateOperationsInput | string | null
    workedSeconds?: IntFieldUpdateOperationsInput | number
    notWorkingSeconds?: IntFieldUpdateOperationsInput | number
    overtimeSeconds?: IntFieldUpdateOperationsInput | number
    hadManual?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceConfigCreateInput = {
    id: number
    ip: string
    username: string
    passwordEnc: string
    lastEventTime?: string | null
    authFailedAt?: Date | string | null
    authFailureCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceConfigUncheckedCreateInput = {
    id: number
    ip: string
    username: string
    passwordEnc: string
    lastEventTime?: string | null
    authFailedAt?: Date | string | null
    authFailureCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceConfigUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ip?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordEnc?: StringFieldUpdateOperationsInput | string
    lastEventTime?: NullableStringFieldUpdateOperationsInput | string | null
    authFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authFailureCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceConfigUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ip?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordEnc?: StringFieldUpdateOperationsInput | string
    lastEventTime?: NullableStringFieldUpdateOperationsInput | string | null
    authFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authFailureCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceConfigCreateManyInput = {
    id: number
    ip: string
    username: string
    passwordEnc: string
    lastEventTime?: string | null
    authFailedAt?: Date | string | null
    authFailureCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceConfigUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    ip?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordEnc?: StringFieldUpdateOperationsInput | string
    lastEventTime?: NullableStringFieldUpdateOperationsInput | string | null
    authFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authFailureCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceConfigUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ip?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordEnc?: StringFieldUpdateOperationsInput | string
    lastEventTime?: NullableStringFieldUpdateOperationsInput | string | null
    authFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authFailureCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceConfigCreateInput = {
    workStart: Date | string
    workEnd: Date | string
    otEnd: Date | string
    earlyStart: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceConfigUncheckedCreateInput = {
    id?: number
    workStart: Date | string
    workEnd: Date | string
    otEnd: Date | string
    earlyStart: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceConfigUpdateInput = {
    workStart?: DateTimeFieldUpdateOperationsInput | Date | string
    workEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    otEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    earlyStart?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceConfigUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    workStart?: DateTimeFieldUpdateOperationsInput | Date | string
    workEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    otEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    earlyStart?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceConfigCreateManyInput = {
    id?: number
    workStart: Date | string
    workEnd: Date | string
    otEnd: Date | string
    earlyStart: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceConfigUpdateManyMutationInput = {
    workStart?: DateTimeFieldUpdateOperationsInput | Date | string
    workEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    otEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    earlyStart?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceConfigUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    workStart?: DateTimeFieldUpdateOperationsInput | Date | string
    workEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    otEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    earlyStart?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryConfigCreateInput = {
    basicSalary: number
    otRate?: number | null
    allowance?: number | null
    deduction?: number | null
    effectiveFrom?: Date | string
    user: UserCreateNestedOneWithoutSalaryConfigsInput
  }

  export type SalaryConfigUncheckedCreateInput = {
    id?: number
    userId: number
    basicSalary: number
    otRate?: number | null
    allowance?: number | null
    deduction?: number | null
    effectiveFrom?: Date | string
  }

  export type SalaryConfigUpdateInput = {
    basicSalary?: FloatFieldUpdateOperationsInput | number
    otRate?: NullableFloatFieldUpdateOperationsInput | number | null
    allowance?: NullableFloatFieldUpdateOperationsInput | number | null
    deduction?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSalaryConfigsNestedInput
  }

  export type SalaryConfigUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    basicSalary?: FloatFieldUpdateOperationsInput | number
    otRate?: NullableFloatFieldUpdateOperationsInput | number | null
    allowance?: NullableFloatFieldUpdateOperationsInput | number | null
    deduction?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryConfigCreateManyInput = {
    id?: number
    userId: number
    basicSalary: number
    otRate?: number | null
    allowance?: number | null
    deduction?: number | null
    effectiveFrom?: Date | string
  }

  export type SalaryConfigUpdateManyMutationInput = {
    basicSalary?: FloatFieldUpdateOperationsInput | number
    otRate?: NullableFloatFieldUpdateOperationsInput | number | null
    allowance?: NullableFloatFieldUpdateOperationsInput | number | null
    deduction?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryConfigUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    basicSalary?: FloatFieldUpdateOperationsInput | number
    otRate?: NullableFloatFieldUpdateOperationsInput | number | null
    allowance?: NullableFloatFieldUpdateOperationsInput | number | null
    deduction?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryRecordCreateInput = {
    month: number
    year: number
    basicSalary: number
    totalLeave?: number
    leaveDeductions?: number
    overtimePay?: number
    netSalary: number
    generatedAt?: Date | string
    user: UserCreateNestedOneWithoutSalaryRecordsInput
  }

  export type SalaryRecordUncheckedCreateInput = {
    id?: number
    userId: number
    month: number
    year: number
    basicSalary: number
    totalLeave?: number
    leaveDeductions?: number
    overtimePay?: number
    netSalary: number
    generatedAt?: Date | string
  }

  export type SalaryRecordUpdateInput = {
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    basicSalary?: FloatFieldUpdateOperationsInput | number
    totalLeave?: IntFieldUpdateOperationsInput | number
    leaveDeductions?: FloatFieldUpdateOperationsInput | number
    overtimePay?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSalaryRecordsNestedInput
  }

  export type SalaryRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    basicSalary?: FloatFieldUpdateOperationsInput | number
    totalLeave?: IntFieldUpdateOperationsInput | number
    leaveDeductions?: FloatFieldUpdateOperationsInput | number
    overtimePay?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryRecordCreateManyInput = {
    id?: number
    userId: number
    month: number
    year: number
    basicSalary: number
    totalLeave?: number
    leaveDeductions?: number
    overtimePay?: number
    netSalary: number
    generatedAt?: Date | string
  }

  export type SalaryRecordUpdateManyMutationInput = {
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    basicSalary?: FloatFieldUpdateOperationsInput | number
    totalLeave?: IntFieldUpdateOperationsInput | number
    leaveDeductions?: FloatFieldUpdateOperationsInput | number
    overtimePay?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    basicSalary?: FloatFieldUpdateOperationsInput | number
    totalLeave?: IntFieldUpdateOperationsInput | number
    leaveDeductions?: FloatFieldUpdateOperationsInput | number
    overtimePay?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type Leave_requestListRelationFilter = {
    every?: Leave_requestWhereInput
    some?: Leave_requestWhereInput
    none?: Leave_requestWhereInput
  }

  export type Leave_balanceListRelationFilter = {
    every?: Leave_balanceWhereInput
    some?: Leave_balanceWhereInput
    none?: Leave_balanceWhereInput
  }

  export type PunchListRelationFilter = {
    every?: PunchWhereInput
    some?: PunchWhereInput
    none?: PunchWhereInput
  }

  export type AttendanceDayListRelationFilter = {
    every?: AttendanceDayWhereInput
    some?: AttendanceDayWhereInput
    none?: AttendanceDayWhereInput
  }

  export type SalaryConfigListRelationFilter = {
    every?: SalaryConfigWhereInput
    some?: SalaryConfigWhereInput
    none?: SalaryConfigWhereInput
  }

  export type SalaryRecordListRelationFilter = {
    every?: SalaryRecordWhereInput
    some?: SalaryRecordWhereInput
    none?: SalaryRecordWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type Leave_requestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Leave_balanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PunchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceDayOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalaryConfigOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalaryRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    refreshToken?: SortOrder
    employeeId?: SortOrder
    cardNumber?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    epfNo?: SortOrder
    nic?: SortOrder
    jobPosition?: SortOrder
    imagePath?: SortOrder
    active?: SortOrder
    joinDate?: SortOrder
    address?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    refreshToken?: SortOrder
    employeeId?: SortOrder
    cardNumber?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    epfNo?: SortOrder
    nic?: SortOrder
    jobPosition?: SortOrder
    imagePath?: SortOrder
    active?: SortOrder
    joinDate?: SortOrder
    address?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    refreshToken?: SortOrder
    employeeId?: SortOrder
    cardNumber?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    epfNo?: SortOrder
    nic?: SortOrder
    jobPosition?: SortOrder
    imagePath?: SortOrder
    active?: SortOrder
    joinDate?: SortOrder
    address?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumLeaveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveTypeFilter<$PrismaModel> | $Enums.LeaveType
  }

  export type EnumLeaveStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLeaveStatusNullableFilter<$PrismaModel> | $Enums.LeaveStatus | null
  }

  export type Leave_request_dateListRelationFilter = {
    every?: Leave_request_dateWhereInput
    some?: Leave_request_dateWhereInput
    none?: Leave_request_dateWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type Leave_request_dateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Leave_requestCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    approvedBy?: SortOrder
    leaveType?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    requestedAt?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
  }

  export type Leave_requestAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    approvedBy?: SortOrder
  }

  export type Leave_requestMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    approvedBy?: SortOrder
    leaveType?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    requestedAt?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
  }

  export type Leave_requestMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    approvedBy?: SortOrder
    leaveType?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    requestedAt?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
  }

  export type Leave_requestSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    approvedBy?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumLeaveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveTypeWithAggregatesFilter<$PrismaModel> | $Enums.LeaveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveTypeFilter<$PrismaModel>
    _max?: NestedEnumLeaveTypeFilter<$PrismaModel>
  }

  export type EnumLeaveStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLeaveStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.LeaveStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumLeaveStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumLeaveStatusNullableFilter<$PrismaModel>
  }

  export type EnumHalfdayTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.HalfdayType | EnumHalfdayTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.HalfdayType[] | ListEnumHalfdayTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.HalfdayType[] | ListEnumHalfdayTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumHalfdayTypeNullableFilter<$PrismaModel> | $Enums.HalfdayType | null
  }

  export type Leave_requestScalarRelationFilter = {
    is?: Leave_requestWhereInput
    isNot?: Leave_requestWhereInput
  }

  export type Leave_request_dateCountOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    leaveDate?: SortOrder
    isHalfDay?: SortOrder
    halfdayType?: SortOrder
  }

  export type Leave_request_dateAvgOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
  }

  export type Leave_request_dateMaxOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    leaveDate?: SortOrder
    isHalfDay?: SortOrder
    halfdayType?: SortOrder
  }

  export type Leave_request_dateMinOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    leaveDate?: SortOrder
    isHalfDay?: SortOrder
    halfdayType?: SortOrder
  }

  export type Leave_request_dateSumOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
  }

  export type EnumHalfdayTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HalfdayType | EnumHalfdayTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.HalfdayType[] | ListEnumHalfdayTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.HalfdayType[] | ListEnumHalfdayTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumHalfdayTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.HalfdayType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumHalfdayTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumHalfdayTypeNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type Leave_balanceUserIdYearLeaveTypeCompoundUniqueInput = {
    userId: number
    year: number
    leaveType: $Enums.LeaveType
  }

  export type Leave_balanceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    leaveType?: SortOrder
    balance?: SortOrder
  }

  export type Leave_balanceAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    balance?: SortOrder
  }

  export type Leave_balanceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    leaveType?: SortOrder
    balance?: SortOrder
  }

  export type Leave_balanceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    leaveType?: SortOrder
    balance?: SortOrder
  }

  export type Leave_balanceSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    balance?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type Leave_policyCountOrderByAggregateInput = {
    leaveType?: SortOrder
    defaultBalance?: SortOrder
  }

  export type Leave_policyAvgOrderByAggregateInput = {
    defaultBalance?: SortOrder
  }

  export type Leave_policyMaxOrderByAggregateInput = {
    leaveType?: SortOrder
    defaultBalance?: SortOrder
  }

  export type Leave_policyMinOrderByAggregateInput = {
    leaveType?: SortOrder
    defaultBalance?: SortOrder
  }

  export type Leave_policySumOrderByAggregateInput = {
    defaultBalance?: SortOrder
  }

  export type SyncHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    syncTime?: SortOrder
    totalUsers?: SortOrder
    newUsers?: SortOrder
    updatedUsers?: SortOrder
    status?: SortOrder
  }

  export type SyncHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    totalUsers?: SortOrder
    newUsers?: SortOrder
    updatedUsers?: SortOrder
  }

  export type SyncHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    syncTime?: SortOrder
    totalUsers?: SortOrder
    newUsers?: SortOrder
    updatedUsers?: SortOrder
    status?: SortOrder
  }

  export type SyncHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    syncTime?: SortOrder
    totalUsers?: SortOrder
    newUsers?: SortOrder
    updatedUsers?: SortOrder
    status?: SortOrder
  }

  export type SyncHistorySumOrderByAggregateInput = {
    id?: SortOrder
    totalUsers?: SortOrder
    newUsers?: SortOrder
    updatedUsers?: SortOrder
  }

  export type EnumDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.Direction | EnumDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumDirectionFilter<$PrismaModel> | $Enums.Direction
  }

  export type EnumSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.Source | EnumSourceFieldRefInput<$PrismaModel>
    in?: $Enums.Source[] | ListEnumSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Source[] | ListEnumSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumSourceFilter<$PrismaModel> | $Enums.Source
  }

  export type EnumDirectionNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Direction | EnumDirectionFieldRefInput<$PrismaModel> | null
    in?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDirectionNullableFilter<$PrismaModel> | $Enums.Direction | null
  }

  export type PunchEmployeeIdEventTimeDirectionSourceCompoundUniqueInput = {
    employeeId: string
    eventTime: Date | string
    direction: $Enums.Direction
    source: $Enums.Source
  }

  export type PunchCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    eventTime?: SortOrder
    correctEventTime?: SortOrder
    direction?: SortOrder
    source?: SortOrder
    note?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    directionCorrected?: SortOrder
    originalDirection?: SortOrder
    correctedBy?: SortOrder
    correctionNote?: SortOrder
    correctedAt?: SortOrder
  }

  export type PunchAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PunchMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    eventTime?: SortOrder
    correctEventTime?: SortOrder
    direction?: SortOrder
    source?: SortOrder
    note?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    directionCorrected?: SortOrder
    originalDirection?: SortOrder
    correctedBy?: SortOrder
    correctionNote?: SortOrder
    correctedAt?: SortOrder
  }

  export type PunchMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    eventTime?: SortOrder
    correctEventTime?: SortOrder
    direction?: SortOrder
    source?: SortOrder
    note?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    directionCorrected?: SortOrder
    originalDirection?: SortOrder
    correctedBy?: SortOrder
    correctionNote?: SortOrder
    correctedAt?: SortOrder
  }

  export type PunchSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Direction | EnumDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumDirectionWithAggregatesFilter<$PrismaModel> | $Enums.Direction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDirectionFilter<$PrismaModel>
    _max?: NestedEnumDirectionFilter<$PrismaModel>
  }

  export type EnumSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Source | EnumSourceFieldRefInput<$PrismaModel>
    in?: $Enums.Source[] | ListEnumSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Source[] | ListEnumSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumSourceWithAggregatesFilter<$PrismaModel> | $Enums.Source
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSourceFilter<$PrismaModel>
    _max?: NestedEnumSourceFilter<$PrismaModel>
  }

  export type EnumDirectionNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Direction | EnumDirectionFieldRefInput<$PrismaModel> | null
    in?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDirectionNullableWithAggregatesFilter<$PrismaModel> | $Enums.Direction | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDirectionNullableFilter<$PrismaModel>
    _max?: NestedEnumDirectionNullableFilter<$PrismaModel>
  }

  export type EnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type AttendanceDayEmployeeIdWorkDateCompoundUniqueInput = {
    employeeId: string
    workDate: Date | string
  }

  export type AttendanceDayCountOrderByAggregateInput = {
    employeeId?: SortOrder
    workDate?: SortOrder
    startTime?: SortOrder
    firstIn?: SortOrder
    lastOut?: SortOrder
    workedSeconds?: SortOrder
    notWorkingSeconds?: SortOrder
    overtimeSeconds?: SortOrder
    hadManual?: SortOrder
    status?: SortOrder
    calculatedAt?: SortOrder
  }

  export type AttendanceDayAvgOrderByAggregateInput = {
    workedSeconds?: SortOrder
    notWorkingSeconds?: SortOrder
    overtimeSeconds?: SortOrder
  }

  export type AttendanceDayMaxOrderByAggregateInput = {
    employeeId?: SortOrder
    workDate?: SortOrder
    startTime?: SortOrder
    firstIn?: SortOrder
    lastOut?: SortOrder
    workedSeconds?: SortOrder
    notWorkingSeconds?: SortOrder
    overtimeSeconds?: SortOrder
    hadManual?: SortOrder
    status?: SortOrder
    calculatedAt?: SortOrder
  }

  export type AttendanceDayMinOrderByAggregateInput = {
    employeeId?: SortOrder
    workDate?: SortOrder
    startTime?: SortOrder
    firstIn?: SortOrder
    lastOut?: SortOrder
    workedSeconds?: SortOrder
    notWorkingSeconds?: SortOrder
    overtimeSeconds?: SortOrder
    hadManual?: SortOrder
    status?: SortOrder
    calculatedAt?: SortOrder
  }

  export type AttendanceDaySumOrderByAggregateInput = {
    workedSeconds?: SortOrder
    notWorkingSeconds?: SortOrder
    overtimeSeconds?: SortOrder
  }

  export type EnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type DeviceConfigCountOrderByAggregateInput = {
    id?: SortOrder
    ip?: SortOrder
    username?: SortOrder
    passwordEnc?: SortOrder
    lastEventTime?: SortOrder
    authFailedAt?: SortOrder
    authFailureCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviceConfigAvgOrderByAggregateInput = {
    id?: SortOrder
    authFailureCount?: SortOrder
  }

  export type DeviceConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    ip?: SortOrder
    username?: SortOrder
    passwordEnc?: SortOrder
    lastEventTime?: SortOrder
    authFailedAt?: SortOrder
    authFailureCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviceConfigMinOrderByAggregateInput = {
    id?: SortOrder
    ip?: SortOrder
    username?: SortOrder
    passwordEnc?: SortOrder
    lastEventTime?: SortOrder
    authFailedAt?: SortOrder
    authFailureCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviceConfigSumOrderByAggregateInput = {
    id?: SortOrder
    authFailureCount?: SortOrder
  }

  export type AttendanceConfigCountOrderByAggregateInput = {
    id?: SortOrder
    workStart?: SortOrder
    workEnd?: SortOrder
    otEnd?: SortOrder
    earlyStart?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceConfigAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AttendanceConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    workStart?: SortOrder
    workEnd?: SortOrder
    otEnd?: SortOrder
    earlyStart?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceConfigMinOrderByAggregateInput = {
    id?: SortOrder
    workStart?: SortOrder
    workEnd?: SortOrder
    otEnd?: SortOrder
    earlyStart?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceConfigSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type SalaryConfigCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    basicSalary?: SortOrder
    otRate?: SortOrder
    allowance?: SortOrder
    deduction?: SortOrder
    effectiveFrom?: SortOrder
  }

  export type SalaryConfigAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    basicSalary?: SortOrder
    otRate?: SortOrder
    allowance?: SortOrder
    deduction?: SortOrder
  }

  export type SalaryConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    basicSalary?: SortOrder
    otRate?: SortOrder
    allowance?: SortOrder
    deduction?: SortOrder
    effectiveFrom?: SortOrder
  }

  export type SalaryConfigMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    basicSalary?: SortOrder
    otRate?: SortOrder
    allowance?: SortOrder
    deduction?: SortOrder
    effectiveFrom?: SortOrder
  }

  export type SalaryConfigSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    basicSalary?: SortOrder
    otRate?: SortOrder
    allowance?: SortOrder
    deduction?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type SalaryRecordUserIdMonthYearCompoundUniqueInput = {
    userId: number
    month: number
    year: number
  }

  export type SalaryRecordCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    basicSalary?: SortOrder
    totalLeave?: SortOrder
    leaveDeductions?: SortOrder
    overtimePay?: SortOrder
    netSalary?: SortOrder
    generatedAt?: SortOrder
  }

  export type SalaryRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    basicSalary?: SortOrder
    totalLeave?: SortOrder
    leaveDeductions?: SortOrder
    overtimePay?: SortOrder
    netSalary?: SortOrder
  }

  export type SalaryRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    basicSalary?: SortOrder
    totalLeave?: SortOrder
    leaveDeductions?: SortOrder
    overtimePay?: SortOrder
    netSalary?: SortOrder
    generatedAt?: SortOrder
  }

  export type SalaryRecordMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    basicSalary?: SortOrder
    totalLeave?: SortOrder
    leaveDeductions?: SortOrder
    overtimePay?: SortOrder
    netSalary?: SortOrder
    generatedAt?: SortOrder
  }

  export type SalaryRecordSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    basicSalary?: SortOrder
    totalLeave?: SortOrder
    leaveDeductions?: SortOrder
    overtimePay?: SortOrder
    netSalary?: SortOrder
  }

  export type Leave_requestCreateNestedManyWithoutUserInput = {
    create?: XOR<Leave_requestCreateWithoutUserInput, Leave_requestUncheckedCreateWithoutUserInput> | Leave_requestCreateWithoutUserInput[] | Leave_requestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Leave_requestCreateOrConnectWithoutUserInput | Leave_requestCreateOrConnectWithoutUserInput[]
    createMany?: Leave_requestCreateManyUserInputEnvelope
    connect?: Leave_requestWhereUniqueInput | Leave_requestWhereUniqueInput[]
  }

  export type Leave_requestCreateNestedManyWithoutApprovedByUserInput = {
    create?: XOR<Leave_requestCreateWithoutApprovedByUserInput, Leave_requestUncheckedCreateWithoutApprovedByUserInput> | Leave_requestCreateWithoutApprovedByUserInput[] | Leave_requestUncheckedCreateWithoutApprovedByUserInput[]
    connectOrCreate?: Leave_requestCreateOrConnectWithoutApprovedByUserInput | Leave_requestCreateOrConnectWithoutApprovedByUserInput[]
    createMany?: Leave_requestCreateManyApprovedByUserInputEnvelope
    connect?: Leave_requestWhereUniqueInput | Leave_requestWhereUniqueInput[]
  }

  export type Leave_balanceCreateNestedManyWithoutUserInput = {
    create?: XOR<Leave_balanceCreateWithoutUserInput, Leave_balanceUncheckedCreateWithoutUserInput> | Leave_balanceCreateWithoutUserInput[] | Leave_balanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Leave_balanceCreateOrConnectWithoutUserInput | Leave_balanceCreateOrConnectWithoutUserInput[]
    createMany?: Leave_balanceCreateManyUserInputEnvelope
    connect?: Leave_balanceWhereUniqueInput | Leave_balanceWhereUniqueInput[]
  }

  export type PunchCreateNestedManyWithoutUserInput = {
    create?: XOR<PunchCreateWithoutUserInput, PunchUncheckedCreateWithoutUserInput> | PunchCreateWithoutUserInput[] | PunchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PunchCreateOrConnectWithoutUserInput | PunchCreateOrConnectWithoutUserInput[]
    createMany?: PunchCreateManyUserInputEnvelope
    connect?: PunchWhereUniqueInput | PunchWhereUniqueInput[]
  }

  export type AttendanceDayCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceDayCreateWithoutUserInput, AttendanceDayUncheckedCreateWithoutUserInput> | AttendanceDayCreateWithoutUserInput[] | AttendanceDayUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceDayCreateOrConnectWithoutUserInput | AttendanceDayCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceDayCreateManyUserInputEnvelope
    connect?: AttendanceDayWhereUniqueInput | AttendanceDayWhereUniqueInput[]
  }

  export type SalaryConfigCreateNestedManyWithoutUserInput = {
    create?: XOR<SalaryConfigCreateWithoutUserInput, SalaryConfigUncheckedCreateWithoutUserInput> | SalaryConfigCreateWithoutUserInput[] | SalaryConfigUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalaryConfigCreateOrConnectWithoutUserInput | SalaryConfigCreateOrConnectWithoutUserInput[]
    createMany?: SalaryConfigCreateManyUserInputEnvelope
    connect?: SalaryConfigWhereUniqueInput | SalaryConfigWhereUniqueInput[]
  }

  export type SalaryRecordCreateNestedManyWithoutUserInput = {
    create?: XOR<SalaryRecordCreateWithoutUserInput, SalaryRecordUncheckedCreateWithoutUserInput> | SalaryRecordCreateWithoutUserInput[] | SalaryRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalaryRecordCreateOrConnectWithoutUserInput | SalaryRecordCreateOrConnectWithoutUserInput[]
    createMany?: SalaryRecordCreateManyUserInputEnvelope
    connect?: SalaryRecordWhereUniqueInput | SalaryRecordWhereUniqueInput[]
  }

  export type Leave_requestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Leave_requestCreateWithoutUserInput, Leave_requestUncheckedCreateWithoutUserInput> | Leave_requestCreateWithoutUserInput[] | Leave_requestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Leave_requestCreateOrConnectWithoutUserInput | Leave_requestCreateOrConnectWithoutUserInput[]
    createMany?: Leave_requestCreateManyUserInputEnvelope
    connect?: Leave_requestWhereUniqueInput | Leave_requestWhereUniqueInput[]
  }

  export type Leave_requestUncheckedCreateNestedManyWithoutApprovedByUserInput = {
    create?: XOR<Leave_requestCreateWithoutApprovedByUserInput, Leave_requestUncheckedCreateWithoutApprovedByUserInput> | Leave_requestCreateWithoutApprovedByUserInput[] | Leave_requestUncheckedCreateWithoutApprovedByUserInput[]
    connectOrCreate?: Leave_requestCreateOrConnectWithoutApprovedByUserInput | Leave_requestCreateOrConnectWithoutApprovedByUserInput[]
    createMany?: Leave_requestCreateManyApprovedByUserInputEnvelope
    connect?: Leave_requestWhereUniqueInput | Leave_requestWhereUniqueInput[]
  }

  export type Leave_balanceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Leave_balanceCreateWithoutUserInput, Leave_balanceUncheckedCreateWithoutUserInput> | Leave_balanceCreateWithoutUserInput[] | Leave_balanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Leave_balanceCreateOrConnectWithoutUserInput | Leave_balanceCreateOrConnectWithoutUserInput[]
    createMany?: Leave_balanceCreateManyUserInputEnvelope
    connect?: Leave_balanceWhereUniqueInput | Leave_balanceWhereUniqueInput[]
  }

  export type PunchUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PunchCreateWithoutUserInput, PunchUncheckedCreateWithoutUserInput> | PunchCreateWithoutUserInput[] | PunchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PunchCreateOrConnectWithoutUserInput | PunchCreateOrConnectWithoutUserInput[]
    createMany?: PunchCreateManyUserInputEnvelope
    connect?: PunchWhereUniqueInput | PunchWhereUniqueInput[]
  }

  export type AttendanceDayUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceDayCreateWithoutUserInput, AttendanceDayUncheckedCreateWithoutUserInput> | AttendanceDayCreateWithoutUserInput[] | AttendanceDayUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceDayCreateOrConnectWithoutUserInput | AttendanceDayCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceDayCreateManyUserInputEnvelope
    connect?: AttendanceDayWhereUniqueInput | AttendanceDayWhereUniqueInput[]
  }

  export type SalaryConfigUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SalaryConfigCreateWithoutUserInput, SalaryConfigUncheckedCreateWithoutUserInput> | SalaryConfigCreateWithoutUserInput[] | SalaryConfigUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalaryConfigCreateOrConnectWithoutUserInput | SalaryConfigCreateOrConnectWithoutUserInput[]
    createMany?: SalaryConfigCreateManyUserInputEnvelope
    connect?: SalaryConfigWhereUniqueInput | SalaryConfigWhereUniqueInput[]
  }

  export type SalaryRecordUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SalaryRecordCreateWithoutUserInput, SalaryRecordUncheckedCreateWithoutUserInput> | SalaryRecordCreateWithoutUserInput[] | SalaryRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalaryRecordCreateOrConnectWithoutUserInput | SalaryRecordCreateOrConnectWithoutUserInput[]
    createMany?: SalaryRecordCreateManyUserInputEnvelope
    connect?: SalaryRecordWhereUniqueInput | SalaryRecordWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type Leave_requestUpdateManyWithoutUserNestedInput = {
    create?: XOR<Leave_requestCreateWithoutUserInput, Leave_requestUncheckedCreateWithoutUserInput> | Leave_requestCreateWithoutUserInput[] | Leave_requestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Leave_requestCreateOrConnectWithoutUserInput | Leave_requestCreateOrConnectWithoutUserInput[]
    upsert?: Leave_requestUpsertWithWhereUniqueWithoutUserInput | Leave_requestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Leave_requestCreateManyUserInputEnvelope
    set?: Leave_requestWhereUniqueInput | Leave_requestWhereUniqueInput[]
    disconnect?: Leave_requestWhereUniqueInput | Leave_requestWhereUniqueInput[]
    delete?: Leave_requestWhereUniqueInput | Leave_requestWhereUniqueInput[]
    connect?: Leave_requestWhereUniqueInput | Leave_requestWhereUniqueInput[]
    update?: Leave_requestUpdateWithWhereUniqueWithoutUserInput | Leave_requestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Leave_requestUpdateManyWithWhereWithoutUserInput | Leave_requestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Leave_requestScalarWhereInput | Leave_requestScalarWhereInput[]
  }

  export type Leave_requestUpdateManyWithoutApprovedByUserNestedInput = {
    create?: XOR<Leave_requestCreateWithoutApprovedByUserInput, Leave_requestUncheckedCreateWithoutApprovedByUserInput> | Leave_requestCreateWithoutApprovedByUserInput[] | Leave_requestUncheckedCreateWithoutApprovedByUserInput[]
    connectOrCreate?: Leave_requestCreateOrConnectWithoutApprovedByUserInput | Leave_requestCreateOrConnectWithoutApprovedByUserInput[]
    upsert?: Leave_requestUpsertWithWhereUniqueWithoutApprovedByUserInput | Leave_requestUpsertWithWhereUniqueWithoutApprovedByUserInput[]
    createMany?: Leave_requestCreateManyApprovedByUserInputEnvelope
    set?: Leave_requestWhereUniqueInput | Leave_requestWhereUniqueInput[]
    disconnect?: Leave_requestWhereUniqueInput | Leave_requestWhereUniqueInput[]
    delete?: Leave_requestWhereUniqueInput | Leave_requestWhereUniqueInput[]
    connect?: Leave_requestWhereUniqueInput | Leave_requestWhereUniqueInput[]
    update?: Leave_requestUpdateWithWhereUniqueWithoutApprovedByUserInput | Leave_requestUpdateWithWhereUniqueWithoutApprovedByUserInput[]
    updateMany?: Leave_requestUpdateManyWithWhereWithoutApprovedByUserInput | Leave_requestUpdateManyWithWhereWithoutApprovedByUserInput[]
    deleteMany?: Leave_requestScalarWhereInput | Leave_requestScalarWhereInput[]
  }

  export type Leave_balanceUpdateManyWithoutUserNestedInput = {
    create?: XOR<Leave_balanceCreateWithoutUserInput, Leave_balanceUncheckedCreateWithoutUserInput> | Leave_balanceCreateWithoutUserInput[] | Leave_balanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Leave_balanceCreateOrConnectWithoutUserInput | Leave_balanceCreateOrConnectWithoutUserInput[]
    upsert?: Leave_balanceUpsertWithWhereUniqueWithoutUserInput | Leave_balanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Leave_balanceCreateManyUserInputEnvelope
    set?: Leave_balanceWhereUniqueInput | Leave_balanceWhereUniqueInput[]
    disconnect?: Leave_balanceWhereUniqueInput | Leave_balanceWhereUniqueInput[]
    delete?: Leave_balanceWhereUniqueInput | Leave_balanceWhereUniqueInput[]
    connect?: Leave_balanceWhereUniqueInput | Leave_balanceWhereUniqueInput[]
    update?: Leave_balanceUpdateWithWhereUniqueWithoutUserInput | Leave_balanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Leave_balanceUpdateManyWithWhereWithoutUserInput | Leave_balanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Leave_balanceScalarWhereInput | Leave_balanceScalarWhereInput[]
  }

  export type PunchUpdateManyWithoutUserNestedInput = {
    create?: XOR<PunchCreateWithoutUserInput, PunchUncheckedCreateWithoutUserInput> | PunchCreateWithoutUserInput[] | PunchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PunchCreateOrConnectWithoutUserInput | PunchCreateOrConnectWithoutUserInput[]
    upsert?: PunchUpsertWithWhereUniqueWithoutUserInput | PunchUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PunchCreateManyUserInputEnvelope
    set?: PunchWhereUniqueInput | PunchWhereUniqueInput[]
    disconnect?: PunchWhereUniqueInput | PunchWhereUniqueInput[]
    delete?: PunchWhereUniqueInput | PunchWhereUniqueInput[]
    connect?: PunchWhereUniqueInput | PunchWhereUniqueInput[]
    update?: PunchUpdateWithWhereUniqueWithoutUserInput | PunchUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PunchUpdateManyWithWhereWithoutUserInput | PunchUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PunchScalarWhereInput | PunchScalarWhereInput[]
  }

  export type AttendanceDayUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceDayCreateWithoutUserInput, AttendanceDayUncheckedCreateWithoutUserInput> | AttendanceDayCreateWithoutUserInput[] | AttendanceDayUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceDayCreateOrConnectWithoutUserInput | AttendanceDayCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceDayUpsertWithWhereUniqueWithoutUserInput | AttendanceDayUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceDayCreateManyUserInputEnvelope
    set?: AttendanceDayWhereUniqueInput | AttendanceDayWhereUniqueInput[]
    disconnect?: AttendanceDayWhereUniqueInput | AttendanceDayWhereUniqueInput[]
    delete?: AttendanceDayWhereUniqueInput | AttendanceDayWhereUniqueInput[]
    connect?: AttendanceDayWhereUniqueInput | AttendanceDayWhereUniqueInput[]
    update?: AttendanceDayUpdateWithWhereUniqueWithoutUserInput | AttendanceDayUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceDayUpdateManyWithWhereWithoutUserInput | AttendanceDayUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceDayScalarWhereInput | AttendanceDayScalarWhereInput[]
  }

  export type SalaryConfigUpdateManyWithoutUserNestedInput = {
    create?: XOR<SalaryConfigCreateWithoutUserInput, SalaryConfigUncheckedCreateWithoutUserInput> | SalaryConfigCreateWithoutUserInput[] | SalaryConfigUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalaryConfigCreateOrConnectWithoutUserInput | SalaryConfigCreateOrConnectWithoutUserInput[]
    upsert?: SalaryConfigUpsertWithWhereUniqueWithoutUserInput | SalaryConfigUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SalaryConfigCreateManyUserInputEnvelope
    set?: SalaryConfigWhereUniqueInput | SalaryConfigWhereUniqueInput[]
    disconnect?: SalaryConfigWhereUniqueInput | SalaryConfigWhereUniqueInput[]
    delete?: SalaryConfigWhereUniqueInput | SalaryConfigWhereUniqueInput[]
    connect?: SalaryConfigWhereUniqueInput | SalaryConfigWhereUniqueInput[]
    update?: SalaryConfigUpdateWithWhereUniqueWithoutUserInput | SalaryConfigUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SalaryConfigUpdateManyWithWhereWithoutUserInput | SalaryConfigUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SalaryConfigScalarWhereInput | SalaryConfigScalarWhereInput[]
  }

  export type SalaryRecordUpdateManyWithoutUserNestedInput = {
    create?: XOR<SalaryRecordCreateWithoutUserInput, SalaryRecordUncheckedCreateWithoutUserInput> | SalaryRecordCreateWithoutUserInput[] | SalaryRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalaryRecordCreateOrConnectWithoutUserInput | SalaryRecordCreateOrConnectWithoutUserInput[]
    upsert?: SalaryRecordUpsertWithWhereUniqueWithoutUserInput | SalaryRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SalaryRecordCreateManyUserInputEnvelope
    set?: SalaryRecordWhereUniqueInput | SalaryRecordWhereUniqueInput[]
    disconnect?: SalaryRecordWhereUniqueInput | SalaryRecordWhereUniqueInput[]
    delete?: SalaryRecordWhereUniqueInput | SalaryRecordWhereUniqueInput[]
    connect?: SalaryRecordWhereUniqueInput | SalaryRecordWhereUniqueInput[]
    update?: SalaryRecordUpdateWithWhereUniqueWithoutUserInput | SalaryRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SalaryRecordUpdateManyWithWhereWithoutUserInput | SalaryRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SalaryRecordScalarWhereInput | SalaryRecordScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type Leave_requestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Leave_requestCreateWithoutUserInput, Leave_requestUncheckedCreateWithoutUserInput> | Leave_requestCreateWithoutUserInput[] | Leave_requestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Leave_requestCreateOrConnectWithoutUserInput | Leave_requestCreateOrConnectWithoutUserInput[]
    upsert?: Leave_requestUpsertWithWhereUniqueWithoutUserInput | Leave_requestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Leave_requestCreateManyUserInputEnvelope
    set?: Leave_requestWhereUniqueInput | Leave_requestWhereUniqueInput[]
    disconnect?: Leave_requestWhereUniqueInput | Leave_requestWhereUniqueInput[]
    delete?: Leave_requestWhereUniqueInput | Leave_requestWhereUniqueInput[]
    connect?: Leave_requestWhereUniqueInput | Leave_requestWhereUniqueInput[]
    update?: Leave_requestUpdateWithWhereUniqueWithoutUserInput | Leave_requestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Leave_requestUpdateManyWithWhereWithoutUserInput | Leave_requestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Leave_requestScalarWhereInput | Leave_requestScalarWhereInput[]
  }

  export type Leave_requestUncheckedUpdateManyWithoutApprovedByUserNestedInput = {
    create?: XOR<Leave_requestCreateWithoutApprovedByUserInput, Leave_requestUncheckedCreateWithoutApprovedByUserInput> | Leave_requestCreateWithoutApprovedByUserInput[] | Leave_requestUncheckedCreateWithoutApprovedByUserInput[]
    connectOrCreate?: Leave_requestCreateOrConnectWithoutApprovedByUserInput | Leave_requestCreateOrConnectWithoutApprovedByUserInput[]
    upsert?: Leave_requestUpsertWithWhereUniqueWithoutApprovedByUserInput | Leave_requestUpsertWithWhereUniqueWithoutApprovedByUserInput[]
    createMany?: Leave_requestCreateManyApprovedByUserInputEnvelope
    set?: Leave_requestWhereUniqueInput | Leave_requestWhereUniqueInput[]
    disconnect?: Leave_requestWhereUniqueInput | Leave_requestWhereUniqueInput[]
    delete?: Leave_requestWhereUniqueInput | Leave_requestWhereUniqueInput[]
    connect?: Leave_requestWhereUniqueInput | Leave_requestWhereUniqueInput[]
    update?: Leave_requestUpdateWithWhereUniqueWithoutApprovedByUserInput | Leave_requestUpdateWithWhereUniqueWithoutApprovedByUserInput[]
    updateMany?: Leave_requestUpdateManyWithWhereWithoutApprovedByUserInput | Leave_requestUpdateManyWithWhereWithoutApprovedByUserInput[]
    deleteMany?: Leave_requestScalarWhereInput | Leave_requestScalarWhereInput[]
  }

  export type Leave_balanceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Leave_balanceCreateWithoutUserInput, Leave_balanceUncheckedCreateWithoutUserInput> | Leave_balanceCreateWithoutUserInput[] | Leave_balanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Leave_balanceCreateOrConnectWithoutUserInput | Leave_balanceCreateOrConnectWithoutUserInput[]
    upsert?: Leave_balanceUpsertWithWhereUniqueWithoutUserInput | Leave_balanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Leave_balanceCreateManyUserInputEnvelope
    set?: Leave_balanceWhereUniqueInput | Leave_balanceWhereUniqueInput[]
    disconnect?: Leave_balanceWhereUniqueInput | Leave_balanceWhereUniqueInput[]
    delete?: Leave_balanceWhereUniqueInput | Leave_balanceWhereUniqueInput[]
    connect?: Leave_balanceWhereUniqueInput | Leave_balanceWhereUniqueInput[]
    update?: Leave_balanceUpdateWithWhereUniqueWithoutUserInput | Leave_balanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Leave_balanceUpdateManyWithWhereWithoutUserInput | Leave_balanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Leave_balanceScalarWhereInput | Leave_balanceScalarWhereInput[]
  }

  export type PunchUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PunchCreateWithoutUserInput, PunchUncheckedCreateWithoutUserInput> | PunchCreateWithoutUserInput[] | PunchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PunchCreateOrConnectWithoutUserInput | PunchCreateOrConnectWithoutUserInput[]
    upsert?: PunchUpsertWithWhereUniqueWithoutUserInput | PunchUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PunchCreateManyUserInputEnvelope
    set?: PunchWhereUniqueInput | PunchWhereUniqueInput[]
    disconnect?: PunchWhereUniqueInput | PunchWhereUniqueInput[]
    delete?: PunchWhereUniqueInput | PunchWhereUniqueInput[]
    connect?: PunchWhereUniqueInput | PunchWhereUniqueInput[]
    update?: PunchUpdateWithWhereUniqueWithoutUserInput | PunchUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PunchUpdateManyWithWhereWithoutUserInput | PunchUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PunchScalarWhereInput | PunchScalarWhereInput[]
  }

  export type AttendanceDayUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceDayCreateWithoutUserInput, AttendanceDayUncheckedCreateWithoutUserInput> | AttendanceDayCreateWithoutUserInput[] | AttendanceDayUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceDayCreateOrConnectWithoutUserInput | AttendanceDayCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceDayUpsertWithWhereUniqueWithoutUserInput | AttendanceDayUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceDayCreateManyUserInputEnvelope
    set?: AttendanceDayWhereUniqueInput | AttendanceDayWhereUniqueInput[]
    disconnect?: AttendanceDayWhereUniqueInput | AttendanceDayWhereUniqueInput[]
    delete?: AttendanceDayWhereUniqueInput | AttendanceDayWhereUniqueInput[]
    connect?: AttendanceDayWhereUniqueInput | AttendanceDayWhereUniqueInput[]
    update?: AttendanceDayUpdateWithWhereUniqueWithoutUserInput | AttendanceDayUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceDayUpdateManyWithWhereWithoutUserInput | AttendanceDayUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceDayScalarWhereInput | AttendanceDayScalarWhereInput[]
  }

  export type SalaryConfigUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SalaryConfigCreateWithoutUserInput, SalaryConfigUncheckedCreateWithoutUserInput> | SalaryConfigCreateWithoutUserInput[] | SalaryConfigUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalaryConfigCreateOrConnectWithoutUserInput | SalaryConfigCreateOrConnectWithoutUserInput[]
    upsert?: SalaryConfigUpsertWithWhereUniqueWithoutUserInput | SalaryConfigUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SalaryConfigCreateManyUserInputEnvelope
    set?: SalaryConfigWhereUniqueInput | SalaryConfigWhereUniqueInput[]
    disconnect?: SalaryConfigWhereUniqueInput | SalaryConfigWhereUniqueInput[]
    delete?: SalaryConfigWhereUniqueInput | SalaryConfigWhereUniqueInput[]
    connect?: SalaryConfigWhereUniqueInput | SalaryConfigWhereUniqueInput[]
    update?: SalaryConfigUpdateWithWhereUniqueWithoutUserInput | SalaryConfigUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SalaryConfigUpdateManyWithWhereWithoutUserInput | SalaryConfigUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SalaryConfigScalarWhereInput | SalaryConfigScalarWhereInput[]
  }

  export type SalaryRecordUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SalaryRecordCreateWithoutUserInput, SalaryRecordUncheckedCreateWithoutUserInput> | SalaryRecordCreateWithoutUserInput[] | SalaryRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalaryRecordCreateOrConnectWithoutUserInput | SalaryRecordCreateOrConnectWithoutUserInput[]
    upsert?: SalaryRecordUpsertWithWhereUniqueWithoutUserInput | SalaryRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SalaryRecordCreateManyUserInputEnvelope
    set?: SalaryRecordWhereUniqueInput | SalaryRecordWhereUniqueInput[]
    disconnect?: SalaryRecordWhereUniqueInput | SalaryRecordWhereUniqueInput[]
    delete?: SalaryRecordWhereUniqueInput | SalaryRecordWhereUniqueInput[]
    connect?: SalaryRecordWhereUniqueInput | SalaryRecordWhereUniqueInput[]
    update?: SalaryRecordUpdateWithWhereUniqueWithoutUserInput | SalaryRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SalaryRecordUpdateManyWithWhereWithoutUserInput | SalaryRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SalaryRecordScalarWhereInput | SalaryRecordScalarWhereInput[]
  }

  export type Leave_request_dateCreateNestedManyWithoutRequestInput = {
    create?: XOR<Leave_request_dateCreateWithoutRequestInput, Leave_request_dateUncheckedCreateWithoutRequestInput> | Leave_request_dateCreateWithoutRequestInput[] | Leave_request_dateUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: Leave_request_dateCreateOrConnectWithoutRequestInput | Leave_request_dateCreateOrConnectWithoutRequestInput[]
    createMany?: Leave_request_dateCreateManyRequestInputEnvelope
    connect?: Leave_request_dateWhereUniqueInput | Leave_request_dateWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutLeaveRequestsInput = {
    create?: XOR<UserCreateWithoutLeaveRequestsInput, UserUncheckedCreateWithoutLeaveRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaveRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovedRequestsInput = {
    create?: XOR<UserCreateWithoutApprovedRequestsInput, UserUncheckedCreateWithoutApprovedRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type Leave_request_dateUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<Leave_request_dateCreateWithoutRequestInput, Leave_request_dateUncheckedCreateWithoutRequestInput> | Leave_request_dateCreateWithoutRequestInput[] | Leave_request_dateUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: Leave_request_dateCreateOrConnectWithoutRequestInput | Leave_request_dateCreateOrConnectWithoutRequestInput[]
    createMany?: Leave_request_dateCreateManyRequestInputEnvelope
    connect?: Leave_request_dateWhereUniqueInput | Leave_request_dateWhereUniqueInput[]
  }

  export type EnumLeaveTypeFieldUpdateOperationsInput = {
    set?: $Enums.LeaveType
  }

  export type NullableEnumLeaveStatusFieldUpdateOperationsInput = {
    set?: $Enums.LeaveStatus | null
  }

  export type Leave_request_dateUpdateManyWithoutRequestNestedInput = {
    create?: XOR<Leave_request_dateCreateWithoutRequestInput, Leave_request_dateUncheckedCreateWithoutRequestInput> | Leave_request_dateCreateWithoutRequestInput[] | Leave_request_dateUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: Leave_request_dateCreateOrConnectWithoutRequestInput | Leave_request_dateCreateOrConnectWithoutRequestInput[]
    upsert?: Leave_request_dateUpsertWithWhereUniqueWithoutRequestInput | Leave_request_dateUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: Leave_request_dateCreateManyRequestInputEnvelope
    set?: Leave_request_dateWhereUniqueInput | Leave_request_dateWhereUniqueInput[]
    disconnect?: Leave_request_dateWhereUniqueInput | Leave_request_dateWhereUniqueInput[]
    delete?: Leave_request_dateWhereUniqueInput | Leave_request_dateWhereUniqueInput[]
    connect?: Leave_request_dateWhereUniqueInput | Leave_request_dateWhereUniqueInput[]
    update?: Leave_request_dateUpdateWithWhereUniqueWithoutRequestInput | Leave_request_dateUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: Leave_request_dateUpdateManyWithWhereWithoutRequestInput | Leave_request_dateUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: Leave_request_dateScalarWhereInput | Leave_request_dateScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutLeaveRequestsNestedInput = {
    create?: XOR<UserCreateWithoutLeaveRequestsInput, UserUncheckedCreateWithoutLeaveRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaveRequestsInput
    upsert?: UserUpsertWithoutLeaveRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeaveRequestsInput, UserUpdateWithoutLeaveRequestsInput>, UserUncheckedUpdateWithoutLeaveRequestsInput>
  }

  export type UserUpdateOneWithoutApprovedRequestsNestedInput = {
    create?: XOR<UserCreateWithoutApprovedRequestsInput, UserUncheckedCreateWithoutApprovedRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedRequestsInput
    upsert?: UserUpsertWithoutApprovedRequestsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedRequestsInput, UserUpdateWithoutApprovedRequestsInput>, UserUncheckedUpdateWithoutApprovedRequestsInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type Leave_request_dateUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<Leave_request_dateCreateWithoutRequestInput, Leave_request_dateUncheckedCreateWithoutRequestInput> | Leave_request_dateCreateWithoutRequestInput[] | Leave_request_dateUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: Leave_request_dateCreateOrConnectWithoutRequestInput | Leave_request_dateCreateOrConnectWithoutRequestInput[]
    upsert?: Leave_request_dateUpsertWithWhereUniqueWithoutRequestInput | Leave_request_dateUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: Leave_request_dateCreateManyRequestInputEnvelope
    set?: Leave_request_dateWhereUniqueInput | Leave_request_dateWhereUniqueInput[]
    disconnect?: Leave_request_dateWhereUniqueInput | Leave_request_dateWhereUniqueInput[]
    delete?: Leave_request_dateWhereUniqueInput | Leave_request_dateWhereUniqueInput[]
    connect?: Leave_request_dateWhereUniqueInput | Leave_request_dateWhereUniqueInput[]
    update?: Leave_request_dateUpdateWithWhereUniqueWithoutRequestInput | Leave_request_dateUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: Leave_request_dateUpdateManyWithWhereWithoutRequestInput | Leave_request_dateUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: Leave_request_dateScalarWhereInput | Leave_request_dateScalarWhereInput[]
  }

  export type Leave_requestCreateNestedOneWithoutDatesInput = {
    create?: XOR<Leave_requestCreateWithoutDatesInput, Leave_requestUncheckedCreateWithoutDatesInput>
    connectOrCreate?: Leave_requestCreateOrConnectWithoutDatesInput
    connect?: Leave_requestWhereUniqueInput
  }

  export type NullableEnumHalfdayTypeFieldUpdateOperationsInput = {
    set?: $Enums.HalfdayType | null
  }

  export type Leave_requestUpdateOneRequiredWithoutDatesNestedInput = {
    create?: XOR<Leave_requestCreateWithoutDatesInput, Leave_requestUncheckedCreateWithoutDatesInput>
    connectOrCreate?: Leave_requestCreateOrConnectWithoutDatesInput
    upsert?: Leave_requestUpsertWithoutDatesInput
    connect?: Leave_requestWhereUniqueInput
    update?: XOR<XOR<Leave_requestUpdateToOneWithWhereWithoutDatesInput, Leave_requestUpdateWithoutDatesInput>, Leave_requestUncheckedUpdateWithoutDatesInput>
  }

  export type UserCreateNestedOneWithoutLeaveBalancesInput = {
    create?: XOR<UserCreateWithoutLeaveBalancesInput, UserUncheckedCreateWithoutLeaveBalancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaveBalancesInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutLeaveBalancesNestedInput = {
    create?: XOR<UserCreateWithoutLeaveBalancesInput, UserUncheckedCreateWithoutLeaveBalancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaveBalancesInput
    upsert?: UserUpsertWithoutLeaveBalancesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeaveBalancesInput, UserUpdateWithoutLeaveBalancesInput>, UserUncheckedUpdateWithoutLeaveBalancesInput>
  }

  export type UserCreateNestedOneWithoutPunchesInput = {
    create?: XOR<UserCreateWithoutPunchesInput, UserUncheckedCreateWithoutPunchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPunchesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumDirectionFieldUpdateOperationsInput = {
    set?: $Enums.Direction
  }

  export type EnumSourceFieldUpdateOperationsInput = {
    set?: $Enums.Source
  }

  export type NullableEnumDirectionFieldUpdateOperationsInput = {
    set?: $Enums.Direction | null
  }

  export type UserUpdateOneRequiredWithoutPunchesNestedInput = {
    create?: XOR<UserCreateWithoutPunchesInput, UserUncheckedCreateWithoutPunchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPunchesInput
    upsert?: UserUpsertWithoutPunchesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPunchesInput, UserUpdateWithoutPunchesInput>, UserUncheckedUpdateWithoutPunchesInput>
  }

  export type UserCreateNestedOneWithoutAttendanceDaysInput = {
    create?: XOR<UserCreateWithoutAttendanceDaysInput, UserUncheckedCreateWithoutAttendanceDaysInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceDaysInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAttendanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.AttendanceStatus
  }

  export type UserUpdateOneRequiredWithoutAttendanceDaysNestedInput = {
    create?: XOR<UserCreateWithoutAttendanceDaysInput, UserUncheckedCreateWithoutAttendanceDaysInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceDaysInput
    upsert?: UserUpsertWithoutAttendanceDaysInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttendanceDaysInput, UserUpdateWithoutAttendanceDaysInput>, UserUncheckedUpdateWithoutAttendanceDaysInput>
  }

  export type UserCreateNestedOneWithoutSalaryConfigsInput = {
    create?: XOR<UserCreateWithoutSalaryConfigsInput, UserUncheckedCreateWithoutSalaryConfigsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalaryConfigsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutSalaryConfigsNestedInput = {
    create?: XOR<UserCreateWithoutSalaryConfigsInput, UserUncheckedCreateWithoutSalaryConfigsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalaryConfigsInput
    upsert?: UserUpsertWithoutSalaryConfigsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSalaryConfigsInput, UserUpdateWithoutSalaryConfigsInput>, UserUncheckedUpdateWithoutSalaryConfigsInput>
  }

  export type UserCreateNestedOneWithoutSalaryRecordsInput = {
    create?: XOR<UserCreateWithoutSalaryRecordsInput, UserUncheckedCreateWithoutSalaryRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalaryRecordsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSalaryRecordsNestedInput = {
    create?: XOR<UserCreateWithoutSalaryRecordsInput, UserUncheckedCreateWithoutSalaryRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalaryRecordsInput
    upsert?: UserUpsertWithoutSalaryRecordsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSalaryRecordsInput, UserUpdateWithoutSalaryRecordsInput>, UserUncheckedUpdateWithoutSalaryRecordsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumLeaveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveTypeFilter<$PrismaModel> | $Enums.LeaveType
  }

  export type NestedEnumLeaveStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLeaveStatusNullableFilter<$PrismaModel> | $Enums.LeaveStatus | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumLeaveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveTypeWithAggregatesFilter<$PrismaModel> | $Enums.LeaveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveTypeFilter<$PrismaModel>
    _max?: NestedEnumLeaveTypeFilter<$PrismaModel>
  }

  export type NestedEnumLeaveStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLeaveStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.LeaveStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumLeaveStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumLeaveStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumHalfdayTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.HalfdayType | EnumHalfdayTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.HalfdayType[] | ListEnumHalfdayTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.HalfdayType[] | ListEnumHalfdayTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumHalfdayTypeNullableFilter<$PrismaModel> | $Enums.HalfdayType | null
  }

  export type NestedEnumHalfdayTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HalfdayType | EnumHalfdayTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.HalfdayType[] | ListEnumHalfdayTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.HalfdayType[] | ListEnumHalfdayTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumHalfdayTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.HalfdayType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumHalfdayTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumHalfdayTypeNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.Direction | EnumDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumDirectionFilter<$PrismaModel> | $Enums.Direction
  }

  export type NestedEnumSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.Source | EnumSourceFieldRefInput<$PrismaModel>
    in?: $Enums.Source[] | ListEnumSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Source[] | ListEnumSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumSourceFilter<$PrismaModel> | $Enums.Source
  }

  export type NestedEnumDirectionNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Direction | EnumDirectionFieldRefInput<$PrismaModel> | null
    in?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDirectionNullableFilter<$PrismaModel> | $Enums.Direction | null
  }

  export type NestedEnumDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Direction | EnumDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumDirectionWithAggregatesFilter<$PrismaModel> | $Enums.Direction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDirectionFilter<$PrismaModel>
    _max?: NestedEnumDirectionFilter<$PrismaModel>
  }

  export type NestedEnumSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Source | EnumSourceFieldRefInput<$PrismaModel>
    in?: $Enums.Source[] | ListEnumSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Source[] | ListEnumSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumSourceWithAggregatesFilter<$PrismaModel> | $Enums.Source
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSourceFilter<$PrismaModel>
    _max?: NestedEnumSourceFilter<$PrismaModel>
  }

  export type NestedEnumDirectionNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Direction | EnumDirectionFieldRefInput<$PrismaModel> | null
    in?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDirectionNullableWithAggregatesFilter<$PrismaModel> | $Enums.Direction | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDirectionNullableFilter<$PrismaModel>
    _max?: NestedEnumDirectionNullableFilter<$PrismaModel>
  }

  export type NestedEnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type Leave_requestCreateWithoutUserInput = {
    leaveType: $Enums.LeaveType
    status?: $Enums.LeaveStatus | null
    reason?: string | null
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    dates?: Leave_request_dateCreateNestedManyWithoutRequestInput
    approvedByUser?: UserCreateNestedOneWithoutApprovedRequestsInput
  }

  export type Leave_requestUncheckedCreateWithoutUserInput = {
    id?: number
    approvedBy?: number | null
    leaveType: $Enums.LeaveType
    status?: $Enums.LeaveStatus | null
    reason?: string | null
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    dates?: Leave_request_dateUncheckedCreateNestedManyWithoutRequestInput
  }

  export type Leave_requestCreateOrConnectWithoutUserInput = {
    where: Leave_requestWhereUniqueInput
    create: XOR<Leave_requestCreateWithoutUserInput, Leave_requestUncheckedCreateWithoutUserInput>
  }

  export type Leave_requestCreateManyUserInputEnvelope = {
    data: Leave_requestCreateManyUserInput | Leave_requestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type Leave_requestCreateWithoutApprovedByUserInput = {
    leaveType: $Enums.LeaveType
    status?: $Enums.LeaveStatus | null
    reason?: string | null
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    dates?: Leave_request_dateCreateNestedManyWithoutRequestInput
    user: UserCreateNestedOneWithoutLeaveRequestsInput
  }

  export type Leave_requestUncheckedCreateWithoutApprovedByUserInput = {
    id?: number
    userId: number
    leaveType: $Enums.LeaveType
    status?: $Enums.LeaveStatus | null
    reason?: string | null
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    dates?: Leave_request_dateUncheckedCreateNestedManyWithoutRequestInput
  }

  export type Leave_requestCreateOrConnectWithoutApprovedByUserInput = {
    where: Leave_requestWhereUniqueInput
    create: XOR<Leave_requestCreateWithoutApprovedByUserInput, Leave_requestUncheckedCreateWithoutApprovedByUserInput>
  }

  export type Leave_requestCreateManyApprovedByUserInputEnvelope = {
    data: Leave_requestCreateManyApprovedByUserInput | Leave_requestCreateManyApprovedByUserInput[]
    skipDuplicates?: boolean
  }

  export type Leave_balanceCreateWithoutUserInput = {
    year: number
    leaveType: $Enums.LeaveType
    balance: number
  }

  export type Leave_balanceUncheckedCreateWithoutUserInput = {
    id?: number
    year: number
    leaveType: $Enums.LeaveType
    balance: number
  }

  export type Leave_balanceCreateOrConnectWithoutUserInput = {
    where: Leave_balanceWhereUniqueInput
    create: XOR<Leave_balanceCreateWithoutUserInput, Leave_balanceUncheckedCreateWithoutUserInput>
  }

  export type Leave_balanceCreateManyUserInputEnvelope = {
    data: Leave_balanceCreateManyUserInput | Leave_balanceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PunchCreateWithoutUserInput = {
    eventTime: Date | string
    correctEventTime?: Date | string | null
    direction: $Enums.Direction
    source: $Enums.Source
    note?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    directionCorrected?: boolean
    originalDirection?: $Enums.Direction | null
    correctedBy?: string | null
    correctionNote?: string | null
    correctedAt?: Date | string | null
  }

  export type PunchUncheckedCreateWithoutUserInput = {
    id?: number
    eventTime: Date | string
    correctEventTime?: Date | string | null
    direction: $Enums.Direction
    source: $Enums.Source
    note?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    directionCorrected?: boolean
    originalDirection?: $Enums.Direction | null
    correctedBy?: string | null
    correctionNote?: string | null
    correctedAt?: Date | string | null
  }

  export type PunchCreateOrConnectWithoutUserInput = {
    where: PunchWhereUniqueInput
    create: XOR<PunchCreateWithoutUserInput, PunchUncheckedCreateWithoutUserInput>
  }

  export type PunchCreateManyUserInputEnvelope = {
    data: PunchCreateManyUserInput | PunchCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceDayCreateWithoutUserInput = {
    workDate: Date | string
    startTime?: string | null
    firstIn?: string | null
    lastOut?: string | null
    workedSeconds?: number
    notWorkingSeconds?: number
    overtimeSeconds?: number
    hadManual?: boolean
    status?: $Enums.AttendanceStatus
    calculatedAt?: Date | string
  }

  export type AttendanceDayUncheckedCreateWithoutUserInput = {
    workDate: Date | string
    startTime?: string | null
    firstIn?: string | null
    lastOut?: string | null
    workedSeconds?: number
    notWorkingSeconds?: number
    overtimeSeconds?: number
    hadManual?: boolean
    status?: $Enums.AttendanceStatus
    calculatedAt?: Date | string
  }

  export type AttendanceDayCreateOrConnectWithoutUserInput = {
    where: AttendanceDayWhereUniqueInput
    create: XOR<AttendanceDayCreateWithoutUserInput, AttendanceDayUncheckedCreateWithoutUserInput>
  }

  export type AttendanceDayCreateManyUserInputEnvelope = {
    data: AttendanceDayCreateManyUserInput | AttendanceDayCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SalaryConfigCreateWithoutUserInput = {
    basicSalary: number
    otRate?: number | null
    allowance?: number | null
    deduction?: number | null
    effectiveFrom?: Date | string
  }

  export type SalaryConfigUncheckedCreateWithoutUserInput = {
    id?: number
    basicSalary: number
    otRate?: number | null
    allowance?: number | null
    deduction?: number | null
    effectiveFrom?: Date | string
  }

  export type SalaryConfigCreateOrConnectWithoutUserInput = {
    where: SalaryConfigWhereUniqueInput
    create: XOR<SalaryConfigCreateWithoutUserInput, SalaryConfigUncheckedCreateWithoutUserInput>
  }

  export type SalaryConfigCreateManyUserInputEnvelope = {
    data: SalaryConfigCreateManyUserInput | SalaryConfigCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SalaryRecordCreateWithoutUserInput = {
    month: number
    year: number
    basicSalary: number
    totalLeave?: number
    leaveDeductions?: number
    overtimePay?: number
    netSalary: number
    generatedAt?: Date | string
  }

  export type SalaryRecordUncheckedCreateWithoutUserInput = {
    id?: number
    month: number
    year: number
    basicSalary: number
    totalLeave?: number
    leaveDeductions?: number
    overtimePay?: number
    netSalary: number
    generatedAt?: Date | string
  }

  export type SalaryRecordCreateOrConnectWithoutUserInput = {
    where: SalaryRecordWhereUniqueInput
    create: XOR<SalaryRecordCreateWithoutUserInput, SalaryRecordUncheckedCreateWithoutUserInput>
  }

  export type SalaryRecordCreateManyUserInputEnvelope = {
    data: SalaryRecordCreateManyUserInput | SalaryRecordCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type Leave_requestUpsertWithWhereUniqueWithoutUserInput = {
    where: Leave_requestWhereUniqueInput
    update: XOR<Leave_requestUpdateWithoutUserInput, Leave_requestUncheckedUpdateWithoutUserInput>
    create: XOR<Leave_requestCreateWithoutUserInput, Leave_requestUncheckedCreateWithoutUserInput>
  }

  export type Leave_requestUpdateWithWhereUniqueWithoutUserInput = {
    where: Leave_requestWhereUniqueInput
    data: XOR<Leave_requestUpdateWithoutUserInput, Leave_requestUncheckedUpdateWithoutUserInput>
  }

  export type Leave_requestUpdateManyWithWhereWithoutUserInput = {
    where: Leave_requestScalarWhereInput
    data: XOR<Leave_requestUpdateManyMutationInput, Leave_requestUncheckedUpdateManyWithoutUserInput>
  }

  export type Leave_requestScalarWhereInput = {
    AND?: Leave_requestScalarWhereInput | Leave_requestScalarWhereInput[]
    OR?: Leave_requestScalarWhereInput[]
    NOT?: Leave_requestScalarWhereInput | Leave_requestScalarWhereInput[]
    id?: IntFilter<"Leave_request"> | number
    userId?: IntFilter<"Leave_request"> | number
    approvedBy?: IntNullableFilter<"Leave_request"> | number | null
    leaveType?: EnumLeaveTypeFilter<"Leave_request"> | $Enums.LeaveType
    status?: EnumLeaveStatusNullableFilter<"Leave_request"> | $Enums.LeaveStatus | null
    reason?: StringNullableFilter<"Leave_request"> | string | null
    requestedAt?: DateTimeFilter<"Leave_request"> | Date | string
    approvedAt?: DateTimeNullableFilter<"Leave_request"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"Leave_request"> | Date | string | null
  }

  export type Leave_requestUpsertWithWhereUniqueWithoutApprovedByUserInput = {
    where: Leave_requestWhereUniqueInput
    update: XOR<Leave_requestUpdateWithoutApprovedByUserInput, Leave_requestUncheckedUpdateWithoutApprovedByUserInput>
    create: XOR<Leave_requestCreateWithoutApprovedByUserInput, Leave_requestUncheckedCreateWithoutApprovedByUserInput>
  }

  export type Leave_requestUpdateWithWhereUniqueWithoutApprovedByUserInput = {
    where: Leave_requestWhereUniqueInput
    data: XOR<Leave_requestUpdateWithoutApprovedByUserInput, Leave_requestUncheckedUpdateWithoutApprovedByUserInput>
  }

  export type Leave_requestUpdateManyWithWhereWithoutApprovedByUserInput = {
    where: Leave_requestScalarWhereInput
    data: XOR<Leave_requestUpdateManyMutationInput, Leave_requestUncheckedUpdateManyWithoutApprovedByUserInput>
  }

  export type Leave_balanceUpsertWithWhereUniqueWithoutUserInput = {
    where: Leave_balanceWhereUniqueInput
    update: XOR<Leave_balanceUpdateWithoutUserInput, Leave_balanceUncheckedUpdateWithoutUserInput>
    create: XOR<Leave_balanceCreateWithoutUserInput, Leave_balanceUncheckedCreateWithoutUserInput>
  }

  export type Leave_balanceUpdateWithWhereUniqueWithoutUserInput = {
    where: Leave_balanceWhereUniqueInput
    data: XOR<Leave_balanceUpdateWithoutUserInput, Leave_balanceUncheckedUpdateWithoutUserInput>
  }

  export type Leave_balanceUpdateManyWithWhereWithoutUserInput = {
    where: Leave_balanceScalarWhereInput
    data: XOR<Leave_balanceUpdateManyMutationInput, Leave_balanceUncheckedUpdateManyWithoutUserInput>
  }

  export type Leave_balanceScalarWhereInput = {
    AND?: Leave_balanceScalarWhereInput | Leave_balanceScalarWhereInput[]
    OR?: Leave_balanceScalarWhereInput[]
    NOT?: Leave_balanceScalarWhereInput | Leave_balanceScalarWhereInput[]
    id?: IntFilter<"Leave_balance"> | number
    userId?: IntFilter<"Leave_balance"> | number
    year?: IntFilter<"Leave_balance"> | number
    leaveType?: EnumLeaveTypeFilter<"Leave_balance"> | $Enums.LeaveType
    balance?: FloatFilter<"Leave_balance"> | number
  }

  export type PunchUpsertWithWhereUniqueWithoutUserInput = {
    where: PunchWhereUniqueInput
    update: XOR<PunchUpdateWithoutUserInput, PunchUncheckedUpdateWithoutUserInput>
    create: XOR<PunchCreateWithoutUserInput, PunchUncheckedCreateWithoutUserInput>
  }

  export type PunchUpdateWithWhereUniqueWithoutUserInput = {
    where: PunchWhereUniqueInput
    data: XOR<PunchUpdateWithoutUserInput, PunchUncheckedUpdateWithoutUserInput>
  }

  export type PunchUpdateManyWithWhereWithoutUserInput = {
    where: PunchScalarWhereInput
    data: XOR<PunchUpdateManyMutationInput, PunchUncheckedUpdateManyWithoutUserInput>
  }

  export type PunchScalarWhereInput = {
    AND?: PunchScalarWhereInput | PunchScalarWhereInput[]
    OR?: PunchScalarWhereInput[]
    NOT?: PunchScalarWhereInput | PunchScalarWhereInput[]
    id?: IntFilter<"Punch"> | number
    employeeId?: StringFilter<"Punch"> | string
    eventTime?: DateTimeFilter<"Punch"> | Date | string
    correctEventTime?: DateTimeNullableFilter<"Punch"> | Date | string | null
    direction?: EnumDirectionFilter<"Punch"> | $Enums.Direction
    source?: EnumSourceFilter<"Punch"> | $Enums.Source
    note?: StringNullableFilter<"Punch"> | string | null
    createdBy?: StringNullableFilter<"Punch"> | string | null
    createdAt?: DateTimeFilter<"Punch"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Punch"> | Date | string | null
    directionCorrected?: BoolFilter<"Punch"> | boolean
    originalDirection?: EnumDirectionNullableFilter<"Punch"> | $Enums.Direction | null
    correctedBy?: StringNullableFilter<"Punch"> | string | null
    correctionNote?: StringNullableFilter<"Punch"> | string | null
    correctedAt?: DateTimeNullableFilter<"Punch"> | Date | string | null
  }

  export type AttendanceDayUpsertWithWhereUniqueWithoutUserInput = {
    where: AttendanceDayWhereUniqueInput
    update: XOR<AttendanceDayUpdateWithoutUserInput, AttendanceDayUncheckedUpdateWithoutUserInput>
    create: XOR<AttendanceDayCreateWithoutUserInput, AttendanceDayUncheckedCreateWithoutUserInput>
  }

  export type AttendanceDayUpdateWithWhereUniqueWithoutUserInput = {
    where: AttendanceDayWhereUniqueInput
    data: XOR<AttendanceDayUpdateWithoutUserInput, AttendanceDayUncheckedUpdateWithoutUserInput>
  }

  export type AttendanceDayUpdateManyWithWhereWithoutUserInput = {
    where: AttendanceDayScalarWhereInput
    data: XOR<AttendanceDayUpdateManyMutationInput, AttendanceDayUncheckedUpdateManyWithoutUserInput>
  }

  export type AttendanceDayScalarWhereInput = {
    AND?: AttendanceDayScalarWhereInput | AttendanceDayScalarWhereInput[]
    OR?: AttendanceDayScalarWhereInput[]
    NOT?: AttendanceDayScalarWhereInput | AttendanceDayScalarWhereInput[]
    employeeId?: StringFilter<"AttendanceDay"> | string
    workDate?: DateTimeFilter<"AttendanceDay"> | Date | string
    startTime?: StringNullableFilter<"AttendanceDay"> | string | null
    firstIn?: StringNullableFilter<"AttendanceDay"> | string | null
    lastOut?: StringNullableFilter<"AttendanceDay"> | string | null
    workedSeconds?: IntFilter<"AttendanceDay"> | number
    notWorkingSeconds?: IntFilter<"AttendanceDay"> | number
    overtimeSeconds?: IntFilter<"AttendanceDay"> | number
    hadManual?: BoolFilter<"AttendanceDay"> | boolean
    status?: EnumAttendanceStatusFilter<"AttendanceDay"> | $Enums.AttendanceStatus
    calculatedAt?: DateTimeFilter<"AttendanceDay"> | Date | string
  }

  export type SalaryConfigUpsertWithWhereUniqueWithoutUserInput = {
    where: SalaryConfigWhereUniqueInput
    update: XOR<SalaryConfigUpdateWithoutUserInput, SalaryConfigUncheckedUpdateWithoutUserInput>
    create: XOR<SalaryConfigCreateWithoutUserInput, SalaryConfigUncheckedCreateWithoutUserInput>
  }

  export type SalaryConfigUpdateWithWhereUniqueWithoutUserInput = {
    where: SalaryConfigWhereUniqueInput
    data: XOR<SalaryConfigUpdateWithoutUserInput, SalaryConfigUncheckedUpdateWithoutUserInput>
  }

  export type SalaryConfigUpdateManyWithWhereWithoutUserInput = {
    where: SalaryConfigScalarWhereInput
    data: XOR<SalaryConfigUpdateManyMutationInput, SalaryConfigUncheckedUpdateManyWithoutUserInput>
  }

  export type SalaryConfigScalarWhereInput = {
    AND?: SalaryConfigScalarWhereInput | SalaryConfigScalarWhereInput[]
    OR?: SalaryConfigScalarWhereInput[]
    NOT?: SalaryConfigScalarWhereInput | SalaryConfigScalarWhereInput[]
    id?: IntFilter<"SalaryConfig"> | number
    userId?: IntFilter<"SalaryConfig"> | number
    basicSalary?: FloatFilter<"SalaryConfig"> | number
    otRate?: FloatNullableFilter<"SalaryConfig"> | number | null
    allowance?: FloatNullableFilter<"SalaryConfig"> | number | null
    deduction?: FloatNullableFilter<"SalaryConfig"> | number | null
    effectiveFrom?: DateTimeFilter<"SalaryConfig"> | Date | string
  }

  export type SalaryRecordUpsertWithWhereUniqueWithoutUserInput = {
    where: SalaryRecordWhereUniqueInput
    update: XOR<SalaryRecordUpdateWithoutUserInput, SalaryRecordUncheckedUpdateWithoutUserInput>
    create: XOR<SalaryRecordCreateWithoutUserInput, SalaryRecordUncheckedCreateWithoutUserInput>
  }

  export type SalaryRecordUpdateWithWhereUniqueWithoutUserInput = {
    where: SalaryRecordWhereUniqueInput
    data: XOR<SalaryRecordUpdateWithoutUserInput, SalaryRecordUncheckedUpdateWithoutUserInput>
  }

  export type SalaryRecordUpdateManyWithWhereWithoutUserInput = {
    where: SalaryRecordScalarWhereInput
    data: XOR<SalaryRecordUpdateManyMutationInput, SalaryRecordUncheckedUpdateManyWithoutUserInput>
  }

  export type SalaryRecordScalarWhereInput = {
    AND?: SalaryRecordScalarWhereInput | SalaryRecordScalarWhereInput[]
    OR?: SalaryRecordScalarWhereInput[]
    NOT?: SalaryRecordScalarWhereInput | SalaryRecordScalarWhereInput[]
    id?: IntFilter<"SalaryRecord"> | number
    userId?: IntFilter<"SalaryRecord"> | number
    month?: IntFilter<"SalaryRecord"> | number
    year?: IntFilter<"SalaryRecord"> | number
    basicSalary?: FloatFilter<"SalaryRecord"> | number
    totalLeave?: IntFilter<"SalaryRecord"> | number
    leaveDeductions?: FloatFilter<"SalaryRecord"> | number
    overtimePay?: FloatFilter<"SalaryRecord"> | number
    netSalary?: FloatFilter<"SalaryRecord"> | number
    generatedAt?: DateTimeFilter<"SalaryRecord"> | Date | string
  }

  export type Leave_request_dateCreateWithoutRequestInput = {
    leaveDate: Date | string
    isHalfDay?: boolean
    halfdayType?: $Enums.HalfdayType | null
  }

  export type Leave_request_dateUncheckedCreateWithoutRequestInput = {
    id?: number
    leaveDate: Date | string
    isHalfDay?: boolean
    halfdayType?: $Enums.HalfdayType | null
  }

  export type Leave_request_dateCreateOrConnectWithoutRequestInput = {
    where: Leave_request_dateWhereUniqueInput
    create: XOR<Leave_request_dateCreateWithoutRequestInput, Leave_request_dateUncheckedCreateWithoutRequestInput>
  }

  export type Leave_request_dateCreateManyRequestInputEnvelope = {
    data: Leave_request_dateCreateManyRequestInput | Leave_request_dateCreateManyRequestInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutLeaveRequestsInput = {
    email: string
    password: string
    name: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshToken?: string | null
    employeeId?: string | null
    cardNumber?: string | null
    validFrom?: Date | string | null
    validTo?: Date | string | null
    epfNo?: string | null
    nic?: string | null
    jobPosition?: string | null
    imagePath?: string | null
    active?: boolean
    joinDate?: Date | string | null
    address?: string | null
    approvedRequests?: Leave_requestCreateNestedManyWithoutApprovedByUserInput
    leaveBalances?: Leave_balanceCreateNestedManyWithoutUserInput
    punches?: PunchCreateNestedManyWithoutUserInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutUserInput
    salaryConfigs?: SalaryConfigCreateNestedManyWithoutUserInput
    salaryRecords?: SalaryRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLeaveRequestsInput = {
    id?: number
    email: string
    password: string
    name: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshToken?: string | null
    employeeId?: string | null
    cardNumber?: string | null
    validFrom?: Date | string | null
    validTo?: Date | string | null
    epfNo?: string | null
    nic?: string | null
    jobPosition?: string | null
    imagePath?: string | null
    active?: boolean
    joinDate?: Date | string | null
    address?: string | null
    approvedRequests?: Leave_requestUncheckedCreateNestedManyWithoutApprovedByUserInput
    leaveBalances?: Leave_balanceUncheckedCreateNestedManyWithoutUserInput
    punches?: PunchUncheckedCreateNestedManyWithoutUserInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutUserInput
    salaryConfigs?: SalaryConfigUncheckedCreateNestedManyWithoutUserInput
    salaryRecords?: SalaryRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLeaveRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeaveRequestsInput, UserUncheckedCreateWithoutLeaveRequestsInput>
  }

  export type UserCreateWithoutApprovedRequestsInput = {
    email: string
    password: string
    name: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshToken?: string | null
    employeeId?: string | null
    cardNumber?: string | null
    validFrom?: Date | string | null
    validTo?: Date | string | null
    epfNo?: string | null
    nic?: string | null
    jobPosition?: string | null
    imagePath?: string | null
    active?: boolean
    joinDate?: Date | string | null
    address?: string | null
    leaveRequests?: Leave_requestCreateNestedManyWithoutUserInput
    leaveBalances?: Leave_balanceCreateNestedManyWithoutUserInput
    punches?: PunchCreateNestedManyWithoutUserInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutUserInput
    salaryConfigs?: SalaryConfigCreateNestedManyWithoutUserInput
    salaryRecords?: SalaryRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutApprovedRequestsInput = {
    id?: number
    email: string
    password: string
    name: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshToken?: string | null
    employeeId?: string | null
    cardNumber?: string | null
    validFrom?: Date | string | null
    validTo?: Date | string | null
    epfNo?: string | null
    nic?: string | null
    jobPosition?: string | null
    imagePath?: string | null
    active?: boolean
    joinDate?: Date | string | null
    address?: string | null
    leaveRequests?: Leave_requestUncheckedCreateNestedManyWithoutUserInput
    leaveBalances?: Leave_balanceUncheckedCreateNestedManyWithoutUserInput
    punches?: PunchUncheckedCreateNestedManyWithoutUserInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutUserInput
    salaryConfigs?: SalaryConfigUncheckedCreateNestedManyWithoutUserInput
    salaryRecords?: SalaryRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutApprovedRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedRequestsInput, UserUncheckedCreateWithoutApprovedRequestsInput>
  }

  export type Leave_request_dateUpsertWithWhereUniqueWithoutRequestInput = {
    where: Leave_request_dateWhereUniqueInput
    update: XOR<Leave_request_dateUpdateWithoutRequestInput, Leave_request_dateUncheckedUpdateWithoutRequestInput>
    create: XOR<Leave_request_dateCreateWithoutRequestInput, Leave_request_dateUncheckedCreateWithoutRequestInput>
  }

  export type Leave_request_dateUpdateWithWhereUniqueWithoutRequestInput = {
    where: Leave_request_dateWhereUniqueInput
    data: XOR<Leave_request_dateUpdateWithoutRequestInput, Leave_request_dateUncheckedUpdateWithoutRequestInput>
  }

  export type Leave_request_dateUpdateManyWithWhereWithoutRequestInput = {
    where: Leave_request_dateScalarWhereInput
    data: XOR<Leave_request_dateUpdateManyMutationInput, Leave_request_dateUncheckedUpdateManyWithoutRequestInput>
  }

  export type Leave_request_dateScalarWhereInput = {
    AND?: Leave_request_dateScalarWhereInput | Leave_request_dateScalarWhereInput[]
    OR?: Leave_request_dateScalarWhereInput[]
    NOT?: Leave_request_dateScalarWhereInput | Leave_request_dateScalarWhereInput[]
    id?: IntFilter<"Leave_request_date"> | number
    requestId?: IntFilter<"Leave_request_date"> | number
    leaveDate?: DateTimeFilter<"Leave_request_date"> | Date | string
    isHalfDay?: BoolFilter<"Leave_request_date"> | boolean
    halfdayType?: EnumHalfdayTypeNullableFilter<"Leave_request_date"> | $Enums.HalfdayType | null
  }

  export type UserUpsertWithoutLeaveRequestsInput = {
    update: XOR<UserUpdateWithoutLeaveRequestsInput, UserUncheckedUpdateWithoutLeaveRequestsInput>
    create: XOR<UserCreateWithoutLeaveRequestsInput, UserUncheckedCreateWithoutLeaveRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeaveRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeaveRequestsInput, UserUncheckedUpdateWithoutLeaveRequestsInput>
  }

  export type UserUpdateWithoutLeaveRequestsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    epfNo?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    jobPosition?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    approvedRequests?: Leave_requestUpdateManyWithoutApprovedByUserNestedInput
    leaveBalances?: Leave_balanceUpdateManyWithoutUserNestedInput
    punches?: PunchUpdateManyWithoutUserNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutUserNestedInput
    salaryConfigs?: SalaryConfigUpdateManyWithoutUserNestedInput
    salaryRecords?: SalaryRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLeaveRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    epfNo?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    jobPosition?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    approvedRequests?: Leave_requestUncheckedUpdateManyWithoutApprovedByUserNestedInput
    leaveBalances?: Leave_balanceUncheckedUpdateManyWithoutUserNestedInput
    punches?: PunchUncheckedUpdateManyWithoutUserNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutUserNestedInput
    salaryConfigs?: SalaryConfigUncheckedUpdateManyWithoutUserNestedInput
    salaryRecords?: SalaryRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutApprovedRequestsInput = {
    update: XOR<UserUpdateWithoutApprovedRequestsInput, UserUncheckedUpdateWithoutApprovedRequestsInput>
    create: XOR<UserCreateWithoutApprovedRequestsInput, UserUncheckedCreateWithoutApprovedRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedRequestsInput, UserUncheckedUpdateWithoutApprovedRequestsInput>
  }

  export type UserUpdateWithoutApprovedRequestsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    epfNo?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    jobPosition?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    leaveRequests?: Leave_requestUpdateManyWithoutUserNestedInput
    leaveBalances?: Leave_balanceUpdateManyWithoutUserNestedInput
    punches?: PunchUpdateManyWithoutUserNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutUserNestedInput
    salaryConfigs?: SalaryConfigUpdateManyWithoutUserNestedInput
    salaryRecords?: SalaryRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    epfNo?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    jobPosition?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    leaveRequests?: Leave_requestUncheckedUpdateManyWithoutUserNestedInput
    leaveBalances?: Leave_balanceUncheckedUpdateManyWithoutUserNestedInput
    punches?: PunchUncheckedUpdateManyWithoutUserNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutUserNestedInput
    salaryConfigs?: SalaryConfigUncheckedUpdateManyWithoutUserNestedInput
    salaryRecords?: SalaryRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type Leave_requestCreateWithoutDatesInput = {
    leaveType: $Enums.LeaveType
    status?: $Enums.LeaveStatus | null
    reason?: string | null
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    user: UserCreateNestedOneWithoutLeaveRequestsInput
    approvedByUser?: UserCreateNestedOneWithoutApprovedRequestsInput
  }

  export type Leave_requestUncheckedCreateWithoutDatesInput = {
    id?: number
    userId: number
    approvedBy?: number | null
    leaveType: $Enums.LeaveType
    status?: $Enums.LeaveStatus | null
    reason?: string | null
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
  }

  export type Leave_requestCreateOrConnectWithoutDatesInput = {
    where: Leave_requestWhereUniqueInput
    create: XOR<Leave_requestCreateWithoutDatesInput, Leave_requestUncheckedCreateWithoutDatesInput>
  }

  export type Leave_requestUpsertWithoutDatesInput = {
    update: XOR<Leave_requestUpdateWithoutDatesInput, Leave_requestUncheckedUpdateWithoutDatesInput>
    create: XOR<Leave_requestCreateWithoutDatesInput, Leave_requestUncheckedCreateWithoutDatesInput>
    where?: Leave_requestWhereInput
  }

  export type Leave_requestUpdateToOneWithWhereWithoutDatesInput = {
    where?: Leave_requestWhereInput
    data: XOR<Leave_requestUpdateWithoutDatesInput, Leave_requestUncheckedUpdateWithoutDatesInput>
  }

  export type Leave_requestUpdateWithoutDatesInput = {
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    status?: NullableEnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutLeaveRequestsNestedInput
    approvedByUser?: UserUpdateOneWithoutApprovedRequestsNestedInput
  }

  export type Leave_requestUncheckedUpdateWithoutDatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    status?: NullableEnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateWithoutLeaveBalancesInput = {
    email: string
    password: string
    name: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshToken?: string | null
    employeeId?: string | null
    cardNumber?: string | null
    validFrom?: Date | string | null
    validTo?: Date | string | null
    epfNo?: string | null
    nic?: string | null
    jobPosition?: string | null
    imagePath?: string | null
    active?: boolean
    joinDate?: Date | string | null
    address?: string | null
    leaveRequests?: Leave_requestCreateNestedManyWithoutUserInput
    approvedRequests?: Leave_requestCreateNestedManyWithoutApprovedByUserInput
    punches?: PunchCreateNestedManyWithoutUserInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutUserInput
    salaryConfigs?: SalaryConfigCreateNestedManyWithoutUserInput
    salaryRecords?: SalaryRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLeaveBalancesInput = {
    id?: number
    email: string
    password: string
    name: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshToken?: string | null
    employeeId?: string | null
    cardNumber?: string | null
    validFrom?: Date | string | null
    validTo?: Date | string | null
    epfNo?: string | null
    nic?: string | null
    jobPosition?: string | null
    imagePath?: string | null
    active?: boolean
    joinDate?: Date | string | null
    address?: string | null
    leaveRequests?: Leave_requestUncheckedCreateNestedManyWithoutUserInput
    approvedRequests?: Leave_requestUncheckedCreateNestedManyWithoutApprovedByUserInput
    punches?: PunchUncheckedCreateNestedManyWithoutUserInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutUserInput
    salaryConfigs?: SalaryConfigUncheckedCreateNestedManyWithoutUserInput
    salaryRecords?: SalaryRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLeaveBalancesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeaveBalancesInput, UserUncheckedCreateWithoutLeaveBalancesInput>
  }

  export type UserUpsertWithoutLeaveBalancesInput = {
    update: XOR<UserUpdateWithoutLeaveBalancesInput, UserUncheckedUpdateWithoutLeaveBalancesInput>
    create: XOR<UserCreateWithoutLeaveBalancesInput, UserUncheckedCreateWithoutLeaveBalancesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeaveBalancesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeaveBalancesInput, UserUncheckedUpdateWithoutLeaveBalancesInput>
  }

  export type UserUpdateWithoutLeaveBalancesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    epfNo?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    jobPosition?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    leaveRequests?: Leave_requestUpdateManyWithoutUserNestedInput
    approvedRequests?: Leave_requestUpdateManyWithoutApprovedByUserNestedInput
    punches?: PunchUpdateManyWithoutUserNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutUserNestedInput
    salaryConfigs?: SalaryConfigUpdateManyWithoutUserNestedInput
    salaryRecords?: SalaryRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLeaveBalancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    epfNo?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    jobPosition?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    leaveRequests?: Leave_requestUncheckedUpdateManyWithoutUserNestedInput
    approvedRequests?: Leave_requestUncheckedUpdateManyWithoutApprovedByUserNestedInput
    punches?: PunchUncheckedUpdateManyWithoutUserNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutUserNestedInput
    salaryConfigs?: SalaryConfigUncheckedUpdateManyWithoutUserNestedInput
    salaryRecords?: SalaryRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPunchesInput = {
    email: string
    password: string
    name: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshToken?: string | null
    employeeId?: string | null
    cardNumber?: string | null
    validFrom?: Date | string | null
    validTo?: Date | string | null
    epfNo?: string | null
    nic?: string | null
    jobPosition?: string | null
    imagePath?: string | null
    active?: boolean
    joinDate?: Date | string | null
    address?: string | null
    leaveRequests?: Leave_requestCreateNestedManyWithoutUserInput
    approvedRequests?: Leave_requestCreateNestedManyWithoutApprovedByUserInput
    leaveBalances?: Leave_balanceCreateNestedManyWithoutUserInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutUserInput
    salaryConfigs?: SalaryConfigCreateNestedManyWithoutUserInput
    salaryRecords?: SalaryRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPunchesInput = {
    id?: number
    email: string
    password: string
    name: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshToken?: string | null
    employeeId?: string | null
    cardNumber?: string | null
    validFrom?: Date | string | null
    validTo?: Date | string | null
    epfNo?: string | null
    nic?: string | null
    jobPosition?: string | null
    imagePath?: string | null
    active?: boolean
    joinDate?: Date | string | null
    address?: string | null
    leaveRequests?: Leave_requestUncheckedCreateNestedManyWithoutUserInput
    approvedRequests?: Leave_requestUncheckedCreateNestedManyWithoutApprovedByUserInput
    leaveBalances?: Leave_balanceUncheckedCreateNestedManyWithoutUserInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutUserInput
    salaryConfigs?: SalaryConfigUncheckedCreateNestedManyWithoutUserInput
    salaryRecords?: SalaryRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPunchesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPunchesInput, UserUncheckedCreateWithoutPunchesInput>
  }

  export type UserUpsertWithoutPunchesInput = {
    update: XOR<UserUpdateWithoutPunchesInput, UserUncheckedUpdateWithoutPunchesInput>
    create: XOR<UserCreateWithoutPunchesInput, UserUncheckedCreateWithoutPunchesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPunchesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPunchesInput, UserUncheckedUpdateWithoutPunchesInput>
  }

  export type UserUpdateWithoutPunchesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    epfNo?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    jobPosition?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    leaveRequests?: Leave_requestUpdateManyWithoutUserNestedInput
    approvedRequests?: Leave_requestUpdateManyWithoutApprovedByUserNestedInput
    leaveBalances?: Leave_balanceUpdateManyWithoutUserNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutUserNestedInput
    salaryConfigs?: SalaryConfigUpdateManyWithoutUserNestedInput
    salaryRecords?: SalaryRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPunchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    epfNo?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    jobPosition?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    leaveRequests?: Leave_requestUncheckedUpdateManyWithoutUserNestedInput
    approvedRequests?: Leave_requestUncheckedUpdateManyWithoutApprovedByUserNestedInput
    leaveBalances?: Leave_balanceUncheckedUpdateManyWithoutUserNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutUserNestedInput
    salaryConfigs?: SalaryConfigUncheckedUpdateManyWithoutUserNestedInput
    salaryRecords?: SalaryRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAttendanceDaysInput = {
    email: string
    password: string
    name: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshToken?: string | null
    employeeId?: string | null
    cardNumber?: string | null
    validFrom?: Date | string | null
    validTo?: Date | string | null
    epfNo?: string | null
    nic?: string | null
    jobPosition?: string | null
    imagePath?: string | null
    active?: boolean
    joinDate?: Date | string | null
    address?: string | null
    leaveRequests?: Leave_requestCreateNestedManyWithoutUserInput
    approvedRequests?: Leave_requestCreateNestedManyWithoutApprovedByUserInput
    leaveBalances?: Leave_balanceCreateNestedManyWithoutUserInput
    punches?: PunchCreateNestedManyWithoutUserInput
    salaryConfigs?: SalaryConfigCreateNestedManyWithoutUserInput
    salaryRecords?: SalaryRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAttendanceDaysInput = {
    id?: number
    email: string
    password: string
    name: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshToken?: string | null
    employeeId?: string | null
    cardNumber?: string | null
    validFrom?: Date | string | null
    validTo?: Date | string | null
    epfNo?: string | null
    nic?: string | null
    jobPosition?: string | null
    imagePath?: string | null
    active?: boolean
    joinDate?: Date | string | null
    address?: string | null
    leaveRequests?: Leave_requestUncheckedCreateNestedManyWithoutUserInput
    approvedRequests?: Leave_requestUncheckedCreateNestedManyWithoutApprovedByUserInput
    leaveBalances?: Leave_balanceUncheckedCreateNestedManyWithoutUserInput
    punches?: PunchUncheckedCreateNestedManyWithoutUserInput
    salaryConfigs?: SalaryConfigUncheckedCreateNestedManyWithoutUserInput
    salaryRecords?: SalaryRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAttendanceDaysInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttendanceDaysInput, UserUncheckedCreateWithoutAttendanceDaysInput>
  }

  export type UserUpsertWithoutAttendanceDaysInput = {
    update: XOR<UserUpdateWithoutAttendanceDaysInput, UserUncheckedUpdateWithoutAttendanceDaysInput>
    create: XOR<UserCreateWithoutAttendanceDaysInput, UserUncheckedCreateWithoutAttendanceDaysInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttendanceDaysInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttendanceDaysInput, UserUncheckedUpdateWithoutAttendanceDaysInput>
  }

  export type UserUpdateWithoutAttendanceDaysInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    epfNo?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    jobPosition?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    leaveRequests?: Leave_requestUpdateManyWithoutUserNestedInput
    approvedRequests?: Leave_requestUpdateManyWithoutApprovedByUserNestedInput
    leaveBalances?: Leave_balanceUpdateManyWithoutUserNestedInput
    punches?: PunchUpdateManyWithoutUserNestedInput
    salaryConfigs?: SalaryConfigUpdateManyWithoutUserNestedInput
    salaryRecords?: SalaryRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAttendanceDaysInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    epfNo?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    jobPosition?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    leaveRequests?: Leave_requestUncheckedUpdateManyWithoutUserNestedInput
    approvedRequests?: Leave_requestUncheckedUpdateManyWithoutApprovedByUserNestedInput
    leaveBalances?: Leave_balanceUncheckedUpdateManyWithoutUserNestedInput
    punches?: PunchUncheckedUpdateManyWithoutUserNestedInput
    salaryConfigs?: SalaryConfigUncheckedUpdateManyWithoutUserNestedInput
    salaryRecords?: SalaryRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSalaryConfigsInput = {
    email: string
    password: string
    name: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshToken?: string | null
    employeeId?: string | null
    cardNumber?: string | null
    validFrom?: Date | string | null
    validTo?: Date | string | null
    epfNo?: string | null
    nic?: string | null
    jobPosition?: string | null
    imagePath?: string | null
    active?: boolean
    joinDate?: Date | string | null
    address?: string | null
    leaveRequests?: Leave_requestCreateNestedManyWithoutUserInput
    approvedRequests?: Leave_requestCreateNestedManyWithoutApprovedByUserInput
    leaveBalances?: Leave_balanceCreateNestedManyWithoutUserInput
    punches?: PunchCreateNestedManyWithoutUserInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutUserInput
    salaryRecords?: SalaryRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSalaryConfigsInput = {
    id?: number
    email: string
    password: string
    name: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshToken?: string | null
    employeeId?: string | null
    cardNumber?: string | null
    validFrom?: Date | string | null
    validTo?: Date | string | null
    epfNo?: string | null
    nic?: string | null
    jobPosition?: string | null
    imagePath?: string | null
    active?: boolean
    joinDate?: Date | string | null
    address?: string | null
    leaveRequests?: Leave_requestUncheckedCreateNestedManyWithoutUserInput
    approvedRequests?: Leave_requestUncheckedCreateNestedManyWithoutApprovedByUserInput
    leaveBalances?: Leave_balanceUncheckedCreateNestedManyWithoutUserInput
    punches?: PunchUncheckedCreateNestedManyWithoutUserInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutUserInput
    salaryRecords?: SalaryRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSalaryConfigsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSalaryConfigsInput, UserUncheckedCreateWithoutSalaryConfigsInput>
  }

  export type UserUpsertWithoutSalaryConfigsInput = {
    update: XOR<UserUpdateWithoutSalaryConfigsInput, UserUncheckedUpdateWithoutSalaryConfigsInput>
    create: XOR<UserCreateWithoutSalaryConfigsInput, UserUncheckedCreateWithoutSalaryConfigsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSalaryConfigsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSalaryConfigsInput, UserUncheckedUpdateWithoutSalaryConfigsInput>
  }

  export type UserUpdateWithoutSalaryConfigsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    epfNo?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    jobPosition?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    leaveRequests?: Leave_requestUpdateManyWithoutUserNestedInput
    approvedRequests?: Leave_requestUpdateManyWithoutApprovedByUserNestedInput
    leaveBalances?: Leave_balanceUpdateManyWithoutUserNestedInput
    punches?: PunchUpdateManyWithoutUserNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutUserNestedInput
    salaryRecords?: SalaryRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSalaryConfigsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    epfNo?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    jobPosition?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    leaveRequests?: Leave_requestUncheckedUpdateManyWithoutUserNestedInput
    approvedRequests?: Leave_requestUncheckedUpdateManyWithoutApprovedByUserNestedInput
    leaveBalances?: Leave_balanceUncheckedUpdateManyWithoutUserNestedInput
    punches?: PunchUncheckedUpdateManyWithoutUserNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutUserNestedInput
    salaryRecords?: SalaryRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSalaryRecordsInput = {
    email: string
    password: string
    name: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshToken?: string | null
    employeeId?: string | null
    cardNumber?: string | null
    validFrom?: Date | string | null
    validTo?: Date | string | null
    epfNo?: string | null
    nic?: string | null
    jobPosition?: string | null
    imagePath?: string | null
    active?: boolean
    joinDate?: Date | string | null
    address?: string | null
    leaveRequests?: Leave_requestCreateNestedManyWithoutUserInput
    approvedRequests?: Leave_requestCreateNestedManyWithoutApprovedByUserInput
    leaveBalances?: Leave_balanceCreateNestedManyWithoutUserInput
    punches?: PunchCreateNestedManyWithoutUserInput
    attendanceDays?: AttendanceDayCreateNestedManyWithoutUserInput
    salaryConfigs?: SalaryConfigCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSalaryRecordsInput = {
    id?: number
    email: string
    password: string
    name: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshToken?: string | null
    employeeId?: string | null
    cardNumber?: string | null
    validFrom?: Date | string | null
    validTo?: Date | string | null
    epfNo?: string | null
    nic?: string | null
    jobPosition?: string | null
    imagePath?: string | null
    active?: boolean
    joinDate?: Date | string | null
    address?: string | null
    leaveRequests?: Leave_requestUncheckedCreateNestedManyWithoutUserInput
    approvedRequests?: Leave_requestUncheckedCreateNestedManyWithoutApprovedByUserInput
    leaveBalances?: Leave_balanceUncheckedCreateNestedManyWithoutUserInput
    punches?: PunchUncheckedCreateNestedManyWithoutUserInput
    attendanceDays?: AttendanceDayUncheckedCreateNestedManyWithoutUserInput
    salaryConfigs?: SalaryConfigUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSalaryRecordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSalaryRecordsInput, UserUncheckedCreateWithoutSalaryRecordsInput>
  }

  export type UserUpsertWithoutSalaryRecordsInput = {
    update: XOR<UserUpdateWithoutSalaryRecordsInput, UserUncheckedUpdateWithoutSalaryRecordsInput>
    create: XOR<UserCreateWithoutSalaryRecordsInput, UserUncheckedCreateWithoutSalaryRecordsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSalaryRecordsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSalaryRecordsInput, UserUncheckedUpdateWithoutSalaryRecordsInput>
  }

  export type UserUpdateWithoutSalaryRecordsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    epfNo?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    jobPosition?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    leaveRequests?: Leave_requestUpdateManyWithoutUserNestedInput
    approvedRequests?: Leave_requestUpdateManyWithoutApprovedByUserNestedInput
    leaveBalances?: Leave_balanceUpdateManyWithoutUserNestedInput
    punches?: PunchUpdateManyWithoutUserNestedInput
    attendanceDays?: AttendanceDayUpdateManyWithoutUserNestedInput
    salaryConfigs?: SalaryConfigUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSalaryRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    epfNo?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    jobPosition?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    leaveRequests?: Leave_requestUncheckedUpdateManyWithoutUserNestedInput
    approvedRequests?: Leave_requestUncheckedUpdateManyWithoutApprovedByUserNestedInput
    leaveBalances?: Leave_balanceUncheckedUpdateManyWithoutUserNestedInput
    punches?: PunchUncheckedUpdateManyWithoutUserNestedInput
    attendanceDays?: AttendanceDayUncheckedUpdateManyWithoutUserNestedInput
    salaryConfigs?: SalaryConfigUncheckedUpdateManyWithoutUserNestedInput
  }

  export type Leave_requestCreateManyUserInput = {
    id?: number
    approvedBy?: number | null
    leaveType: $Enums.LeaveType
    status?: $Enums.LeaveStatus | null
    reason?: string | null
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
  }

  export type Leave_requestCreateManyApprovedByUserInput = {
    id?: number
    userId: number
    leaveType: $Enums.LeaveType
    status?: $Enums.LeaveStatus | null
    reason?: string | null
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
  }

  export type Leave_balanceCreateManyUserInput = {
    id?: number
    year: number
    leaveType: $Enums.LeaveType
    balance: number
  }

  export type PunchCreateManyUserInput = {
    id?: number
    eventTime: Date | string
    correctEventTime?: Date | string | null
    direction: $Enums.Direction
    source: $Enums.Source
    note?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    directionCorrected?: boolean
    originalDirection?: $Enums.Direction | null
    correctedBy?: string | null
    correctionNote?: string | null
    correctedAt?: Date | string | null
  }

  export type AttendanceDayCreateManyUserInput = {
    workDate: Date | string
    startTime?: string | null
    firstIn?: string | null
    lastOut?: string | null
    workedSeconds?: number
    notWorkingSeconds?: number
    overtimeSeconds?: number
    hadManual?: boolean
    status?: $Enums.AttendanceStatus
    calculatedAt?: Date | string
  }

  export type SalaryConfigCreateManyUserInput = {
    id?: number
    basicSalary: number
    otRate?: number | null
    allowance?: number | null
    deduction?: number | null
    effectiveFrom?: Date | string
  }

  export type SalaryRecordCreateManyUserInput = {
    id?: number
    month: number
    year: number
    basicSalary: number
    totalLeave?: number
    leaveDeductions?: number
    overtimePay?: number
    netSalary: number
    generatedAt?: Date | string
  }

  export type Leave_requestUpdateWithoutUserInput = {
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    status?: NullableEnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dates?: Leave_request_dateUpdateManyWithoutRequestNestedInput
    approvedByUser?: UserUpdateOneWithoutApprovedRequestsNestedInput
  }

  export type Leave_requestUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    status?: NullableEnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dates?: Leave_request_dateUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type Leave_requestUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    status?: NullableEnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Leave_requestUpdateWithoutApprovedByUserInput = {
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    status?: NullableEnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dates?: Leave_request_dateUpdateManyWithoutRequestNestedInput
    user?: UserUpdateOneRequiredWithoutLeaveRequestsNestedInput
  }

  export type Leave_requestUncheckedUpdateWithoutApprovedByUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    status?: NullableEnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dates?: Leave_request_dateUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type Leave_requestUncheckedUpdateManyWithoutApprovedByUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    status?: NullableEnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Leave_balanceUpdateWithoutUserInput = {
    year?: IntFieldUpdateOperationsInput | number
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    balance?: FloatFieldUpdateOperationsInput | number
  }

  export type Leave_balanceUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    balance?: FloatFieldUpdateOperationsInput | number
  }

  export type Leave_balanceUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    balance?: FloatFieldUpdateOperationsInput | number
  }

  export type PunchUpdateWithoutUserInput = {
    eventTime?: DateTimeFieldUpdateOperationsInput | Date | string
    correctEventTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direction?: EnumDirectionFieldUpdateOperationsInput | $Enums.Direction
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directionCorrected?: BoolFieldUpdateOperationsInput | boolean
    originalDirection?: NullableEnumDirectionFieldUpdateOperationsInput | $Enums.Direction | null
    correctedBy?: NullableStringFieldUpdateOperationsInput | string | null
    correctionNote?: NullableStringFieldUpdateOperationsInput | string | null
    correctedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PunchUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventTime?: DateTimeFieldUpdateOperationsInput | Date | string
    correctEventTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direction?: EnumDirectionFieldUpdateOperationsInput | $Enums.Direction
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directionCorrected?: BoolFieldUpdateOperationsInput | boolean
    originalDirection?: NullableEnumDirectionFieldUpdateOperationsInput | $Enums.Direction | null
    correctedBy?: NullableStringFieldUpdateOperationsInput | string | null
    correctionNote?: NullableStringFieldUpdateOperationsInput | string | null
    correctedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PunchUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventTime?: DateTimeFieldUpdateOperationsInput | Date | string
    correctEventTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direction?: EnumDirectionFieldUpdateOperationsInput | $Enums.Direction
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directionCorrected?: BoolFieldUpdateOperationsInput | boolean
    originalDirection?: NullableEnumDirectionFieldUpdateOperationsInput | $Enums.Direction | null
    correctedBy?: NullableStringFieldUpdateOperationsInput | string | null
    correctionNote?: NullableStringFieldUpdateOperationsInput | string | null
    correctedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceDayUpdateWithoutUserInput = {
    workDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    firstIn?: NullableStringFieldUpdateOperationsInput | string | null
    lastOut?: NullableStringFieldUpdateOperationsInput | string | null
    workedSeconds?: IntFieldUpdateOperationsInput | number
    notWorkingSeconds?: IntFieldUpdateOperationsInput | number
    overtimeSeconds?: IntFieldUpdateOperationsInput | number
    hadManual?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceDayUncheckedUpdateWithoutUserInput = {
    workDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    firstIn?: NullableStringFieldUpdateOperationsInput | string | null
    lastOut?: NullableStringFieldUpdateOperationsInput | string | null
    workedSeconds?: IntFieldUpdateOperationsInput | number
    notWorkingSeconds?: IntFieldUpdateOperationsInput | number
    overtimeSeconds?: IntFieldUpdateOperationsInput | number
    hadManual?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceDayUncheckedUpdateManyWithoutUserInput = {
    workDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    firstIn?: NullableStringFieldUpdateOperationsInput | string | null
    lastOut?: NullableStringFieldUpdateOperationsInput | string | null
    workedSeconds?: IntFieldUpdateOperationsInput | number
    notWorkingSeconds?: IntFieldUpdateOperationsInput | number
    overtimeSeconds?: IntFieldUpdateOperationsInput | number
    hadManual?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryConfigUpdateWithoutUserInput = {
    basicSalary?: FloatFieldUpdateOperationsInput | number
    otRate?: NullableFloatFieldUpdateOperationsInput | number | null
    allowance?: NullableFloatFieldUpdateOperationsInput | number | null
    deduction?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryConfigUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    basicSalary?: FloatFieldUpdateOperationsInput | number
    otRate?: NullableFloatFieldUpdateOperationsInput | number | null
    allowance?: NullableFloatFieldUpdateOperationsInput | number | null
    deduction?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryConfigUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    basicSalary?: FloatFieldUpdateOperationsInput | number
    otRate?: NullableFloatFieldUpdateOperationsInput | number | null
    allowance?: NullableFloatFieldUpdateOperationsInput | number | null
    deduction?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryRecordUpdateWithoutUserInput = {
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    basicSalary?: FloatFieldUpdateOperationsInput | number
    totalLeave?: IntFieldUpdateOperationsInput | number
    leaveDeductions?: FloatFieldUpdateOperationsInput | number
    overtimePay?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryRecordUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    basicSalary?: FloatFieldUpdateOperationsInput | number
    totalLeave?: IntFieldUpdateOperationsInput | number
    leaveDeductions?: FloatFieldUpdateOperationsInput | number
    overtimePay?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryRecordUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    basicSalary?: FloatFieldUpdateOperationsInput | number
    totalLeave?: IntFieldUpdateOperationsInput | number
    leaveDeductions?: FloatFieldUpdateOperationsInput | number
    overtimePay?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Leave_request_dateCreateManyRequestInput = {
    id?: number
    leaveDate: Date | string
    isHalfDay?: boolean
    halfdayType?: $Enums.HalfdayType | null
  }

  export type Leave_request_dateUpdateWithoutRequestInput = {
    leaveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isHalfDay?: BoolFieldUpdateOperationsInput | boolean
    halfdayType?: NullableEnumHalfdayTypeFieldUpdateOperationsInput | $Enums.HalfdayType | null
  }

  export type Leave_request_dateUncheckedUpdateWithoutRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    leaveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isHalfDay?: BoolFieldUpdateOperationsInput | boolean
    halfdayType?: NullableEnumHalfdayTypeFieldUpdateOperationsInput | $Enums.HalfdayType | null
  }

  export type Leave_request_dateUncheckedUpdateManyWithoutRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    leaveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isHalfDay?: BoolFieldUpdateOperationsInput | boolean
    halfdayType?: NullableEnumHalfdayTypeFieldUpdateOperationsInput | $Enums.HalfdayType | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}